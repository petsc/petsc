/* $Id: eventLog.c,v 1.3 2000/08/16 05:14:09 knepley Exp $ */

#include "petsc.h"        /*I    "petsc.h"   I*/
#include "src/sys/src/plog/ptime.h"
#include "plog.h"

/* Variables for the tracing logger */
extern FILE          *tracefile;
extern int            tracelevel;
extern char          *traceblanks;
extern char           tracespace[128];
extern PetscLogDouble tracetime;

/*------------------------------------------------ General Functions ------------------------------------------------*/
#undef __FUNCT__  
#define __FUNCT__ "EventLogDestroy"
/*
  EventLogDestroy - This destroys a EventLog object.

  Not collective

  Input Paramter:
. eventLog - The EventLog

  Level: beginner

.keywords: log, event, destroy
.seealso: EventLogCreate()
*/
int EventLogDestroy(EventLog eventLog)
{
  int event;
  int ierr;

  PetscFunctionBegin;
  for(event = 0; event < eventLog->numEvents; event++) {
    ierr = PerfInfoDestroy(&eventLog->eventInfo[event]);                                                  CHKERRQ(ierr);
  }
  ierr = PetscFree(eventLog->eventInfo);                                                                  CHKERRQ(ierr);
  ierr = PetscFree(eventLog);                                                                             CHKERRQ(ierr);
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogCopy"
/*
  EventLogCopy - This copys an EventLog object.

  Not collective

  Input Parameter:
. eventLog - The EventLog

  Output Parameter:
. newLog   - The copy

  Level: beginner

.keywords: log, event, copy
.seealso: EventLogCreate(), EventLogDestroy()
*/
int EventLogCopy(EventLog eventLog, EventLog *newLog)
{
  EventLog l;
  int      event;
  int      ierr;

  PetscFunctionBegin;
  ierr = PetscNew(struct _EventLog, &l);                                                                  CHKERRQ(ierr);
  l->numEvents   = eventLog->numEvents;
  l->maxEvents   = eventLog->maxEvents;
  ierr = PetscMalloc(l->maxEvents * sizeof(PerfInfo), &l->eventInfo);                                     CHKERRQ(ierr);
  for(event = 0; event < eventLog->numEvents; event++) {
    ierr = PetscStrallocpy(eventLog->eventInfo[event].name, &l->eventInfo[event].name);                   CHKERRQ(ierr);
    if (eventLog->eventInfo[event].color) {
      ierr = PetscStrallocpy(eventLog->eventInfo[event].color, &l->eventInfo[event].color);               CHKERRQ(ierr);
    } else {
      l->eventInfo[event].color       = PETSC_NULL;
    }
    l->eventInfo[event].id            = eventLog->eventInfo[event].id;
    l->eventInfo[event].cookie        = eventLog->eventInfo[event].cookie;
    l->eventInfo[event].active        = eventLog->eventInfo[event].active;
    l->eventInfo[event].visible       = eventLog->eventInfo[event].visible;
    l->eventInfo[event].depth         = 0;
    l->eventInfo[event].count         = 0;
    l->eventInfo[event].flops         = 0.0;
    l->eventInfo[event].time          = 0.0;
    l->eventInfo[event].numMessages   = 0.0;
    l->eventInfo[event].messageLength = 0.0;
    l->eventInfo[event].numReductions = 0.0;
  }
  *newLog = l;
  PetscFunctionReturn(0);
}

/*--------------------------------------------- Registration Functions ----------------------------------------------*/
#undef __FUNCT__  
#define __FUNCT__ "EventLogRegister"
/*@C
  EventLogRegister - Registers an event for logging operations in an application code. 
  A prefered event id is given on input, and the actual id is returned on output. If
  the user has no preference, PETSC_DECIDE will cause the id to be automatically
  assigned, and unique in this EventLog.

  Not Collective

  Input Parameters:
+ eventLog - The EventLog
. ename    - The name associated with the event
. color    - [Optional] A string specifying a color and display pattern
             for viewing an event, used by Upshot/Nupshot to view logs
             generated by -log_mpe (e.g., - "red:", "green:vlines3");
             use PETSC_NULL to let PETSc assign a color.
. cookie   - The cookie associated to the class for this event
- event    - The prefered event id (or PETSC_DECIDE), and the actual event id on output

  Example of Usage:
.vb
      int USER_EVENT;
      int user_event_flops;
      PetscLogEventRegister(&USER_EVENT,"User event name","EventColor");
      PetscLogEventBegin(USER_EVENT,0,0,0,0);
         [code segment to monitor]
         PetscLogFlops(user_event_flops);
      PetscLogEventEnd(USER_EVENT,0,0,0,0);
.ve

  Notes: 
  PETSc automatically logs library events if the code has been
  compiled with -DPETSC_USE_LOG (which is the default) and -log,
  -log_summary, or -log_all are specified.  PetscLogEventRegister() is
  intended for logging user events to supplement this PETSc
  information. 

  PETSc can gather data for use with the utilities Upshot/Nupshot
  (part of the MPICH distribution).  If PETSc has been compiled
  with flag -DPETSC_HAVE_MPE (MPE is an additional utility within
  MPICH), the user can employ another command line option, -log_mpe,
  to create a logfile, "mpe.log", which can be visualized
  Upshot/Nupshot. The color argument is used by this utility
  in forming the display of this event; the standard X-windows
  color names should be used.

  Level: intermediate

.keywords: log, event, register
.seealso: PetscLogEventBegin(), PetscLogEventEnd(), PetscLogFlops(), PetscLogEventMPEActivate(), PetscLogEventMPEDeactivate(),
          EventLogActivate(), EventLogDeactivate()
@*/
int EventLogRegister(EventLog eventLog, const char ename[], const char color[], int cookie, int *event)
{
  PerfInfo *eventInfo;
  char     *cstr = PETSC_NULL;
  char     *str;
  int       e;
  int       ierr;

  PetscFunctionBegin;
  PetscValidCharPointer(ename);
  PetscValidIntPointer(event);
  e = eventLog->numEvents++;
  if (eventLog->numEvents > eventLog->maxEvents) {
    ierr = PetscMalloc(eventLog->maxEvents*2 * sizeof(PerfInfo), &eventInfo);                             CHKERRQ(ierr);
    ierr = PetscMemcpy(eventInfo,   eventLog->eventInfo,   eventLog->maxEvents * sizeof(PerfInfo));       CHKERRQ(ierr);
    ierr = PetscFree(eventLog->eventInfo);                                                                CHKERRQ(ierr);
    eventLog->eventInfo  = eventInfo;
    eventLog->maxEvents *= 2;
  }
  ierr = PetscStrallocpy(ename, &str);                                                                    CHKERRQ(ierr);
  if (color != PETSC_NULL) {
    PetscValidCharPointer(color);
    ierr = PetscStrallocpy(color, &cstr);                                                                 CHKERRQ(ierr);
  }
  eventLog->eventInfo[e].name          = str;
  eventLog->eventInfo[e].color         = cstr;
  eventLog->eventInfo[e].cookie        = cookie;
  eventLog->eventInfo[e].active        = PETSC_TRUE;
  eventLog->eventInfo[e].visible       = PETSC_TRUE;
  eventLog->eventInfo[e].depth         = 0;
  eventLog->eventInfo[e].count         = 0;
  eventLog->eventInfo[e].flops         = 0.0;
  eventLog->eventInfo[e].time          = 0.0;
  eventLog->eventInfo[e].numMessages   = 0.0;
  eventLog->eventInfo[e].messageLength = 0.0;
  eventLog->eventInfo[e].numReductions = 0.0;
  if (*event == PETSC_DECIDE) {
    eventLog->eventInfo[e].id          = ++PETSC_LARGEST_EVENT;
  } else if (cookie >= 0) {
    eventLog->eventInfo[e].id          = *event;
    /* Need to check here for montonicity and insert if necessary */
  } else {
    SETERRQ1(PETSC_ERR_ARG_OUTOFRANGE, "Invalid suggested event id %d", *event);
  }
#if defined(PETSC_HAVE_MPE)
  if (UseMPE) {
    int rank;

    ierr = MPI_Comm_rank(PETSC_COMM_WORLD, &rank);                                                        CHKERRQ(ierr);
    if (!rank) {
      MPE_Describe_state(MPEBEGIN+2*e, MPEBEGIN+2*e+1, str, cstr);
    }
  }
#endif
  *event = eventLog->eventInfo[e].id;
  PetscFunctionReturn(0);
}

/*---------------------------------------------- Activation Functions -----------------------------------------------*/
#undef __FUNCT__  
#define __FUNCT__ "EventLogActivate"
/*@C
  EventLogActivate - Indicates that a particular event should be logged.

  Not Collective

  Input Parameters:
+ eventLog - The EventLog
- event    - The event id

   Usage:
.vb
      EventLogDeactivate(log, VEC_SetValues);
        [code where you do not want to log VecSetValues()]
      EventLogActivate(log, VEC_SetValues);
        [code where you do want to log VecSetValues()]
.ve 

  Note:
  The event may be either a pre-defined PETSc event (found in 
  include/petsclog.h) or an event number obtained with EventLogRegister().

  Level: advanced

.keywords: log, event, activate
.seealso: PetscLogEventMPEDeactivate(), PetscLogEventMPEActivate(), EventLogDeactivate()
@*/
int EventLogActivate(EventLog eventLog, int event)
{
  int eventNum;
  int ierr;

  PetscFunctionBegin;
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  eventLog->eventInfo[eventNum].active = PETSC_TRUE;
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogDeactivate"
/*@C
  EventLogDeactivate - Indicates that a particular event should not be logged.

  Not Collective

  Input Parameters:
+ eventLog - The EventLog
- event    - The event id

   Usage:
.vb
      EventLogDeactivate(log, VEC_SetValues);
        [code where you do not want to log VecSetValues()]
      EventLogActivate(log, VEC_SetValues);
        [code where you do want to log VecSetValues()]
.ve 

  Note:
  The event may be either a pre-defined PETSc event (found in 
  include/petsclog.h) or an event number obtained with EventLogRegister().

  Level: advanced

.keywords: log, event, activate
.seealso: PetscLogEventMPEDeactivate(), PetscLogEventMPEActivate(), EventLogActivate()
@*/
int EventLogDeactivate(EventLog eventLog, int event)
{
  int eventNum;
  int ierr;

  PetscFunctionBegin;
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  eventLog->eventInfo[eventNum].active = PETSC_FALSE;
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogActivateClass"
/*@C
  EventLogActivateClass - Activates event logging for a PETSc object class.

  Not Collective

  Input Parameter:
. cookie - The class id, for example MAT_COOKIE, SNES_COOKIE,

  Level: developer

.seealso: EventLogDeactivateClass(), EventLogActivate(), EventLogDeactivate()
@*/
int EventLogActivateClass(EventLog eventLog, int cookie)
{
  int e;

  PetscFunctionBegin;
  for(e = 0; e < eventLog->numEvents; e++) {
    if (eventLog->eventInfo[e].cookie == cookie) eventLog->eventInfo[e].active = PETSC_TRUE;
  }
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogDeactivateClass"
/*@C
  EventLogDeactivateClass - Deactivates event logging for a PETSc object class.

  Not Collective

  Input Parameter:
. cookie - The class id, for example MAT_COOKIE, SNES_COOKIE,

  Level: developer

.seealso: EventLogDeactivateClass(), EventLogDeactivate(), EventLogActivate()
@*/
int EventLogDeactivateClass(EventLog eventLog, int cookie)
{
  int e;

  PetscFunctionBegin;
  for(e = 0; e < eventLog->numEvents; e++) {
    if (eventLog->eventInfo[e].cookie == cookie) eventLog->eventInfo[e].active = PETSC_FALSE;
  }
  PetscFunctionReturn(0);
}

/*------------------------------------------------ Query Functions --------------------------------------------------*/
#undef __FUNCT__  
#define __FUNCT__ "EventLogSetVisible"
/*@C
  EventLogSetVisible - This function determines whether an event is printed during PetscLogPrintSummary()

  Not Collective

  Input Parameters:
+ eventLog  - The EventLog
. event     - The event id to log
- isVisible - The visibility flag, PETSC_TRUE for printing, otherwise PETSC_FALSE (default is PETSC_TRUE)

  Database Options:
. -log_summary - Activates log summary

  Level: intermediate

.keywords: log, visible, event
.seealso: EventLogGetVisible(), EventLogGetCurrent(), EventLogRegister(), StageLogGetEventLog()
@*/
int EventLogSetVisible(EventLog eventLog, int event, PetscTruth isVisible)
{
  int eventNum;
  int ierr;

  PetscFunctionBegin;
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  eventLog->eventInfo[eventNum].visible = isVisible;
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogGetVisible"
/*@C
  EventLogGetVisible - This function returns whether an event is printed during PetscLogPrintSummary()

  Not Collective

  Input Parameters:
+ eventLog  - The EventLog
- event     - The event id to log

  Output Parameter:
. isVisible - The visibility flag, PETSC_TRUE for printing, otherwise PETSC_FALSE (default is PETSC_TRUE)

  Database Options:
. -log_summary - Activates log summary

  Level: intermediate

.keywords: log, visible, event
.seealso: EventLogSetVisible(), EventLogGetCurrent(), EventLogRegister(), StageLogGetEventLog()
@*/
int EventLogGetVisible(EventLog eventLog, int event, PetscTruth *isVisible)
{
  int eventNum;
  int ierr;

  PetscFunctionBegin;
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  PetscValidIntPointer(isVisible);
  *isVisible = eventLog->eventInfo[eventNum].visible;
  PetscFunctionReturn(0);
}

#undef __FUNCT__  
#define __FUNCT__ "EventLogGetEvent"
/*@C
  EventLogGetEvent - This function returns the event number corresponding to a given event id.

  Not Collective

  Input Parameters:
+ eventLog - The EventLog
- event    - The event id
            
  Output Parameter:
. eventNum - The event number

  Level: developer

.keywords: log, event
.seealso: PetscLogEventRegister(), PetscLogObjCreateDefault(), PetscLogObjDestroyDefault()
@*/
int EventLogGetEvent(EventLog eventLog, int event, int *eventNum)
{
  int e;

  PetscFunctionBegin;
  PetscValidIntPointer(eventNum);
  for(e = 0; e < eventLog->numEvents; e++) {
    /* Could do bisection here */
    if (eventLog->eventInfo[e].id == event) break;
  }
  if (e >= eventLog->numEvents) SETERRQ1(PETSC_ERR_ARG_WRONG, "Invalid event id %d", event);
  *eventNum = e;
  PetscFunctionReturn(0);
}

/*------------------------------------------------ Action Functions -------------------------------------------------*/
/* Default event begin logger */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventBeginDefault"
int PetscLogEventBeginDefault(int event, int t, PetscObject o1, PetscObject o2, PetscObject o3, PetscObject o4)
{
  StageLog stageLog;
  EventLog eventLog;
  int      stage, eventNum;
  int      ierr;

  PetscFunctionBegin;
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth++;
  if (eventLog->eventInfo[eventNum].depth > 1) PetscFunctionReturn(0);
  /* Log performance info */
  eventLog->eventInfo[eventNum].count++;
  PetscTimeSubtract(eventLog->eventInfo[eventNum].time);
  eventLog->eventInfo[eventNum].flops         -= _TotalFlops;
  eventLog->eventInfo[eventNum].numMessages   -= irecv_ct  + isend_ct  + recv_ct  + send_ct;
  eventLog->eventInfo[eventNum].messageLength -= irecv_len + isend_len + recv_len + send_len;
  eventLog->eventInfo[eventNum].numReductions -= allreduce_ct;
  PetscFunctionReturn(0);
}

/* Default event end logger */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventEndDefault"
int PetscLogEventEndDefault(int event, int t, PetscObject o1, PetscObject o2, PetscObject o3, PetscObject o4)
{
  StageLog stageLog;
  EventLog eventLog;
  int      stage, eventNum;
  int      ierr;

  PetscFunctionBegin;
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth--;
  if (eventLog->eventInfo[eventNum].depth > 0) {
    PetscFunctionReturn(0);
  } else if (eventLog->eventInfo[eventNum].depth < 0) {
    SETERRQ(PETSC_ERR_ARG_WRONGSTATE, "Logging event had unbalanced begin/end pairs");
  }
  /* Log performance info */
  PetscTimeAdd(eventLog->eventInfo[eventNum].time);
  eventLog->eventInfo[eventNum].flops         += _TotalFlops;
  eventLog->eventInfo[eventNum].numMessages   += irecv_ct  + isend_ct  + recv_ct  + send_ct;
  eventLog->eventInfo[eventNum].messageLength += irecv_len + isend_len + recv_len + send_len;
  eventLog->eventInfo[eventNum].numReductions += allreduce_ct;
  PetscFunctionReturn(0);
}

/* Event begin logger with complete logging */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventBeginComplete"
int PetscLogEventBeginComplete(int event, int t, PetscObject o1, PetscObject o2, PetscObject o3, PetscObject o4)
{
  StageLog       stageLog;
  EventLog       eventLog;
  Action        *tmpAction;
  PetscLogDouble start, end;
  PetscLogDouble curTime;
  int            stage, eventNum;
  int            ierr;

  PetscFunctionBegin;
  /* Dynamically enlarge logging structures */
  if (numActions >= maxActions) {
    PetscTime(start);
    ierr = PetscMalloc(maxActions*2 * sizeof(Action), &tmpAction);                                        CHKERRQ(ierr);
    ierr = PetscMemcpy(tmpAction, actions, maxActions * sizeof(Action));                                  CHKERRQ(ierr);
    ierr = PetscFree(actions);                                                                            CHKERRQ(ierr);
    actions     = tmpAction;
    maxActions *= 2;
    PetscTime(end);
    BaseTime += (end - start);
  }
  /* Record the event */
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  PetscTime(curTime);
  if (actions != PETSC_NULL) {
    actions[numActions].time     = curTime - BaseTime;
    actions[numActions++].action = ACTIONBEGIN;
    actions[numActions].event    = event;
    actions[numActions].cookie   = eventLog->eventInfo[eventNum].cookie;
    if (o1) actions[numActions].id1 = o1->id; else actions[numActions].id1 = -1;
    if (o2) actions[numActions].id2 = o2->id; else actions[numActions].id2 = -1;
    if (o3) actions[numActions].id3 = o3->id; else actions[numActions].id3 = -1;
    actions[numActions].flops    = _TotalFlops;
    ierr = PetscTrSpace(&actions[numActions].mem, PETSC_NULL, &actions[numActions].maxmem);               CHKERRQ(ierr);
  }
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth++;
  if (eventLog->eventInfo[eventNum].depth > 1) PetscFunctionReturn(0);
  /* Log the performance info */
  eventLog->eventInfo[eventNum].count++;
  eventLog->eventInfo[eventNum].time          -= curTime;
  eventLog->eventInfo[eventNum].flops         -= _TotalFlops;
  eventLog->eventInfo[eventNum].numMessages   -= irecv_ct  + isend_ct  + recv_ct  + send_ct;
  eventLog->eventInfo[eventNum].messageLength -= irecv_len + isend_len + recv_len + send_len;
  eventLog->eventInfo[eventNum].numReductions -= allreduce_ct;
  PetscFunctionReturn(0);
}

/* Event end logger with complete logging */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventEndComplete"
int PetscLogEventEndComplete(int event, int t, PetscObject o1, PetscObject o2, PetscObject o3, PetscObject o4)
{
  StageLog       stageLog;
  EventLog       eventLog;
  Action        *tmpAction;
  PetscLogDouble start, end;
  PetscLogDouble curTime;
  int            stage, eventNum;
  int            ierr;

  PetscFunctionBegin;
  /* Dynamically enlarge logging structures */
  if (numActions >= maxActions) {
    PetscTime(start);
    ierr = PetscMalloc(maxActions*2 * sizeof(Action), &tmpAction);                                        CHKERRQ(ierr);
    ierr = PetscMemcpy(tmpAction, actions, maxActions * sizeof(Action));                                  CHKERRQ(ierr);
    ierr = PetscFree(actions);                                                                            CHKERRQ(ierr);
    actions     = tmpAction;
    maxActions *= 2;
    PetscTime(end);
    BaseTime += (end - start);
  }
  /* Record the event */
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  PetscTime(curTime);
  if (actions != PETSC_NULL) {
    actions[numActions].time     = curTime - BaseTime;
    actions[numActions++].action = ACTIONEND;
    actions[numActions].event    = event;
    actions[numActions].cookie   = eventLog->eventInfo[eventNum].cookie;
    if (o1) actions[numActions].id1 = o1->id; else actions[numActions].id1 = -1;
    if (o2) actions[numActions].id2 = o2->id; else actions[numActions].id2 = -1;
    if (o3) actions[numActions].id3 = o3->id; else actions[numActions].id3 = -1;
    actions[numActions].flops    = _TotalFlops;
    ierr = PetscTrSpace(&actions[numActions].mem, PETSC_NULL, &actions[numActions].maxmem);               CHKERRQ(ierr);
  }
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth--;
  if (eventLog->eventInfo[eventNum].depth > 0) {
    PetscFunctionReturn(0);
  } else if (eventLog->eventInfo[eventNum].depth < 0) {
    SETERRQ(PETSC_ERR_ARG_WRONGSTATE, "Logging event had unbalanced begin/end pairs");
  }
  /* Log the performance info */
  eventLog->eventInfo[eventNum].count++;
  eventLog->eventInfo[eventNum].time          += curTime;
  eventLog->eventInfo[eventNum].flops         += _TotalFlops;
  eventLog->eventInfo[eventNum].numMessages   += irecv_ct  + isend_ct  + recv_ct  + send_ct;
  eventLog->eventInfo[eventNum].messageLength += irecv_len + isend_len + recv_len + send_len;
  eventLog->eventInfo[eventNum].numReductions += allreduce_ct;
  PetscFunctionReturn(0);
}

/* Tracing event begin logger */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventBeginTrace"
int PetscLogEventBeginTrace(int event, int t, PetscObject o1, PetscObject o2, PetscObject o3, PetscObject o4)
{
  StageLog       stageLog;
  EventLog       eventLog;
  PetscLogDouble cur_time;
  int            rank, stage, eventNum;
  int            ierr;

  PetscFunctionBegin;
  if (tracetime == 0.0) {PetscTime(tracetime);}

  ierr = MPI_Comm_rank(PETSC_COMM_WORLD, &rank);                                                          CHKERRQ(ierr);
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth++;
  if (eventLog->eventInfo[eventNum].depth > 1) PetscFunctionReturn(0);
  /* Log performance info */
  ierr = PetscStrncpy(tracespace, traceblanks, 2*tracelevel);                                             CHKERRQ(ierr);
  tracespace[2*tracelevel] = 0;
  PetscTime(cur_time);
  fprintf(tracefile, "%s[%d] %g Event begin: %s\n", tracespace, rank, cur_time-tracetime, eventLog->eventInfo[eventNum].name);
  fflush(tracefile);
  tracelevel++;

  PetscFunctionReturn(0);
}

/* Tracing event end logger */
#undef __FUNCT__  
#define __FUNCT__ "PetscLogEventEndTrace"
int PetscLogEventEndTrace(int event,int t,PetscObject o1,PetscObject o2,PetscObject o3,PetscObject o4)
{
  StageLog       stageLog;
  EventLog       eventLog;
  PetscLogDouble cur_time;
  int            rank, stage, eventNum;
  int            ierr;

  PetscFunctionBegin;
  tracelevel--;
  ierr = MPI_Comm_rank(PETSC_COMM_WORLD, &rank);                                                          CHKERRQ(ierr);
  ierr = PetscLogGetStageLog(&stageLog);                                                                  CHKERRQ(ierr);
  ierr = StageLogGetCurrent(stageLog, &stage);                                                            CHKERRQ(ierr);
  ierr = StageLogGetEventLog(stageLog, stage, &eventLog);                                                 CHKERRQ(ierr);
  ierr = EventLogGetEvent(eventLog, event, &eventNum);                                                    CHKERRQ(ierr);
  /* Check for double counting */
  eventLog->eventInfo[eventNum].depth--;
  if (eventLog->eventInfo[eventNum].depth > 0) {
    PetscFunctionReturn(0);
  } else if (eventLog->eventInfo[eventNum].depth < 0) {
    SETERRQ(PETSC_ERR_ARG_WRONGSTATE, "Logging event had unbalanced begin/end pairs");
  }
  /* Log performance info */
  ierr = PetscStrncpy(tracespace, traceblanks, 2*tracelevel);                                             CHKERRQ(ierr);
  tracespace[2*tracelevel] = 0;
  PetscTime(cur_time);
  fprintf(tracefile, "%s[%d] %g Event end: %s\n", tracespace, rank, cur_time-tracetime, eventLog->eventInfo[eventNum].name);
  fflush(tracefile);
  PetscFunctionReturn(0);
}

/*----------------------------------------------- Creation Function -------------------------------------------------*/
#undef __FUNCT__  
#define __FUNCT__ "EventLogCreate"
/*
  EventLogCreate - This creates a EventLog object.

  Not collective

  Input Parameter:
. eventLog - The EventLog

  Level: beginner

.keywords: log, event, create
.seealso: EventLogDestroy(), StageLogCreate()
*/
int EventLogCreate(EventLog *eventLog)
{
  EventLog l;
  int      ierr;

  PetscFunctionBegin;
  ierr = PetscNew(struct _EventLog, &l);                                                                  CHKERRQ(ierr);
  l->numEvents   = 0;
  l->maxEvents   = 100;
  ierr = PetscMalloc(l->maxEvents * sizeof(PerfInfo), &l->eventInfo);                                     CHKERRQ(ierr);
  *eventLog = l;
  PetscFunctionReturn(0);
}
