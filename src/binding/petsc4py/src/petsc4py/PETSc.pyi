from __future__ import annotations
import sys
from threading import Lock
from typing import (
    Any,
    Union,
    Optional,
    NoReturn,
    overload,
)
if sys.version_info >= (3, 8):
    from typing import (
        final,
        Final,
        Literal,
    )
else:
    from typing_extensions import (
        final,
        Final,
        Literal,
    )
if sys.version_info >= (3, 9):
    from collections.abc import (
        Callable,
        Hashable,
        Iterable,
        Iterator,
        Sequence,
        Mapping,
    )
else:
    from typing import (
        Callable,
        Hashable,
        Iterable,
        Iterator,
        Sequence,
        Mapping,
    )
if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self
from os import PathLike

import numpy

from numpy import (
    dtype,
    ndarray,
)

from mpi4py.MPI import (
    Datatype,
    Intracomm,
    Op,
)

from petsc4py.typing import (
    Scalar,
    ArrayBool,
    ArrayComplex,
    ArrayInt,
    ArrayReal,
    ArrayScalar,
    CSRIndicesSpec,
    CSRSpec,
    DMCoarsenHookFunction,
    DMRestrictHookFunction,
    DimsSpec,
    KSPConvergenceTestFunction,
    KSPMonitorFunction,
    KSPOperatorsFunction,
    KSPPostSolveFunction,
    KSPPreSolveFunction,
    KSPRHSFunction,
    LayoutSizeSpec,
    MatAssemblySpec,
    MatBlockSizeSpec,
    MatNullFunction,
    MatSizeSpec,
    NNZSpec,
    NormTypeSpec,
    PetscOptionsHandlerFunction,
    ScatterModeSpec,
    SNESMonitorFunction,
    SNESObjFunction,
    SNESFunction,
    SNESJacobianFunction,
    SNESGuessFunction,
    SNESUpdateFunction,
    SNESLSPreFunction,
    SNESNGSFunction,
    SNESConvergedFunction,
    TAOConstraintsFunction,
    TAOConstraintsJacobianFunction,
    TAOConvergedFunction,
    TAOGradientFunction,
    TAOHessianFunction,
    TAOJacobianFunction,
    TAOJacobianResidualFunction,
    TAOMonitorFunction,
    TAOObjectiveFunction,
    TAOObjectiveGradientFunction,
    TAOResidualFunction,
    TAOUpdateFunction,
    TAOVariableBoundsFunction,
    TAOLSGradientFunction,
    TAOLSObjectiveFunction,
    TAOLSObjectiveGradientFunction,
    TSI2Function,
    TSI2Jacobian,
    TSI2JacobianP,
    TSIFunction,
    TSIJacobian,
    TSIJacobianP,
    TSIndicatorFunction,
    TSMonitorFunction,
    TSPostEventFunction,
    TSPostStepFunction,
    TSPreStepFunction,
    TSRHSFunction,
    TSRHSJacobian,
    TSRHSJacobianP,
    AccessModeSpec,
    InsertModeSpec,
)

IntType: numpy.dtype = ...
RealType: numpy.dtype = ...
ComplexType: numpy.dtype = ...
ScalarType: numpy.dtype = ...

DECIDE: Final[int] = ...
DEFAULT: Final[int] = ...
DETERMINE: Final[int] = ...
CURRENT: Final[int] = ...
UNLIMITED: Final[int] = ...

class Comm:
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def destroy(self) -> None: ...
    def duplicate(self) -> Self: ...
    def getSize(self) -> int: ...
    def getRank(self) -> int: ...
    def barrier(self) -> None: ...
    def tompi4py(self) -> Intracomm: ...
    size: int
    rank: int
    fortran: int
    Free = destroy
    Clone = duplicate
    Dup = duplicate
    Get_size = getSize
    Get_rank = getRank
    Barrier = barrier

COMM_NULL: Final[Comm] = ...
COMM_SELF: Final[Comm] = ...
COMM_WORLD: Final[Comm] = ...

class Object:
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def getType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def viewFromOptions(self, name: str, objpre: Object | None = None) -> None: ...
    def setOptionsHandler(self, handler: PetscOptionsHandlerFunction | None) -> None: ...
    def destroyOptionsHandlers(self) -> None: ...
    def getComm(self) -> Comm: ...
    def getName(self) -> str: ...
    def setName(self, name: str | None) -> None: ...
    def getClassId(self) -> int: ...
    def getClassName(self) -> str: ...
    def getRefCount(self) -> int: ...
    def getId(self) -> int: ...
    def compose(self, name: str | None, obj: Object) -> None: ...
    def query(self, name: str) -> Object: ...
    def incRef(self) -> int: ...
    def decRef(self) -> int: ...
    def getAttr(self, name: str) -> object: ...
    def setAttr(self, name: str, attr: object) -> None: ...
    def getDict(self) -> dict: ...
    def stateIncrease(self) -> None: ...
    def stateGet(self) -> int: ...
    def stateSet(self, state: int) -> None: ...
    def incrementTabLevel(self, tab: int, parent: Object | None = None) -> None: ...
    def setTabLevel(self, level: int) -> None: ...
    def getTabLevel(self) -> None: ...
    type: str
    prefix: str
    comm: Comm
    name: str
    classid: int
    id: int
    klass: str
    refcount: int
    handle: int
    fortran: int

class Viewer(Object):
    class Type:
        SOCKET: Final[str] = ...
        ASCII: Final[str] = ...
        BINARY: Final[str] = ...
        STRING: Final[str] = ...
        DRAW: Final[str] = ...
        VU: Final[str] = ...
        MATHEMATICA: Final[str] = ...
        HDF5: Final[str] = ...
        VTK: Final[str] = ...
        MATLAB: Final[str] = ...
        SAWS: Final[str] = ...
        GLVIS: Final[str] = ...
        ADIOS: Final[str] = ...
        EXODUSII: Final[str] = ...
        PYTHON: Final[str] = ...
        PYVISTA: Final[str] = ...
    class Format:
        DEFAULT: Final[int] = ...
        ASCII_MATLAB: Final[int] = ...
        ASCII_MATHEMATICA: Final[int] = ...
        ASCII_IMPL: Final[int] = ...
        ASCII_INFO: Final[int] = ...
        ASCII_INFO_DETAIL: Final[int] = ...
        ASCII_COMMON: Final[int] = ...
        ASCII_SYMMODU: Final[int] = ...
        ASCII_INDEX: Final[int] = ...
        ASCII_DENSE: Final[int] = ...
        ASCII_MATRIXMARKET: Final[int] = ...
        ASCII_PCICE: Final[int] = ...
        ASCII_PYTHON: Final[int] = ...
        ASCII_FACTOR_INFO: Final[int] = ...
        ASCII_LATEX: Final[int] = ...
        ASCII_XML: Final[int] = ...
        ASCII_GLVIS: Final[int] = ...
        ASCII_CSV: Final[int] = ...
        DRAW_BASIC: Final[int] = ...
        DRAW_LG: Final[int] = ...
        DRAW_LG_XRANGE: Final[int] = ...
        DRAW_CONTOUR: Final[int] = ...
        DRAW_PORTS: Final[int] = ...
        VTK_VTS: Final[int] = ...
        VTK_VTR: Final[int] = ...
        VTK_VTU: Final[int] = ...
        BINARY_MATLAB: Final[int] = ...
        NATIVE: Final[int] = ...
        HDF5_PETSC: Final[int] = ...
        HDF5_VIZ: Final[int] = ...
        HDF5_XDMF: Final[int] = ...
        HDF5_MAT: Final[int] = ...
        NOFORMAT: Final[int] = ...
        LOAD_BALANCE: Final[int] = ...
        FAILED: Final[int] = ...
    class FileMode:
        READ: Final[int] = ...
        WRITE: Final[int] = ...
        APPEND: Final[int] = ...
        UPDATE: Final[int] = ...
        APPEND_UPDATE: Final[int] = ...
        R: Final[int] = ...
        W: Final[int] = ...
        A: Final[int] = ...
        U: Final[int] = ...
        AU: Final[int] = ...
        UA: Final[int] = ...
    class DrawSize:
        FULL_SIZE: Final[int] = ...
        HALF_SIZE: Final[int] = ...
        THIRD_SIZE: Final[int] = ...
        QUARTER_SIZE: Final[int] = ...
        FULL: Final[int] = ...
        HALF: Final[int] = ...
        THIRD: Final[int] = ...
        QUARTER: Final[int] = ...
    
    
    def view(self, obj: Viewer | Object | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def createASCII(self, name: str, mode: FileMode | str | None = None, comm: Comm | None = None) -> Self: ...
    def createBinary(self, name: str, mode: FileMode | str | None = None, comm: Comm | None = None) -> Self: ...
    def createMPIIO(self, name: str, mode: FileMode | str | None = None, comm: Comm | None = None) -> Self: ...
    def createVTK(self, name: str, mode: FileMode | str | None = None, comm: Comm | None = None) -> Self: ...
    def createHDF5(self, name: str, mode: FileMode | str | None = None, comm: Comm | None = None) -> Self: ...
    def createDraw(self, display: str | None = None, title: str | None = None, position: tuple[int, int] | None = None, size: tuple[int, int] | int | None = None, comm: Comm | None = None) -> Self: ...
    def setType(self, vwr_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def getFormat(self) -> Format: ...
    def pushFormat(self, format: Format) -> None: ...
    def popFormat(self) -> None: ...
    def getSubViewer(self, comm: Comm | None = None) -> Viewer: ...
    def restoreSubViewer(self, sub: Viewer) -> None: ...
    @classmethod
    def STDOUT(cls, comm: Comm | None = None) -> Viewer: ...
    @classmethod
    def STDERR(cls, comm: Comm | None = None) -> Viewer: ...
    @classmethod
    def ASCII(cls, name: str, comm: Comm | None = None) -> Viewer: ...
    @classmethod
    def BINARY(cls, comm: Comm | None = None) -> Viewer: ...
    @classmethod
    def DRAW(cls, comm: Comm | None = None) -> Viewer: ...
    def setASCIITab(self, tabs: int) -> None: ...
    def getASCIITab(self) -> int: ...
    def addASCIITab(self, tabs: int) -> None: ...
    def subtractASCIITab(self, tabs: int) -> None: ...
    def pushASCIISynchronized(self) -> None: ...
    def popASCIISynchronized(self) -> None: ...
    def pushASCIITab(self) -> None: ...
    def popASCIITab(self) -> None: ...
    def useASCIITabs(self, flag: bool) -> None: ...
    def printfASCII(self, msg: str) -> None: ...
    def printfASCIISynchronized(self, msg: str) -> None: ...
    def flush(self) -> None: ...
    def setFileMode(self, mode: FileMode | str) -> None: ...
    def getFileMode(self) -> FileMode: ...
    def setFileName(self, name: str) -> None: ...
    def getFileName(self) -> str: ...
    def setDrawInfo(self, display: str | None = None, title: str | None = None, position: tuple[int, int] | None = None, size: tuple[int, int] | int | None = None) -> None: ...
    def clearDraw(self) -> None: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def viewObjectPython(self, obj: Object) -> None: ...

class Random(Object):
    class Type:
        RAND: Final[str] = ...
        RAND48: Final[str] = ...
        SPRNG: Final[str] = ...
        RANDER48: Final[str] = ...
        RANDOM123: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, rnd_type: Random.Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def getValue(self) -> Scalar: ...
    def getValueReal(self) -> float: ...
    def getSeed(self) -> int: ...
    def setSeed(self, seed: int | None = None) -> None: ...
    def getInterval(self) -> tuple[Scalar, Scalar]: ...
    def setInterval(self, interval: tuple[Scalar, Scalar]) -> None: ...
    seed: int
    interval: tuple[Scalar, Scalar]

class Device:
    class Type:
        HOST: Final[int] = ...
        CUDA: Final[int] = ...
        HIP: Final[int] = ...
        SYCL: Final[int] = ...
        DEFAULT: Final[int] = ...
    @classmethod
    def create(cls, dtype: Type | None = None, device_id: int = DECIDE) -> Device: ...
    def destroy(self) -> None: ...
    def configure(self) -> None: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def getDeviceType(self) -> str: ...
    def getDeviceId(self) -> int: ...
    @staticmethod
    def setDefaultType(device_type: Type | str) -> None: ...
    type: str
    device_id: int

class DeviceContext(Object):
    class JoinMode:
        DESTROY: Final[int] = ...
        SYNC: Final[int] = ...
        NO_SYNC: Final[int] = ...
    class StreamType:
        DEFAULT: Final[int] = ...
        NONBLOCKING: Final[int] = ...
        DEFAULT_WITH_BARRIER: Final[int] = ...
        NONBLOCKING_WITH_BARRIER: Final[int] = ...
    def create(self) -> Self: ...
    def destroy(self) -> Self: ...
    def getStreamType(self) -> str: ...
    def setStreamType(self, stream_type: StreamType | str) -> None: ...
    def getDevice(self) -> Device: ...
    def setDevice(self, device: Device) -> None: ...
    def setUp(self) -> None: ...
    def duplicate(self) -> DeviceContext: ...
    def idle(self) -> bool: ...
    def waitFor(self, other: DeviceContext | None) -> None: ...
    def fork(self, n: int, stream_type: DeviceContext.StreamType | str | None = None) -> list[DeviceContext]: ...
    def join(self, join_mode: JoinMode | str, py_sub_ctxs: list[DeviceContext]) -> None: ...
    def synchronize(self) -> None: ...
    def setFromOptions(self, comm: Comm | None = None) -> None: ...
    @staticmethod
    def getCurrent() -> DeviceContext: ...
    @staticmethod
    def setCurrent(dctx: DeviceContext | None) -> None: ...
    stream_type: str
    device: Device
    current: DeviceContext

class IS(Object):
    class Type:
        GENERAL: Final[str] = ...
        BLOCK: Final[str] = ...
        STRIDE: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, is_type: IS.Type | str) -> None: ...
    def getType(self) -> str: ...
    def createGeneral(self, indices: Sequence[int], comm: Comm | None = None) -> Self: ...
    def createBlock(self, bsize: int, indices: Sequence[int], comm: Comm | None = None) -> Self: ...
    def createStride(self, size: int, first: int = 0, step: int = 1, comm: Comm | None = None) -> Self: ...
    def duplicate(self) -> IS: ...
    def copy(self, result: IS | None = None) -> IS: ...
    def load(self, viewer: Viewer) -> Self: ...
    def allGather(self) -> IS: ...
    def toGeneral(self) -> Self: ...
    def buildTwoSided(self, toindx: IS | None = None) -> IS: ...
    def invertPermutation(self, nlocal: int | None = None) -> IS: ...
    def partitioningToNumbering(self) -> IS: ...
    def partitioningCount(self, npart: int | None = None) -> ArrayInt: ...
    def getSize(self) -> int: ...
    def getLocalSize(self) -> int: ...
    def getSizes(self) -> tuple[int, int]: ...
    def getBlockSize(self) -> int: ...
    def setBlockSize(self, bs: int) -> None: ...
    def sort(self) -> Self: ...
    def isSorted(self) -> bool: ...
    def setPermutation(self) -> Self: ...
    def isPermutation(self) -> bool: ...
    def setIdentity(self) -> Self: ...
    def isIdentity(self) -> bool: ...
    def equal(self, iset: IS) -> bool: ...
    def sum(self, iset: IS) -> IS: ...
    def expand(self, iset: IS) -> IS: ...
    def union(self, iset: IS) -> IS: ...
    def difference(self, iset: IS) -> IS: ...
    def complement(self, nmin: int, nmax: int) -> IS: ...
    def embed(self, iset: IS, drop: bool) -> IS: ...
    def renumber(self, mult: IS | None = None) -> tuple[int, IS]: ...
    def setIndices(self, indices: Sequence[int]) -> None: ...
    def getIndices(self) -> ArrayInt: ...
    def setBlockIndices(self, bsize: int, indices: Sequence[int]) -> None: ...
    def getBlockIndices(self) -> ArrayInt: ...
    def setStride(self, size: int, first: int = 0, step: int = 1) -> None: ...
    def getStride(self) -> tuple[int, int, int]: ...
    def getInfo(self) -> tuple[int, int]: ...
    permutation: bool
    identity: bool
    sorted: bool
    sizes: tuple[int, int]
    size: int
    local_size: int
    block_size: int
    indices: ArrayInt
    array: ArrayInt

class LGMap(Object):
    class MapMode:
        MASK: Final[int] = ...
        DROP: Final[int] = ...
    class Type:
        BASIC: Final[str] = ...
        HASH: Final[str] = ...
    def setType(self, lgmap_type: LGMap.Type | str) -> None: ...
    def setFromOptions(self) -> None: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def load(self, viewer: Viewer) -> Self: ...
    def destroy(self) -> Self: ...
    def create(self, indices: Sequence[int], bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createIS(self, iset: IS) -> Self: ...
    def createSF(self, sf: SF, start: int) -> Self: ...
    def getSize(self) -> int: ...
    def getBlockSize(self) -> int: ...
    def getIndices(self) -> ArrayInt: ...
    def getBlockIndices(self) -> ArrayInt: ...
    def getInfo(self) -> dict[int, ArrayInt]: ...
    def getBlockInfo(self) -> dict[int, ArrayInt]: ...
    def apply(self, indices: Sequence[int], result: ArrayInt | None = None) -> ArrayInt: ...
    def applyBlock(self, indices: Sequence[int], result: ArrayInt | None = None) -> ArrayInt: ...
    def applyIS(self, iset: IS) -> IS: ...
    def applyInverse(self, indices: Sequence[int], mode: LGMap.MapMode | str | None = None) -> ArrayInt: ...
    def applyBlockInverse(self, indices: Sequence[int], mode: LGMap.MapMode | str | None = None) -> ArrayInt: ...
    size: int
    block_size: int
    indices: ArrayInt
    block_indices: ArrayInt
    info: dict[int, ArrayInt]
    block_info: dict[int, ArrayInt]

class SF(Object):
    class Type:
        BASIC: Final[str] = ...
        NEIGHBOR: Final[str] = ...
        ALLGATHERV: Final[str] = ...
        ALLGATHER: Final[str] = ...
        GATHERV: Final[str] = ...
        GATHER: Final[str] = ...
        ALLTOALL: Final[str] = ...
        WINDOW: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, sf_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def getGraph(self) -> tuple[int, ArrayInt, ArrayInt]: ...
    def setGraph(self, nroots: int, local: Sequence[int], remote: Sequence[int]) -> None: ...
    def setRankOrder(self, flag: bool) -> None: ...
    def getMulti(self) -> SF: ...
    def createInverse(self) -> SF: ...
    def computeDegree(self) -> ArrayInt: ...
    def createEmbeddedRootSF(self, selected: Sequence[int]) -> SF: ...
    def createEmbeddedLeafSF(self, selected: Sequence[int]) -> SF: ...
    def createSectionSF(self, rootSection: Section, remoteOffsets: Sequence[int] | None, leafSection: Section) -> SF: ...
    def distributeSection(self, rootSection: Section, leafSection: Section | None = None) -> tuple[ArrayInt, Section]: ...
    def compose(self, sf: SF) -> SF: ... # type: ignore[override]
    def bcastBegin(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, op: Op) -> None: ...
    def bcastEnd(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, op: Op) -> None: ...
    def reduceBegin(self, unit: Datatype, leafdata: ndarray, rootdata: ndarray, op: Op) -> None: ...
    def reduceEnd(self, unit: Datatype, leafdata: ndarray, rootdata: ndarray, op: Op) -> None: ...
    def scatterBegin(self, unit: Datatype, multirootdata: ndarray, leafdata: ndarray) -> None: ...
    def scatterEnd(self, unit: Datatype, multirootdata: ndarray, leafdata: ndarray) -> None: ...
    def gatherBegin(self, unit: Datatype, leafdata: ndarray, multirootdata: ndarray) -> None: ...
    def gatherEnd(self, unit: Datatype, leafdata: ndarray, multirootdata: ndarray) -> None: ...
    def fetchAndOpBegin(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, leafupdate: ndarray, op: Op) -> None: ...
    def fetchAndOpEnd(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, leafupdate: ndarray, op: Op) -> None: ...

class Vec(Object):
    class Type:
        SEQ: Final[str] = ...
        MPI: Final[str] = ...
        STANDARD: Final[str] = ...
        SHARED: Final[str] = ...
        SEQVIENNACL: Final[str] = ...
        MPIVIENNACL: Final[str] = ...
        VIENNACL: Final[str] = ...
        SEQCUDA: Final[str] = ...
        MPICUDA: Final[str] = ...
        CUDA: Final[str] = ...
        SEQHIP: Final[str] = ...
        MPIHIP: Final[str] = ...
        HIP: Final[str] = ...
        NEST: Final[str] = ...
        SEQKOKKOS: Final[str] = ...
        MPIKOKKOS: Final[str] = ...
        KOKKOS: Final[str] = ...
    class Option:
        IGNORE_OFF_PROC_ENTRIES: Final[int] = ...
        IGNORE_NEGATIVE_INDICES: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, vec_type: Type | str) -> None: ...
    def setSizes(self, size: LayoutSizeSpec, bsize: int | None = None) -> None: ...
    def createSeq(self, size: LayoutSizeSpec, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createMPI(self, size: LayoutSizeSpec, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createWithArray(self, array: Sequence[Scalar], size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createCUDAWithArrays(self, cpuarray: Sequence[Scalar] | None = None, cudahandle: Any | None = None, size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createHIPWithArrays(self, cpuarray: Sequence[Scalar] | None = None, hiphandle: Any | None = None, size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createViennaCLWithArrays(self, cpuarray: Sequence[Scalar] | None = None, viennaclvechandle: Any | None = None, size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createWithDLPack(self, dltensor, size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def attachDLPackInfo(self, vec: Vec | None = None, dltensor=None) -> Self: ...
    def clearDLPackInfo(self) -> Self: ...
    def toDLPack(self, mode: AccessModeSpec = 'rw') -> Any: ...
    def createGhost(self, ghosts: Sequence[int], size: LayoutSizeSpec, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createGhostWithArray(self, ghosts: Sequence[int], array: Sequence[Scalar], size: LayoutSizeSpec | None = None, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createShared(self, size: LayoutSizeSpec, bsize: int | None = None, comm: Comm | None = None) -> Self: ...
    def createNest(self, vecs: Sequence[Vec], isets: Sequence[IS] | None = None, comm: Comm | None = None) -> Self: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def setOption(self, option: Option, flag: bool) -> None: ...
    def getType(self) -> str: ...
    def getSize(self) -> int: ...
    def getLocalSize(self) -> int: ...
    def getSizes(self) -> LayoutSizeSpec: ...
    def setBlockSize(self, bsize: int) -> None: ...
    def getBlockSize(self) -> int: ...
    def getOwnershipRange(self) -> tuple[int, int]: ...
    def getOwnershipRanges(self) -> ArrayInt: ...
    def createLocalVector(self) -> Vec: ...
    def getLocalVector(self, lvec: Vec, readonly: bool = False) -> None: ...
    def restoreLocalVector(self, lvec: Vec, readonly: bool = False) -> None: ...
    def getBuffer(self, readonly: bool = False) -> Any: ...
    def getArray(self, readonly: bool = False) -> ArrayScalar: ...
    def setArray(self, array: Sequence[Scalar]) -> None: ...
    def placeArray(self, array: Sequence[Scalar]) -> None: ...
    def resetArray(self, force: bool = False) -> ArrayScalar | None: ...
    def bindToCPU(self, flg: bool) -> None: ...
    def boundToCPU(self) -> bool: ...
    def getCUDAHandle(self, mode: AccessModeSpec = 'rw') -> Any: ...
    def restoreCUDAHandle(self, handle: Any, mode: AccessModeSpec = 'rw') -> None: ...
    def getHIPHandle(self, mode: AccessModeSpec = 'rw') -> Any: ...
    def restoreHIPHandle(self, handle: Any, mode: AccessModeSpec = 'rw') -> None: ...
    def getOffloadMask(self) -> int: ...
    def getCLContextHandle(self) -> int: ...
    def getCLQueueHandle(self) -> int: ...
    def getCLMemHandle(self, mode: AccessModeSpec = 'rw') -> int: ...
    def restoreCLMemHandle(self) -> None: ...
    def duplicate(self, array: Sequence[Scalar] | None = None) -> Vec: ...
    def copy(self, result: Vec | None = None) -> Vec: ...
    def chop(self, tol: float) -> None: ...
    def load(self, viewer: Viewer) -> Self: ...
    def equal(self, vec: Vec) -> bool: ...
    def dot(self, vec: Vec) -> Scalar: ...
    def dotBegin(self, vec: Vec) -> None: ...
    def dotEnd(self, vec: Vec) -> Scalar: ...
    def tDot(self, vec: Vec) -> Scalar: ...
    def tDotBegin(self, vec: Vec) -> None: ...
    def tDotEnd(self, vec: Vec) -> Scalar: ...
    def mDot(self, vecs: Sequence[Vec], out: ArrayScalar | None = None) -> ArrayScalar: ...
    def mDotBegin(self, vecs: Sequence[Vec], out: ArrayScalar) -> None: ...
    def mDotEnd(self, vecs: Sequence[Vec], out: ArrayScalar) -> ArrayScalar: ...
    def mtDot(self, vecs: Sequence[Vec], out: ArrayScalar | None = None) -> ArrayScalar: ...
    def mtDotBegin(self, vecs: Sequence[Vec], out: ArrayScalar) -> None: ...
    def mtDotEnd(self, vecs: Sequence[Vec], out: ArrayScalar) -> ArrayScalar: ...
    def norm(self, norm_type: NormTypeSpec = None) -> float | tuple[float, float]: ...
    def normBegin(self, norm_type: NormTypeSpec = None) -> None: ...
    def normEnd(self, norm_type: NormTypeSpec = None) -> float | tuple[float, float]: ...
    def dotNorm2(self, vec: Vec) -> tuple[Scalar, float]: ...
    def sum(self) -> Scalar: ...
    def mean(self) -> Scalar: ...
    def min(self) -> tuple[int, float]: ...
    def max(self) -> tuple[int, float]: ...
    def normalize(self) -> float: ...
    def reciprocal(self) -> None: ...
    def exp(self) -> None: ...
    def log(self) -> None: ...
    def sqrtabs(self) -> None: ...
    def abs(self) -> None: ...
    def conjugate(self) -> None: ...
    def setRandom(self, random: Random | None = None) -> None: ...
    def permute(self, order: IS, invert: bool = False) -> None: ...
    def zeroEntries(self) -> None: ...
    def set(self, alpha: Scalar) -> None: ...
    def isset(self, idx: IS, alpha: Scalar) -> None: ...
    def scale(self, alpha: Scalar) -> None: ...
    def shift(self, alpha: Scalar) -> None: ...
    def swap(self, vec: Vec) -> None: ...
    def axpy(self, alpha: Scalar, x: Vec) -> None: ...
    def isaxpy(self, idx: IS, alpha: Scalar, x: Vec) -> None: ...
    def aypx(self, alpha: Scalar, x: Vec) -> None: ...
    def axpby(self, alpha: Scalar, beta: Scalar, x: Vec) -> None: ...
    def waxpy(self, alpha: Scalar, x: Vec, y: Vec) -> None: ...
    def maxpy(self, alphas: Sequence[Scalar], vecs: Sequence[Vec]) -> None: ...
    def pointwiseMult(self, x: Vec, y: Vec) -> None: ...
    def pointwiseDivide(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMin(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMax(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMaxAbs(self, x: Vec, y: Vec) -> None: ...
    def maxPointwiseDivide(self, vec: Vec) -> float: ...
    def getValue(self, index: int) -> Scalar: ...
    def getValues(self, indices: Sequence[int], values: Sequence[Scalar] | None = None) -> ArrayScalar: ...
    def getValuesStagStencil(self, indices, values=None) -> None: ...
    def setValue(self, index: int, value: Scalar, addv: InsertModeSpec = None) -> None: ...
    def setValues(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlocked(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesStagStencil(self, indices, values, addv=None) -> None: ...
    def setLGMap(self, lgmap: LGMap) -> None: ...
    def getLGMap(self) -> LGMap: ...
    def setValueLocal(self, index: int, value: Scalar, addv: InsertModeSpec = None) -> None: ...
    def setValuesLocal(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlockedLocal(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def assemblyBegin(self) -> None: ...
    def assemblyEnd(self) -> None: ...
    def assemble(self) -> None: ...
    def strideScale(self, field: int, alpha: Scalar) -> None: ...
    def strideSum(self, field: int) -> Scalar: ...
    def strideMin(self, field: int) -> tuple[int, float]: ...
    def strideMax(self, field: int) -> tuple[int, float]: ...
    def strideNorm(self, field: int, norm_type: NormTypeSpec = None) -> float | tuple[float, float]: ...
    def strideScatter(self, field: int, vec: Vec, addv: InsertModeSpec = None) -> None: ...
    def strideGather(self, field: int, vec: Vec, addv: InsertModeSpec = None) -> None: ...
    def localForm(self) -> Any: ...
    def ghostUpdateBegin(self, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    def ghostUpdateEnd(self, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    def ghostUpdate(self, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    def setMPIGhost(self, ghosts: Sequence[int]) -> None: ...
    def getGhostIS(self) -> IS: ...
    def getSubVector(self, iset: IS, subvec: Vec | None = None) -> Vec: ...
    def restoreSubVector(self, iset: IS, subvec: Vec) -> None: ...
    def getNestSubVecs(self) -> list[Vec]: ...
    def setNestSubVecs(self, sx: Sequence[Vec], idxm: Sequence[int] | None = None) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def getDM(self) -> DM: ...
    @classmethod
    def concatenate(cls, vecs: Sequence[Vec]) -> tuple[Vec, list[IS]]: ...
    sizes: LayoutSizeSpec
    size: int
    local_size: int
    block_size: int
    owner_range: tuple[int, int]
    owner_ranges: ArrayInt
    buffer_w: Any
    buffer_r: Any
    array_w: ArrayScalar
    array_r: ArrayScalar
    buffer: Any
    array: ArrayScalar

class Space(Object):
    class Type:
        POLYNOMIAL: Final[str] = ...
        PTRIMMED: Final[str] = ...
        TENSOR: Final[str] = ...
        SUM: Final[str] = ...
        POINT: Final[str] = ...
        SUBSPACE: Final[str] = ...
        WXY: Final[str] = ...
    def setUp(self) -> None: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def destroy(self) -> Self: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def setFromOptions(self) -> None: ...
    def getDimension(self) -> int: ...
    def getDegree(self) -> tuple[int, int]: ...
    def setDegree(self, degree: int | None, maxDegree: int | None) -> None: ...
    def getNumVariables(self) -> int: ...
    def setNumVariables(self, n: int) -> None: ...
    def getNumComponents(self) -> int: ...
    def setNumComponents(self, nc: int) -> None: ...
    def getType(self) -> str: ...
    def setType(self, space_type: Type | str) -> Self: ...
    def getSumConcatenate(self) -> bool: ...
    def setSumConcatenate(self, concatenate: bool) -> None: ...
    def getSumNumSubspaces(self) -> int: ...
    def getSumSubspace(self, s: int) -> Space: ...
    def setSumSubspace(self, s: int, subsp: Space) -> None: ...
    def setSumNumSubspaces(self, numSumSpaces: int) -> None: ...
    def getTensorNumSubspaces(self) -> int: ...
    def setTensorSubspace(self, s: int, subsp: Space) -> None: ...
    def getTensorSubspace(self, s: int) -> Space: ...
    def setTensorNumSubspaces(self, numTensSpaces: int) -> None: ...
    def getPolynomialTensor(self) -> bool: ...
    def setPolynomialTensor(self, tensor: bool) -> None: ...
    def setPointPoints(self, quad: Quad) -> None: ...
    def getPointPoints(self) -> Quad: ...
    def setPTrimmedFormDegree(self, formDegree: int) -> None: ...
    def getPTrimmedFormDegree(self) -> int: ...

class DualSpace(Object):
    class Type:
        LAGRANGE: Final[str] = ...
        SIMPLE: Final[str] = ...
        REFINED: Final[str] = ...
        BDM: Final[str] = ...
    def setUp(self) -> None: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def duplicate(self) -> DualSpace: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def getDimension(self) -> int: ...
    def getNumComponents(self) -> int: ...
    def setNumComponents(self, nc: int) -> None: ...
    def getType(self) -> str: ...
    def setType(self, dualspace_type: Type | str) -> Self: ...
    def getOrder(self) -> int: ...
    def setOrder(self, order: int) -> None: ...
    def getNumDof(self) -> ArrayInt: ...
    def getFunctional(self, i: int) -> Quad: ...
    def getInteriorDimension(self) -> int: ...
    def getLagrangeContinuity(self) -> bool: ...
    def setLagrangeContinuity(self, continuous: bool) -> None: ...
    def getLagrangeTensor(self) -> bool: ...
    def setLagrangeTensor(self, tensor: bool) -> None: ...
    def getLagrangeTrimmed(self) -> bool: ...
    def setLagrangeTrimmed(self, trimmed: bool) -> None: ...
    def setSimpleDimension(self, dim: int) -> None: ...
    def setSimpleFunctional(self, func: int, functional: Quad) -> None: ...

class FE(Object):
    class Type:
        BASIC: Final[str] = ...
        OPENCL: Final[str] = ...
        COMPOSITE: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def createDefault(self, dim: int, nc: int, isSimplex: bool, qorder: int = DETERMINE, prefix: str | None = None, comm: Comm | None = None) -> Self: ...
    def createByCell(self, dim: int, nc: int, ctype: DM.PolytopeType, qorder: int = DETERMINE, prefix: str | None = None, comm: Comm | None = None) -> Self: ...
    def createLagrange(self, dim: int, nc: int, isSimplex: bool, k: int, qorder: int = DETERMINE, comm: Comm | None = None) -> Self: ...
    def getQuadrature(self) -> Quad: ...
    def getDimension(self) -> int: ...
    def getSpatialDimension(self) -> int: ...
    def getNumComponents(self) -> int: ...
    def setNumComponents(self, comp: int) -> None: ...
    def getNumDof(self) -> ndarray: ...
    def getTileSizes(self) -> tuple[int, int, int, int]: ...
    def setTileSizes(self, blockSize: int, numBlocks: int, batchSize: int, numBatches: int) -> None: ...
    def getFaceQuadrature(self) -> Quad: ...
    def setQuadrature(self, quad: Quad) -> Self: ...
    def setFaceQuadrature(self, quad: Quad) -> Quad: ...
    def setType(self, fe_type: Type | str) -> Self: ...
    def getBasisSpace(self) -> Space: ...
    def setBasisSpace(self, sp: Space) -> None: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def getDualSpace(self) -> DualSpace: ...
    def setDualSpace(self, dspace: DualSpace) -> None: ...

class Quad(Object):
    def view(self, viewer: Viewer | None = None) -> None: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def duplicate(self) -> Quad: ...
    def destroy(self) -> Self: ...
    def getData(self) -> tuple[ArrayReal, ArrayReal]: ...
    def getNumComponents(self) -> int: ...
    def setNumComponents(self, nc: int) -> None: ...
    def getOrder(self) -> int: ...
    def setOrder(self, order: int) -> None: ...

class Scatter(Object):
    class Type:
        BASIC: Final[str] = ...
        NEIGHBOR: Final[str] = ...
        ALLGATHERV: Final[str] = ...
        ALLGATHER: Final[str] = ...
        GATHERV: Final[str] = ...
        GATHER: Final[str] = ...
        ALLTOALL: Final[str] = ...
        WINDOW: Final[str] = ...
    class Mode:
        SCATTER_FORWARD: Final[int] = ...
        SCATTER_REVERSE: Final[int] = ...
        SCATTER_FORWARD_LOCAL: Final[int] = ...
        SCATTER_REVERSE_LOCAL: Final[int] = ...
        FORWARD: Final[int] = ...
        REVERSE: Final[int] = ...
        FORWARD_LOCAL: Final[int] = ...
        REVERSE_LOCAL: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, vec_from: Vec, is_from: IS, vec_to: Vec, is_to: IS) -> Self: ...
    def setType(self, scatter_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def copy(self) -> Scatter: ...
    @classmethod
    def toAll(cls, vec: Vec) -> tuple[Scatter, Vec]: ...
    @classmethod
    def toZero(cls, vec: Vec) -> tuple[Scatter, Vec]: ...
    def begin(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    def end(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    def scatter(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = None, mode: ScatterModeSpec = None) -> None: ...
    scatterBegin = begin
    scatterEnd = end

class Section(Object):
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def clone(self) -> Section: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def getNumFields(self) -> int: ...
    def setNumFields(self, numFields: int) -> None: ...
    def getFieldName(self, field: int) -> str: ...
    def setFieldName(self, field: int, fieldName: str) -> None: ...
    def getFieldComponents(self, field: int) -> int: ...
    def setFieldComponents(self, field: int, numComp: int) -> None: ...
    def getChart(self) -> tuple[int, int]: ...
    def setChart(self, pStart: int, pEnd: int) -> None: ...
    def getPermutation(self) -> IS: ...
    def setPermutation(self, perm: IS) -> None: ...
    def getDof(self, point: int) -> int: ...
    def setDof(self, point: int, numDof: int) -> None: ...
    def addDof(self, point: int, numDof: int) -> None: ...
    def getFieldDof(self, point: int, field: int) -> int: ...
    def setFieldDof(self, point: int, field: int, numDof: int) -> None: ...
    def addFieldDof(self, point: int, field: int, numDof: int) -> None: ...
    def getConstraintDof(self, point: int) -> int: ...
    def setConstraintDof(self, point: int, numDof: int) -> None: ...
    def addConstraintDof(self, point: int, numDof: int) -> None: ...
    def getFieldConstraintDof(self, point: int, field: int) -> int: ...
    def setFieldConstraintDof(self, point: int, field: int, numDof: int) -> None: ...
    def addFieldConstraintDof(self, point: int, field: int, numDof: int) -> None: ...
    def getConstraintIndices(self, point: int) -> ArrayInt: ...
    def setConstraintIndices(self, point: int, indices: Sequence[int]) -> None: ...
    def getFieldConstraintIndices(self, point: int, field: int) -> ArrayInt: ...
    def setFieldConstraintIndices(self, point: int, field: int, indices: Sequence[int]) -> None: ...
    def getMaxDof(self) -> int: ...
    def getStorageSize(self) -> int: ...
    def getConstrainedStorageSize(self) -> int: ...
    def getOffset(self, point: int) -> int: ...
    def setOffset(self, point: int, offset: int) -> None: ...
    def getFieldOffset(self, point: int, field: int) -> int: ...
    def setFieldOffset(self, point: int, field: int, offset: int) -> None: ...
    def getOffsetRange(self) -> tuple[int, int]: ...
    def createGlobalSection(self, sf: SF) -> Section: ...

class Mat(Object):
    class Type:
        SAME: Final[str] = ...
        MAIJ: Final[str] = ...
        SEQMAIJ: Final[str] = ...
        MPIMAIJ: Final[str] = ...
        KAIJ: Final[str] = ...
        SEQKAIJ: Final[str] = ...
        MPIKAIJ: Final[str] = ...
        IS: Final[str] = ...
        AIJ: Final[str] = ...
        SEQAIJ: Final[str] = ...
        MPIAIJ: Final[str] = ...
        AIJCRL: Final[str] = ...
        SEQAIJCRL: Final[str] = ...
        MPIAIJCRL: Final[str] = ...
        AIJCUSPARSE: Final[str] = ...
        SEQAIJCUSPARSE: Final[str] = ...
        MPIAIJCUSPARSE: Final[str] = ...
        AIJVIENNACL: Final[str] = ...
        SEQAIJVIENNACL: Final[str] = ...
        MPIAIJVIENNACL: Final[str] = ...
        AIJPERM: Final[str] = ...
        SEQAIJPERM: Final[str] = ...
        MPIAIJPERM: Final[str] = ...
        AIJSELL: Final[str] = ...
        SEQAIJSELL: Final[str] = ...
        MPIAIJSELL: Final[str] = ...
        AIJMKL: Final[str] = ...
        SEQAIJMKL: Final[str] = ...
        MPIAIJMKL: Final[str] = ...
        BAIJMKL: Final[str] = ...
        SEQBAIJMKL: Final[str] = ...
        MPIBAIJMKL: Final[str] = ...
        SHELL: Final[str] = ...
        DENSE: Final[str] = ...
        DENSECUDA: Final[str] = ...
        DENSEHIP: Final[str] = ...
        SEQDENSE: Final[str] = ...
        SEQDENSECUDA: Final[str] = ...
        SEQDENSEHIP: Final[str] = ...
        MPIDENSE: Final[str] = ...
        MPIDENSECUDA: Final[str] = ...
        MPIDENSEHIP: Final[str] = ...
        ELEMENTAL: Final[str] = ...
        BAIJ: Final[str] = ...
        SEQBAIJ: Final[str] = ...
        MPIBAIJ: Final[str] = ...
        MPIADJ: Final[str] = ...
        SBAIJ: Final[str] = ...
        SEQSBAIJ: Final[str] = ...
        MPISBAIJ: Final[str] = ...
        MFFD: Final[str] = ...
        NORMAL: Final[str] = ...
        NORMALHERMITIAN: Final[str] = ...
        LRC: Final[str] = ...
        SCATTER: Final[str] = ...
        BLOCKMAT: Final[str] = ...
        COMPOSITE: Final[str] = ...
        FFT: Final[str] = ...
        FFTW: Final[str] = ...
        SEQCUFFT: Final[str] = ...
        TRANSPOSE: Final[str] = ...
        HERMITIANTRANSPOSE: Final[str] = ...
        SCHURCOMPLEMENT: Final[str] = ...
        PYTHON: Final[str] = ...
        HYPRE: Final[str] = ...
        HYPRESTRUCT: Final[str] = ...
        HYPRESSTRUCT: Final[str] = ...
        SUBMATRIX: Final[str] = ...
        LOCALREF: Final[str] = ...
        NEST: Final[str] = ...
        PREALLOCATOR: Final[str] = ...
        SELL: Final[str] = ...
        SEQSELL: Final[str] = ...
        MPISELL: Final[str] = ...
        DUMMY: Final[str] = ...
        LMVM: Final[str] = ...
        LMVMDFP: Final[str] = ...
        LMVMDDFP: Final[str] = ...
        LMVMBFGS: Final[str] = ...
        LMVMDBFGS: Final[str] = ...
        LMVMDQN: Final[str] = ...
        LMVMSR1: Final[str] = ...
        LMVMBROYDEN: Final[str] = ...
        LMVMBADBROYDEN: Final[str] = ...
        LMVMSYMBROYDEN: Final[str] = ...
        LMVMSYMBADBROYDEN: Final[str] = ...
        LMVMDIAGBBROYDEN: Final[str] = ...
        CONSTANTDIAGONAL: Final[str] = ...
        DIAGONAL: Final[str] = ...
        H2OPUS: Final[str] = ...
    class Option:
        OPTION_MIN: Final[int] = ...
        UNUSED_NONZERO_LOCATION_ERR: Final[int] = ...
        ROW_ORIENTED: Final[int] = ...
        SYMMETRIC: Final[int] = ...
        STRUCTURALLY_SYMMETRIC: Final[int] = ...
        FORCE_DIAGONAL_ENTRIES: Final[int] = ...
        IGNORE_OFF_PROC_ENTRIES: Final[int] = ...
        USE_HASH_TABLE: Final[int] = ...
        KEEP_NONZERO_PATTERN: Final[int] = ...
        IGNORE_ZERO_ENTRIES: Final[int] = ...
        USE_INODES: Final[int] = ...
        HERMITIAN: Final[int] = ...
        SYMMETRY_ETERNAL: Final[int] = ...
        NEW_NONZERO_LOCATION_ERR: Final[int] = ...
        IGNORE_LOWER_TRIANGULAR: Final[int] = ...
        ERROR_LOWER_TRIANGULAR: Final[int] = ...
        GETROW_UPPERTRIANGULAR: Final[int] = ...
        SPD: Final[int] = ...
        NO_OFF_PROC_ZERO_ROWS: Final[int] = ...
        NO_OFF_PROC_ENTRIES: Final[int] = ...
        NEW_NONZERO_LOCATIONS: Final[int] = ...
        NEW_NONZERO_ALLOCATION_ERR: Final[int] = ...
        SUBSET_OFF_PROC_ENTRIES: Final[int] = ...
        SUBMAT_SINGLEIS: Final[int] = ...
        STRUCTURE_ONLY: Final[int] = ...
        SORTED_FULL: Final[int] = ...
        OPTION_MAX: Final[int] = ...
    class AssemblyType:
        FINAL_ASSEMBLY: Final[int] = ...
        FLUSH_ASSEMBLY: Final[int] = ...
        FINAL: Final[int] = ...
        FLUSH: Final[int] = ...
    class InfoType:
        LOCAL: Final[int] = ...
        GLOBAL_MAX: Final[int] = ...
        GLOBAL_SUM: Final[int] = ...
    class Structure:
        SAME_NONZERO_PATTERN: Final[int] = ...
        DIFFERENT_NONZERO_PATTERN: Final[int] = ...
        SUBSET_NONZERO_PATTERN: Final[int] = ...
        UNKNOWN_NONZERO_PATTERN: Final[int] = ...
        SAME: Final[int] = ...
        SAME_NZ: Final[int] = ...
        SUBSET: Final[int] = ...
        SUBSET_NZ: Final[int] = ...
        DIFFERENT: Final[int] = ...
        DIFFERENT_NZ: Final[int] = ...
        UNKNOWN: Final[int] = ...
        UNKNOWN_NZ: Final[int] = ...
    class DuplicateOption:
        DO_NOT_COPY_VALUES: Final[int] = ...
        COPY_VALUES: Final[int] = ...
        SHARE_NONZERO_PATTERN: Final[int] = ...
    class OrderingType:
        NATURAL: Final[str] = ...
        ND: Final[str] = ...
        OWD: Final[str] = ...
        RCM: Final[str] = ...
        QMD: Final[str] = ...
        ROWLENGTH: Final[str] = ...
        WBM: Final[str] = ...
        SPECTRAL: Final[str] = ...
        AMD: Final[str] = ...
        METISND: Final[str] = ...
    class SolverType:
        SUPERLU: Final[str] = ...
        SUPERLU_DIST: Final[str] = ...
        STRUMPACK: Final[str] = ...
        UMFPACK: Final[str] = ...
        CHOLMOD: Final[str] = ...
        KLU: Final[str] = ...
        ELEMENTAL: Final[str] = ...
        SCALAPACK: Final[str] = ...
        ESSL: Final[str] = ...
        LUSOL: Final[str] = ...
        MUMPS: Final[str] = ...
        MKL_PARDISO: Final[str] = ...
        MKL_CPARDISO: Final[str] = ...
        PASTIX: Final[str] = ...
        MATLAB: Final[str] = ...
        PETSC: Final[str] = ...
        BAS: Final[str] = ...
        CUSPARSE: Final[str] = ...
        CUDA: Final[str] = ...
        SPQR: Final[str] = ...
    class FactorShiftType:
        NONE: Final[int] = ...
        NONZERO: Final[int] = ...
        POSITIVE_DEFINITE: Final[int] = ...
        INBLOCKS: Final[int] = ...
        NZ: Final[int] = ...
        PD: Final[int] = ...
    class SORType:
        FORWARD_SWEEP: Final[int] = ...
        BACKWARD_SWEEP: Final[int] = ...
        SYMMETRY_SWEEP: Final[int] = ...
        LOCAL_FORWARD_SWEEP: Final[int] = ...
        LOCAL_BACKWARD_SWEEP: Final[int] = ...
        LOCAL_SYMMETRIC_SWEEP: Final[int] = ...
        ZERO_INITIAL_GUESS: Final[int] = ...
        EISENSTAT: Final[int] = ...
        APPLY_UPPER: Final[int] = ...
        APPLY_LOWER: Final[int] = ...
    class Stencil:
        i: int
        j: int
        k: int
        c: int
        index: tuple[int, int, int]
        field: int
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, mat_type: Type | str) -> None: ...
    def setSizes(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None) -> None: ...
    def setBlockSize(self, bsize: int) -> None: ...
    def setBlockSizes(self, row_bsize: int, col_bsize: int) -> None: ...
    def setVariableBlockSizes(self, blocks: Sequence[int]) -> None: ...
    def setVecType(self, vec_type: Vec.Type | str) -> None: ...
    def getVecType(self) -> str: ...
    def setNestVecType(self, vec_type: Vec.Type | str) -> None: ...
    def createAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None, nnz: NNZSpec | None = None, csr: CSRIndicesSpec | None = None, comm: Comm | None = None) -> Self: ...
    def createBAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec, nnz: NNZSpec | None = None, csr: CSRIndicesSpec | None = None, comm: Comm | None = None) -> Self: ...
    def createSBAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec, nnz: NNZSpec | None = None, csr: CSRIndicesSpec | None = None, comm: Comm | None = None) -> Self: ...
    def createAIJCRL(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None, nnz: NNZSpec | None = None, csr: CSRIndicesSpec | None = None, comm: Comm | None = None) -> Self: ...
    def setPreallocationNNZ(self, nnz: NNZSpec) -> Self: ...
    def setPreallocationCOO(self, coo_i: Sequence[int], coo_j: Sequence[int]) -> Self: ...
    def setPreallocationCOOLocal(self, coo_i: Sequence[int], coo_j: Sequence[int]) -> Self: ...
    def setPreallocationCSR(self, csr: CSRIndicesSpec) -> Self: ...
    def preallocatorPreallocate(self, A: Mat, fill: bool = True) -> None: ...
    def createAIJWithArrays(self, size: MatSizeSpec, csr: CSRSpec | tuple[CSRSpec, CSRSpec], bsize: MatBlockSizeSpec | None = None, comm: Comm | None = None) -> Self: ...
    def createDense(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None, array: Sequence[Scalar] | None = None, comm: Comm | None = None) -> Self: ...
    def createDenseCUDA(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None, array: Sequence[Scalar] | None = None, cudahandle: int | None = None, comm: Comm | None = None) -> Self: ...
    def setPreallocationDense(self, array: Sequence[Scalar]) -> Self: ...
    def createScatter(self, scatter: Scatter, comm: Comm | None = None) -> Self: ...
    def createNormal(self, mat: Mat) -> Self: ...
    def createTranspose(self, mat: Mat) -> Self: ...
    def getTransposeMat(self) -> Mat: ...
    def createNormalHermitian(self, mat: Mat) -> Self: ...
    def createHermitianTranspose(self, mat: Mat) -> Self: ...
    def createLRC(self, A: Mat | None, U: Mat, c: Vec | None, V: Mat | None) -> Self: ...
    def createSubMatrixVirtual(self, A: Mat, isrow: IS, iscol: IS | None = None) -> Self: ...
    def createNest(self, mats: Sequence[Sequence[Mat]], isrows: Sequence[IS] | None = None, iscols: Sequence[IS] | None = None, comm: Comm | None = None) -> Self: ...
    def createH2OpusFromMat(self, A: Mat, coordinates: Sequence[Scalar] | None = None, dist: bool | None = None, eta: float | None = None, leafsize: int | None = None, maxrank: int | None = None, bs: int | None = None, rtol: float | None = None) -> Self: ...
    def createIS(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = None, lgmapr: LGMap | None = None, lgmapc: LGMap | None = None, comm: Comm | None = None) -> Self: ...
    def createConstantDiagonal(self, size: MatSizeSpec, diag: float, comm: Comm | None = None) -> Self: ...
    def createDiagonal(self, diag: Vec) -> Self: ...
    def createPython(self, size: MatSizeSpec, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None = None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None = None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def setOption(self, option: Option, flag: bool) -> None: ...
    def getOption(self, option: Option) -> bool: ...
    def getType(self) -> str: ...
    def getSize(self) -> tuple[int, int]: ...
    def getLocalSize(self) -> tuple[int, int]: ...
    def getSizes(self) -> tuple[LayoutSizeSpec, LayoutSizeSpec]: ...
    def getBlockSize(self) -> int: ...
    def getBlockSizes(self) -> tuple[int, int]: ...
    def getOwnershipRange(self) -> tuple[int, int]: ...
    def getOwnershipRanges(self) -> ArrayInt: ...
    def getOwnershipRangeColumn(self) -> tuple[int, int]: ...
    def getOwnershipRangesColumn(self) -> ArrayInt: ...
    def getOwnershipIS(self) -> tuple[IS, IS]: ...
    def getInfo(self, info: InfoType | None = None) -> dict[str, float]: ...
    def duplicate(self, copy: DuplicateOption | bool = False) -> Mat: ...
    def copy(self, result: Mat | None = None, structure: Structure | None = None) -> Mat: ...
    def load(self, viewer: Viewer) -> Self: ...
    def convert(self, mat_type: Type | str | None = None, out: Mat | None = None) -> Mat: ...
    def transpose(self, out: Mat | None = None) -> Mat: ...
    def setTransposePrecursor(self, out: Mat) -> None: ...
    def hermitianTranspose(self, out: Mat | None = None) -> Mat: ...
    def realPart(self, out: Mat | None = None) -> Mat: ...
    def imagPart(self, out: Mat | None = None) -> Mat: ...
    def conjugate(self, out: Mat | None = None) -> Mat: ...
    def permute(self, row: IS, col: IS) -> Mat: ...
    def equal(self, mat: Mat) -> bool: ...
    def isTranspose(self, mat: Mat | None = None, tol: float = 0) -> bool: ...
    def isSymmetric(self, tol: float = 0) -> bool: ...
    def isSymmetricKnown(self) -> tuple[bool, bool]: ...
    def isHermitian(self, tol: float = 0) -> bool: ...
    def isHermitianKnown(self) -> tuple[bool, bool]: ...
    def isStructurallySymmetric(self) -> bool: ...
    def isLinear(self, n: int = 1) -> bool: ...
    def zeroEntries(self) -> None: ...
    def getValue(self, row, col) -> Scalar: ...
    def getValues(self, rows: Sequence[int], cols: Sequence[int], values: ArrayScalar | None = None) -> ArrayScalar: ...
    def getValuesCSR(self) -> tuple[ArrayInt, ArrayInt, ArrayScalar]: ...
    def getRow(self, row: int) -> tuple[ArrayInt, ArrayScalar]: ...
    def getRowIJ(self, symmetric: bool = False, compressed: bool = False) -> tuple[ArrayInt, ArrayInt]: ...
    def getColumnIJ(self, symmetric: bool = False, compressed: bool = False) -> tuple[ArrayInt, ArrayInt]: ...
    def setValue(self, row: int, col: int, value: Scalar, addv: InsertModeSpec = None) -> None: ...
    def setValues(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesRCV(self, R, C, V, addv=None) -> None: ...
    def setValuesIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None, rowmap: Sequence[int] | None = None) -> None: ...
    def setValuesCOO(self, coo_v: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlocked(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlockedRCV(self, R, C, V, addv=None) -> None: ...
    def setValuesBlockedIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None, rowmap: Sequence[int] | None = None) -> None: ...
    def setValuesBlockedCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setLGMap(self, rmap: LGMap, cmap: LGMap | None = None) -> None: ...
    def getLGMap(self) -> tuple[LGMap, LGMap]: ...
    def setValueLocal(self, row: int, col: int, value: Scalar, addv: InsertModeSpec = None) -> None: ...
    def setValuesLocal(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesLocalRCV(self, R, C, V, addv=None) -> None: ...
    def setValuesLocalIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None, rowmap: Sequence[int] | None = None) -> None: ...
    def setValuesLocalCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlockedLocal(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValuesBlockedLocalRCV(self, R, C, V, addv=None) -> None: ...
    def setValuesBlockedLocalIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None, rowmap: Sequence[int] | None = None) -> None: ...
    def setValuesBlockedLocalCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setStencil(self, dims: DimsSpec, starts: DimsSpec | None = None, dof: int = 1) -> None: ...
    def setValueStencil(self, row: Stencil, col: Stencil, value: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValueStagStencil(self, row, col, value, addv=None) -> None: ...
    def setValueBlockedStencil(self, row: Stencil, col: Stencil, value: Sequence[Scalar], addv: InsertModeSpec = None) -> None: ...
    def setValueBlockedStagStencil(self, row, col, value, addv=None) -> None: ...
    def zeroRows(self, rows: IS | Sequence[int], diag: Scalar = 1.0, x: Vec | None = None, b: Vec | None = None) -> None: ...
    def zeroRowsLocal(self, rows: IS | Sequence[int], diag: Scalar = 1.0, x: Vec | None = None, b: Vec | None = None) -> None: ...
    def zeroRowsColumns(self, rows: IS | Sequence[int], diag: Scalar = 1.0, x: Vec | None = None, b: Vec | None = None) -> None: ...
    def zeroRowsColumnsLocal(self, rows: IS | Sequence[int], diag: Scalar = 1.0, x: Vec | None = None, b: Vec | None = None) -> None: ...
    def zeroRowsColumnsStencil(self, rows: Sequence[Stencil], diag: Scalar = 1.0, x: Vec | None = None, b: Vec | None = None) -> None: ...
    def storeValues(self) -> None: ...
    def retrieveValues(self) -> None: ...
    def assemblyBegin(self, assembly: MatAssemblySpec = None) -> None: ...
    def assemblyEnd(self, assembly: MatAssemblySpec = None) -> None: ...
    def assemble(self, assembly: MatAssemblySpec = None) -> None: ...
    def isAssembled(self) -> bool: ...
    def findZeroRows(self) -> IS: ...
    def createVecs(self, side: Literal['r', 'R', 'right', 'Right', 'RIGHT', 'l', 'L', 'left', 'Left', 'LEFT'] | None = None) -> Vec | tuple[Vec, Vec]: ...
    def createVecRight(self) -> Vec: ...
    def createVecLeft(self) -> Vec: ...
    def getColumnVector(self, column: int, result: Vec | None = None) -> Vec: ...
    def getRedundantMatrix(self, nsubcomm: int, subcomm: Comm | None = None, out: Mat | None = None) -> Mat: ...
    def getDiagonal(self, result: Vec | None = None) -> Vec: ...
    def getRowSum(self, result: Vec | None = None) -> Vec: ...
    def setDiagonal(self, diag: Vec, addv: InsertModeSpec = None) -> None: ...
    def diagonalScale(self, L: Vec | None = None, R: Vec | None = None) -> None: ...
    def invertBlockDiagonal(self) -> ArrayScalar: ...
    def setNullSpace(self, nsp: NullSpace) -> None: ...
    def getNullSpace(self) -> NullSpace: ...
    def setTransposeNullSpace(self, nsp: NullSpace) -> None: ...
    def getTransposeNullSpace(self) -> NullSpace: ...
    def setNearNullSpace(self, nsp: NullSpace) -> None: ...
    def getNearNullSpace(self) -> NullSpace: ...
    def mult(self, x: Vec, y: Vec) -> None: ...
    def multAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def multTranspose(self, x: Vec, y: Vec) -> None: ...
    def multTransposeAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def multHermitian(self, x: Vec, y: Vec) -> None: ...
    def multHermitianAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def SOR(self, b: Vec, x: Vec, omega: float = 1.0, sortype: SORType | None = None, shift: float = 0.0, its: int = 1, lits: int = 1) -> None: ...
    def getDiagonalBlock(self) -> Mat: ...
    def increaseOverlap(self, iset: IS, overlap: int = 1) -> None: ...
    def createSubMatrix(self, isrow: IS, iscol: IS | None = None, submat: Mat | None = None) -> Mat: ...
    def createSubMatrices(self, isrows: IS | Sequence[IS], iscols: IS | Sequence[IS] | None = None, submats: Mat | Sequence[Mat] | None = None) -> Sequence[Mat]: ...
    def createSchurComplement(self, A00: Mat, Ap00: Mat, A01: Mat, A10: Mat, A11: Mat | None = None) -> Self: ...
    def getSchurComplementSubMatrices(self) -> tuple[Mat, Mat, Mat, Mat, Mat]: ...
    def getLocalSubMatrix(self, isrow: IS, iscol: IS, submat: Mat | None = None) -> Mat: ...
    def restoreLocalSubMatrix(self, isrow: IS, iscol: IS, submat: Mat) -> None: ...
    def norm(self, norm_type: NormTypeSpec = None) -> float | tuple[float, float]: ...
    def scale(self, alpha: Scalar) -> None: ...
    def shift(self, alpha: Scalar) -> None: ...
    def chop(self, tol: float) -> None: ...
    def setRandom(self, random: Random | None = None) -> None: ...
    def axpy(self, alpha: Scalar, X: Mat, structure: Structure | None = None) -> None: ...
    def aypx(self, alpha: Scalar, X: Mat, structure: Structure | None = None) -> None: ...
    def matMult(self, mat: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def matTransposeMult(self, mat: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def transposeMatMult(self, mat: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def ptap(self, P: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def rart(self, R: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def matMatMult(self, B: Mat, C: Mat, result: Mat | None = None, fill: float | None = None) -> Mat: ...
    def kron(self, mat: Mat, result: Mat | None = None) -> Mat: ...
    def bindToCPU(self, flg: bool) -> None: ...
    def boundToCPU(self) -> bool: ...
    def getOrdering(self, ord_type: OrderingType) -> tuple[IS, IS]: ...
    def reorderForNonzeroDiagonal(self, isrow: IS, iscol: IS, atol: float = 0) -> None: ...
    def factorLU(self, isrow: IS, iscol: IS, options: dict[str, Any] | None = None) -> None: ...
    def factorSymbolicLU(self, mat: Mat, isrow: IS, iscol: IS, options=None) -> None: ...
    def factorNumericLU(self, mat: Mat, options=None) -> None: ...
    def factorILU(self, isrow: IS, iscol: IS, options: dict[str, Any] | None = None) -> None: ...
    def factorSymbolicILU(self, isrow: IS, iscol: IS, options=None) -> None: ...
    def factorCholesky(self, isperm: IS, options: dict[str, Any] | None = None) -> None: ...
    def factorSymbolicCholesky(self, isperm: IS, options=None) -> None: ...
    def factorNumericCholesky(self, mat: Mat, options=None) -> None: ...
    def factorICC(self, isperm: IS, options: dict[str, Any] | None = None) -> None: ...
    def factorSymbolicICC(self, isperm: IS, options=None) -> None: ...
    def getInertia(self) -> tuple[int, int, int]: ...
    def setUnfactored(self) -> None: ...
    def setISAllowRepeated(self, allow: bool = True) -> None: ...
    def getISAllowRepeated(self) -> bool: ...
    def fixISLocalEmpty(self, fix: bool = True) -> None: ...
    def getISLocalMat(self) -> Mat: ...
    def restoreISLocalMat(self, local: Mat) -> None: ...
    def setISLocalMat(self, local: Mat) -> None: ...
    def setISPreallocation(self, nnz: Sequence[int], onnz: Sequence[int]) -> Self: ...
    def getLRCMats(self) -> tuple[Mat, Mat, Vec, Mat]: ...
    def setLRCMats(self, A: Mat, U: Mat, c: Vec | None = None, V: Mat | None = None) -> None: ...
    def H2OpusOrthogonalize(self) -> Self: ...
    def H2OpusCompress(self, tol: float) -> Self: ...
    def H2OpusLowRankUpdate(self, U: Mat, V: Mat | None = None, s: float = 1.0) -> Self: ...
    def getLMVMJ0(self) -> Mat: ...
    def setLMVMJ0(self, J0: Mat) -> None: ...
    def getLMVMJ0KSP(self) -> Mat: ...
    def setLMVMJ0KSP(self, ksp: KSP) -> None: ...
    def allocateLMVM(self, x: Vec, f: Vec) -> None: ...
    def updateLMVM(self, x: Vec, f: Vec) -> None: ...
    def resetLMVM(self, destructive: bool = False) -> None: ...
    def setMumpsIcntl(self, icntl: int, ival: int) -> None: ...
    def getMumpsIcntl(self, icntl: int) -> int: ...
    def setMumpsCntl(self, icntl: int, val: float) -> None: ...
    def getMumpsCntl(self, icntl: int) -> float: ...
    def getMumpsInfo(self, icntl: int) -> int: ...
    def getMumpsInfog(self, icntl: int) -> int: ...
    def getMumpsRinfo(self, icntl: int) -> float: ...
    def getMumpsRinfog(self, icntl: int) -> float: ...
    def solveForward(self, b: Vec, x: Vec) -> None: ...
    def solveBackward(self, b: Vec, x: Vec) -> None: ...
    def solve(self, b: Vec, x: Vec) -> None: ...
    def solveTranspose(self, b: Vec, x: Vec) -> None: ...
    def solveAdd(self, b: Vec, y: Vec, x: Vec) -> None: ...
    def solveTransposeAdd(self, b: Vec, y: Vec, x: Vec) -> None: ...
    def matSolve(self, B: Mat, X: Mat) -> None: ...
    def setDenseLDA(self, lda: int) -> None: ...
    def getDenseLDA(self) -> int: ...
    def getDenseArray(self, readonly: bool = False) -> ArrayScalar: ...
    def getDenseLocalMatrix(self) -> Mat: ...
    def getDenseSubMatrix(self, rbegin: int = DECIDE, rend: int = DECIDE, cbegin: int = DECIDE, cend: int = DECIDE) -> Mat: ...
    def restoreDenseSubMatrix(self, mat: Mat) -> None: ...
    def getDenseColumnVec(self, i: int, mode: AccessModeSpec = 'rw') -> Vec: ...
    def restoreDenseColumnVec(self, i: int, mode: AccessModeSpec = 'rw', V: Vec | None = None) -> None: ...
    def getNestSize(self) -> tuple[int, int]: ...
    def getNestISs(self) -> tuple[list[IS], list[IS]]: ...
    def getNestLocalISs(self) -> tuple[list[IS], list[IS]]: ...
    def getNestSubMatrix(self, i: int, j: int) -> Mat: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def toDLPack(self, mode: AccessModeSpec = 'rw') -> Any: ...
    sizes: tuple[tuple[int, int], tuple[int, int]]
    size: tuple[int, int]
    local_size: int
    block_size: int
    block_sizes: tuple[int, int]
    owner_range: tuple[int, int]
    owner_ranges: ArrayInt
    assembled: bool
    symmetric: bool
    hermitian: bool
    structsymm: bool
    getVecs = createVecs
    getVecRight = createVecRight
    getVecLeft = createVecLeft
    PtAP = ptap

class MatPartitioning(Object):
    class Type:
        PARTITIONINGCURRENT: Final[str] = ...
        PARTITIONINGAVERAGE: Final[str] = ...
        PARTITIONINGSQUARE: Final[str] = ...
        PARTITIONINGPARMETIS: Final[str] = ...
        PARTITIONINGCHACO: Final[str] = ...
        PARTITIONINGPARTY: Final[str] = ...
        PARTITIONINGPTSCOTCH: Final[str] = ...
        PARTITIONINGHIERARCH: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, matpartitioning_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setAdjacency(self, adj: Mat) -> None: ...
    def apply(self, partitioning: IS) -> None: ...

class NullSpace(Object):
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, constant: bool = False, vectors: Sequence[Vec] = (), comm=None) -> Self: ...
    def createRigidBody(self, coords: Vec) -> Self: ...
    def setFunction(self, function: MatNullFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def hasConstant(self) -> bool: ...
    def getVecs(self) -> list[Vec]: ...
    def getFunction(self) -> MatNullFunction: ...
    def remove(self, vec: Vec) -> None: ...
    def test(self, mat: Mat) -> bool: ...

class PC(Object):
    class Type:
        NONE: Final[str] = ...
        JACOBI: Final[str] = ...
        SOR: Final[str] = ...
        LU: Final[str] = ...
        QR: Final[str] = ...
        SHELL: Final[str] = ...
        BJACOBI: Final[str] = ...
        VPBJACOBI: Final[str] = ...
        MG: Final[str] = ...
        EISENSTAT: Final[str] = ...
        ILU: Final[str] = ...
        ICC: Final[str] = ...
        ASM: Final[str] = ...
        GASM: Final[str] = ...
        KSP: Final[str] = ...
        COMPOSITE: Final[str] = ...
        REDUNDANT: Final[str] = ...
        SPAI: Final[str] = ...
        NN: Final[str] = ...
        CHOLESKY: Final[str] = ...
        PBJACOBI: Final[str] = ...
        MAT: Final[str] = ...
        HYPRE: Final[str] = ...
        PARMS: Final[str] = ...
        FIELDSPLIT: Final[str] = ...
        TFS: Final[str] = ...
        ML: Final[str] = ...
        GALERKIN: Final[str] = ...
        EXOTIC: Final[str] = ...
        CP: Final[str] = ...
        LSC: Final[str] = ...
        PYTHON: Final[str] = ...
        PFMG: Final[str] = ...
        SYSPFMG: Final[str] = ...
        REDISTRIBUTE: Final[str] = ...
        SVD: Final[str] = ...
        GAMG: Final[str] = ...
        CHOWILUVIENNACL: Final[str] = ...
        ROWSCALINGVIENNACL: Final[str] = ...
        SAVIENNACL: Final[str] = ...
        BDDC: Final[str] = ...
        KACZMARZ: Final[str] = ...
        TELESCOPE: Final[str] = ...
        PATCH: Final[str] = ...
        LMVM: Final[str] = ...
        HMG: Final[str] = ...
        DEFLATION: Final[str] = ...
        HPDDM: Final[str] = ...
        H2OPUS: Final[str] = ...
    class Side:
        LEFT: Final[int] = ...
        RIGHT: Final[int] = ...
        SYMMETRIC: Final[int] = ...
        L: Final[int] = ...
        R: Final[int] = ...
        S: Final[int] = ...
    class ASMType:
        NONE: Final[int] = ...
        BASIC: Final[int] = ...
        RESTRICT: Final[int] = ...
        INTERPOLATE: Final[int] = ...
    class GASMType:
        NONE: Final[int] = ...
        BASIC: Final[int] = ...
        RESTRICT: Final[int] = ...
        INTERPOLATE: Final[int] = ...
    class MGType:
        MULTIPLICATIVE: Final[int] = ...
        ADDITIVE: Final[int] = ...
        FULL: Final[int] = ...
        KASKADE: Final[int] = ...
    class MGCycleType:
        V: Final[int] = ...
        W: Final[int] = ...
    class GAMGType:
        AGG: Final[str] = ...
        GEO: Final[str] = ...
        CLASSICAL: Final[str] = ...
    class CompositeType:
        ADDITIVE: Final[int] = ...
        MULTIPLICATIVE: Final[int] = ...
        SYMMETRIC_MULTIPLICATIVE: Final[int] = ...
        SPECIAL: Final[int] = ...
        SCHUR: Final[int] = ...
    class FieldSplitSchurFactType:
        DIAG: Final[int] = ...
        LOWER: Final[int] = ...
        UPPER: Final[int] = ...
        FULL: Final[int] = ...
    class FieldSplitSchurPreType:
        SELF: Final[int] = ...
        SELFP: Final[int] = ...
        A11: Final[int] = ...
        USER: Final[int] = ...
        FULL: Final[int] = ...
    class PatchConstructType:
        STAR: Final[int] = ...
        VANKA: Final[int] = ...
        PARDECOMP: Final[int] = ...
        USER: Final[int] = ...
        PYTHON: Final[int] = ...
    class HPDDMCoarseCorrectionType:
        DEFLATED: Final[int] = ...
        ADDITIVE: Final[int] = ...
        BALANCED: Final[int] = ...
        NONE: Final[int] = ...
    class DeflationSpaceType:
        HAAR: Final[int] = ...
        DB2: Final[int] = ...
        DB4: Final[int] = ...
        DB8: Final[int] = ...
        DB16: Final[int] = ...
        BIORTH22: Final[int] = ...
        MEYER: Final[int] = ...
        AGGREGATION: Final[int] = ...
        USER: Final[int] = ...
    class FailedReason:
        SETUP_ERROR: Final[int] = ...
        NOERROR: Final[int] = ...
        FACTOR_STRUCT_ZEROPIVOT: Final[int] = ...
        FACTOR_NUMERIC_ZEROPIVOT: Final[int] = ...
        FACTOR_OUTMEMORY: Final[int] = ...
        FACTOR_OTHER: Final[int] = ...
        SUBPC_ERROR: Final[int] = ...
    
    
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, pc_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setOperators(self, A: Mat | None = None, P: Mat | None = None) -> None: ...
    def getOperators(self) -> tuple[Mat, Mat]: ...
    def setUseAmat(self, flag: bool) -> None: ...
    def getUseAmat(self) -> bool: ...
    def setReusePreconditioner(self, flag: bool) -> None: ...
    def setFailedReason(self, reason: FailedReason | str) -> None: ...
    def getFailedReason(self) -> FailedReason: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def setUpOnBlocks(self) -> None: ...
    def apply(self, x: Vec, y: Vec) -> None: ...
    def matApply(self, x: Mat, y: Mat) -> None: ...
    def applyTranspose(self, x: Vec, y: Vec) -> None: ...
    def matApplyTranspose(self, x: Mat, y: Mat) -> None: ...
    def applySymmetricLeft(self, x: Vec, y: Vec) -> None: ...
    def applySymmetricRight(self, x: Vec, y: Vec) -> None: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def setCoordinates(self, coordinates: Sequence[Sequence[float]]) -> None: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def getBJacobiSubKSP(self) -> list[KSP]: ...
    def setASMType(self, asmtype: ASMType) -> None: ...
    def setASMOverlap(self, overlap: int) -> None: ...
    def setASMLocalSubdomains(self, nsd: int, is_sub: Sequence[IS] | None = None, is_local: Sequence[IS] | None = None) -> None: ...
    def setASMTotalSubdomains(self, nsd: int, is_sub: Sequence[IS] | None = None, is_local: Sequence[IS] | None = None) -> None: ...
    def getASMSubKSP(self) -> list[KSP]: ...
    def setASMSortIndices(self, dosort: bool) -> None: ...
    def setGASMType(self, gasmtype: GASMType) -> None: ...
    def setGASMOverlap(self, overlap: int) -> None: ...
    def setGAMGType(self, gamgtype: GAMGType | str) -> None: ...
    def setGAMGLevels(self, levels: int) -> None: ...
    def setGAMGSmooths(self, smooths: int) -> None: ...
    def getHYPREType(self) -> str: ...
    def setHYPREType(self, hypretype: str) -> None: ...
    def setHYPREDiscreteCurl(self, mat: Mat) -> None: ...
    def setHYPREDiscreteGradient(self, mat: Mat) -> None: ...
    def setHYPRESetAlphaPoissonMatrix(self, mat: Mat) -> None: ...
    def setHYPRESetBetaPoissonMatrix(self, mat: Mat | None = None) -> None: ...
    def setHYPRESetInterpolations(self, dim: int, RT_Pi_Full: Mat | None = None, RT_Pi=None, ND_Pi_Full: Mat | None = None, ND_Pi=None) -> None: ...
    def setHYPRESetEdgeConstantVectors(self, ozz: Vec, zoz: Vec, zzo: Vec | None = None) -> None: ...
    def setHYPREAMSSetInteriorNodes(self, interior: Vec) -> None: ...
    def setFactorSolverType(self, solver: Mat.SolverType | str) -> None: ...
    def getFactorSolverType(self) -> str: ...
    def setFactorSetUpSolverType(self) -> None: ...
    def setFactorOrdering(self, ord_type: str | None = None, nzdiag: float | None = None, reuse: bool | None = None) -> None: ...
    def setFactorPivot(self, zeropivot: float | None = None, inblocks: bool | None = None) -> None: ...
    def setFactorShift(self, shift_type: Mat.FactorShiftType | None = None, amount: float | None = None) -> None: ...
    def setFactorLevels(self, levels: int) -> None: ...
    def getFactorMatrix(self) -> Mat: ...
    def setFieldSplitType(self, ctype: CompositeType) -> None: ...
    def setFieldSplitIS(self, *fields: tuple[str, IS]) -> None: ...
    def setFieldSplitFields(self, bsize: int, *fields: tuple[str, Sequence[int]]) -> None: ...
    def getFieldSplitSubKSP(self) -> list[KSP]: ...
    def getFieldSplitSchurGetSubKSP(self) -> list[KSP]: ...
    def getFieldSplitSubIS(self, splitname: str) -> IS: ...
    def setFieldSplitSchurFactType(self, ctype: FieldSplitSchurFactType) -> None: ...
    def setFieldSplitSchurPreType(self, ptype: FieldSplitSchurPreType, pre: Mat | None = None) -> None: ...
    def setCompositeType(self, ctype: CompositeType) -> None: ...
    def getCompositePC(self, n: int) -> None: ...
    def addCompositePCType(self, pc_type: Type | str) -> None: ...
    def getKSP(self) -> KSP: ...
    def getMGType(self) -> MGType: ...
    def setMGType(self, mgtype: MGType) -> None: ...
    def getMGLevels(self) -> int: ...
    def setMGLevels(self, levels: int) -> None: ...
    def getMGCoarseSolve(self) -> KSP: ...
    def setMGInterpolation(self, level, mat: Mat) -> None: ...
    def getMGInterpolation(self, level: int) -> Mat: ...
    def setMGRestriction(self, level: int, mat: Mat) -> None: ...
    def getMGRestriction(self, level: int) -> Mat: ...
    def setMGRScale(self, level: int, rscale: Vec) -> None: ...
    def getMGRScale(self, level: int) -> Vec: ...
    def getMGSmoother(self, level: int) -> KSP: ...
    def getMGSmootherDown(self, level: int) -> KSP: ...
    def getMGSmootherUp(self, level: int) -> KSP: ...
    def setMGCycleType(self, cycle_type: MGCycleType) -> None: ...
    def setMGCycleTypeOnLevel(self, level: int, cycle_type: MGCycleType) -> None: ...
    def setMGRhs(self, level: int, rhs: Vec) -> None: ...
    def setMGX(self, level: int, x: Vec) -> None: ...
    def setMGR(self, level: int, r: Vec) -> None: ...
    def setBDDCLocalAdjacency(self, csr: CSRIndicesSpec) -> None: ...
    def setBDDCDivergenceMat(self, div: Mat, trans: bool = False, l2l: IS | None = None) -> None: ...
    def setBDDCDiscreteGradient(self, G: Mat, order: int = 1, field: int = 1, gord: bool = True, conforming: bool = True) -> None: ...
    def setBDDCChangeOfBasisMat(self, T: Mat, interior: bool = False) -> None: ...
    def setBDDCPrimalVerticesIS(self, primv: IS) -> None: ...
    def setBDDCPrimalVerticesLocalIS(self, primv: IS) -> None: ...
    def setBDDCCoarseningRatio(self, cratio: int) -> None: ...
    def setBDDCLevels(self, levels: int) -> None: ...
    def setBDDCDirichletBoundaries(self, bndr: IS) -> None: ...
    def setBDDCDirichletBoundariesLocal(self, bndr: IS) -> None: ...
    def setBDDCNeumannBoundaries(self, bndr: IS) -> None: ...
    def setBDDCNeumannBoundariesLocal(self, bndr: IS) -> None: ...
    def setBDDCDofsSplitting(self, isfields: IS | Sequence[IS]) -> None: ...
    def setBDDCDofsSplittingLocal(self, isfields: IS | Sequence[IS]) -> None: ...
    def getPatchSubKSP(self) -> list[KSP]: ...
    def setPatchCellNumbering(self, sec: Section) -> None: ...
    def setPatchDiscretisationInfo(self, dms, bs, cellNodeMaps, subspaceOffsets, ghostBcNodes, globalBcNodes) -> None: ...
    def setPatchComputeOperator(self, operator, args=None, kargs=None) -> None: ...
    def setPatchComputeOperatorInteriorFacets(self, operator, args=None, kargs=None) -> None: ...
    def setPatchComputeFunction(self, function, args=None, kargs=None) -> None: ...
    def setPatchComputeFunctionInteriorFacets(self, function, args=None, kargs=None) -> None: ...
    def setPatchConstructType(self, typ, operator=None, args=None, kargs=None) -> None: ...
    def setHPDDMAuxiliaryMat(self, uis: IS, uaux: Mat) -> None: ...
    def setHPDDMRHSMat(self, B: Mat) -> None: ...
    def getHPDDMComplexities(self) -> tuple[float, float]: ...
    def setHPDDMHasNeumannMat(self, has: bool) -> None: ...
    def setHPDDMCoarseCorrectionType(self, correction_type: HPDDMCoarseCorrectionType) -> None: ...
    def getHPDDMCoarseCorrectionType(self) -> HPDDMCoarseCorrectionType: ...
    def getHPDDMSTShareSubKSP(self) -> bool: ...
    def setHPDDMDeflationMat(self, uis: IS, U: Mat) -> None: ...
    def setSPAIEpsilon(self, val: float) -> None: ...
    def setSPAINBSteps(self, nbsteps: int) -> None: ...
    def setSPAIMax(self, maxval: int) -> None: ...
    def setSPAIMaxNew(self, maxval: int) -> None: ...
    def setSPAIBlockSize(self, n: int) -> None: ...
    def setSPAICacheSize(self, size: int) -> None: ...
    def setSPAIVerbose(self, level: int) -> None: ...
    def setSPAISp(self, sym: int) -> None: ...
    def setDeflationInitOnly(self, flg: bool) -> None: ...
    def setDeflationLevels(self, levels: int) -> None: ...
    def setDeflationReductionFactor(self, red: int) -> None: ...
    def setDeflationCorrectionFactor(self, fact: float) -> None: ...
    def setDeflationSpaceToCompute(self, space_type: DeflationSpaceType, size: int) -> None: ...
    def setDeflationSpace(self, W: Mat, transpose: bool) -> None: ...
    def setDeflationProjectionNullSpaceMat(self, mat: Mat) -> None: ...
    def setDeflationCoarseMat(self, mat: Mat) -> None: ...
    def getDeflationCoarseKSP(self) -> KSP: ...
    def getDeflationPC(self) -> PC: ...

class KSP(Object):
    class Type:
        RICHARDSON: Final[str] = ...
        CHEBYSHEV: Final[str] = ...
        CG: Final[str] = ...
        GROPPCG: Final[str] = ...
        PIPECG: Final[str] = ...
        PIPECGRR: Final[str] = ...
        PIPELCG: Final[str] = ...
        PIPEPRCG: Final[str] = ...
        PIPECG2: Final[str] = ...
        CGNE: Final[str] = ...
        NASH: Final[str] = ...
        STCG: Final[str] = ...
        GLTR: Final[str] = ...
        FCG: Final[str] = ...
        PIPEFCG: Final[str] = ...
        GMRES: Final[str] = ...
        PIPEFGMRES: Final[str] = ...
        FGMRES: Final[str] = ...
        LGMRES: Final[str] = ...
        DGMRES: Final[str] = ...
        PGMRES: Final[str] = ...
        TCQMR: Final[str] = ...
        BCGS: Final[str] = ...
        IBCGS: Final[str] = ...
        QMRCGS: Final[str] = ...
        FBCGS: Final[str] = ...
        FBCGSR: Final[str] = ...
        BCGSL: Final[str] = ...
        PIPEBCGS: Final[str] = ...
        CGS: Final[str] = ...
        TFQMR: Final[str] = ...
        CR: Final[str] = ...
        PIPECR: Final[str] = ...
        LSQR: Final[str] = ...
        PREONLY: Final[str] = ...
        NONE: Final[str] = ...
        QCG: Final[str] = ...
        BICG: Final[str] = ...
        MINRES: Final[str] = ...
        SYMMLQ: Final[str] = ...
        LCD: Final[str] = ...
        PYTHON: Final[str] = ...
        GCR: Final[str] = ...
        PIPEGCR: Final[str] = ...
        TSIRM: Final[str] = ...
        CGLS: Final[str] = ...
        FETIDP: Final[str] = ...
        HPDDM: Final[str] = ...
    class NormType:
        NORM_DEFAULT: Final[int] = ...
        NORM_NONE: Final[int] = ...
        NORM_PRECONDITIONED: Final[int] = ...
        NORM_UNPRECONDITIONED: Final[int] = ...
        NORM_NATURAL: Final[int] = ...
        DEFAULT: Final[int] = ...
        NONE: Final[int] = ...
        NO: Final[int] = ...
        PRECONDITIONED: Final[int] = ...
        UNPRECONDITIONED: Final[int] = ...
        NATURAL: Final[int] = ...
    class ConvergedReason:
        CONVERGED_ITERATING: Final[int] = ...
        ITERATING: Final[int] = ...
        CONVERGED_RTOL_NORMAL_EQUATIONS: Final[int] = ...
        CONVERGED_ATOL_NORMAL_EQUATIONS: Final[int] = ...
        CONVERGED_RTOL: Final[int] = ...
        CONVERGED_ATOL: Final[int] = ...
        CONVERGED_ITS: Final[int] = ...
        CONVERGED_NEG_CURVE: Final[int] = ...
        CONVERGED_STEP_LENGTH: Final[int] = ...
        CONVERGED_HAPPY_BREAKDOWN: Final[int] = ...
        DIVERGED_NULL: Final[int] = ...
        DIVERGED_MAX_IT: Final[int] = ...
        DIVERGED_DTOL: Final[int] = ...
        DIVERGED_BREAKDOWN: Final[int] = ...
        DIVERGED_BREAKDOWN_BICG: Final[int] = ...
        DIVERGED_NONSYMMETRIC: Final[int] = ...
        DIVERGED_INDEFINITE_PC: Final[int] = ...
        DIVERGED_NANORINF: Final[int] = ...
        DIVERGED_INDEFINITE_MAT: Final[int] = ...
        DIVERGED_PCSETUP_FAILED: Final[int] = ...
    class HPDDMType:
        GMRES: Final[int] = ...
        BGMRES: Final[int] = ...
        CG: Final[int] = ...
        BCG: Final[int] = ...
        GCRODR: Final[int] = ...
        BGCRODR: Final[int] = ...
        BFBCG: Final[int] = ...
        PREONLY: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, ksp_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def getAppCtx(self) -> Any: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def setDMActive(self, flag: bool) -> None: ...
    def setComputeRHS(self, rhs: KSPRHSFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setComputeOperators(self, operators: KSPOperatorsFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setOperators(self, A: Mat | None = None, P: Mat | None = None) -> None: ...
    def getOperators(self) -> tuple[Mat, Mat]: ...
    def setPC(self, pc: PC) -> None: ...
    def getPC(self) -> PC: ...
    def setTolerances(self, rtol: float | None = None, atol: float | None = None, divtol: float | None = None, max_it: int | None = None) -> None: ...
    def getTolerances(self) -> tuple[float, float, float, int]: ...
    def setConvergenceTest(self, converged: KSPConvergenceTestFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def addConvergenceTest(self, converged: KSPConvergenceTestFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None, prepend: bool = False) -> None: ...
    def getConvergenceTest(self) -> KSPConvergenceTestFunction: ...
    def callConvergenceTest(self, its: int, rnorm: float) -> None: ...
    def setConvergenceHistory(self, length: int | None = None, reset: bool = False) -> None: ...
    def getConvergenceHistory(self) -> ArrayReal: ...
    def logConvergenceHistory(self, rnorm: float) -> None: ...
    def setMonitor(self, monitor: KSPMonitorFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getMonitor(self) -> KSPMonitorFunction: ...
    def monitorCancel(self) -> None: ...
    def monitor(self, its: int, rnorm: float) -> None: ...
    def setPCSide(self, side: PC.Side) -> None: ...
    def getPCSide(self) -> PC.Side: ...
    def setNormType(self, normtype: NormType) -> None: ...
    def getNormType(self) -> NormType: ...
    def setComputeEigenvalues(self, flag: bool) -> None: ...
    def getComputeEigenvalues(self) -> bool: ...
    def setComputeSingularValues(self, flag: bool) -> None: ...
    def getComputeSingularValues(self) -> bool: ...
    def setInitialGuessNonzero(self, flag: bool) -> None: ...
    def getInitialGuessNonzero(self) -> bool: ...
    def setInitialGuessKnoll(self, flag: bool) -> None: ...
    def getInitialGuessKnoll(self) -> bool: ...
    def setUseFischerGuess(self, model: int, size: int) -> None: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def setUpOnBlocks(self) -> None: ...
    def setPreSolve(self, presolve: KSPPreSolveFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setPostSolve(self, postsolve: KSPPostSolveFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def solve(self, b: Vec, x: Vec) -> None: ...
    def solveTranspose(self, b: Vec, x: Vec) -> None: ...
    def matSolve(self, B: Mat, X: Mat) -> None: ...
    def matSolveTranspose(self, B: Mat, X: Mat) -> None: ...
    def setIterationNumber(self, its: int) -> None: ...
    def getIterationNumber(self) -> int: ...
    def setResidualNorm(self, rnorm: float) -> None: ...
    def getResidualNorm(self) -> float: ...
    def setConvergedReason(self, reason: KSP.ConvergedReason) -> None: ...
    def getConvergedReason(self) -> KSP.ConvergedReason: ...
    def getCGObjectiveValue(self) -> float: ...
    def setHPDDMType(self, hpddm_type: HPDDMType) -> None: ...
    def getHPDDMType(self) -> HPDDMType: ...
    def setErrorIfNotConverged(self, flag: bool) -> None: ...
    def getErrorIfNotConverged(self) -> bool: ...
    def getRhs(self) -> Vec: ...
    def getSolution(self) -> Vec: ...
    def getWorkVecs(self, right: int | None = None, left: int | None = None) -> tuple[list[Vec], list[Vec]] | list[Vec] | None: ...
    def buildSolution(self, x: Vec | None = None) -> Vec: ...
    def buildResidual(self, r: Vec | None = None) -> Vec: ...
    def computeEigenvalues(self) -> ArrayComplex: ...
    def computeExtremeSingularValues(self) -> tuple[float, float]: ...
    def setGMRESRestart(self, restart: int) -> None: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any | None = None) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    appctx: Any
    dm: DM
    vec_sol: Vec
    vec_rhs: Vec
    mat_op: Mat
    mat_pc: Mat
    guess_nonzero: bool
    guess_knoll: bool
    pc: PC
    pc_side: PC.Side
    norm_type: NormType
    rtol: float
    atol: float
    divtol: float
    max_it: int
    its: int
    norm: float
    history: ndarray
    reason: KSP.ConvergedReason
    is_iterating: bool
    is_converged: bool
    is_diverged: bool
    cancelMonitor = monitorCancel

class SNES(Object):
    class Type:
        NEWTONLS: Final[str] = ...
        NEWTONTR: Final[str] = ...
        NEWTONAL: Final[str] = ...
        PYTHON: Final[str] = ...
        NRICHARDSON: Final[str] = ...
        KSPONLY: Final[str] = ...
        KSPTRANSPOSEONLY: Final[str] = ...
        VINEWTONRSLS: Final[str] = ...
        VINEWTONSSLS: Final[str] = ...
        NGMRES: Final[str] = ...
        QN: Final[str] = ...
        SHELL: Final[str] = ...
        NGS: Final[str] = ...
        NCG: Final[str] = ...
        FAS: Final[str] = ...
        MS: Final[str] = ...
        NASM: Final[str] = ...
        ANDERSON: Final[str] = ...
        ASPIN: Final[str] = ...
        COMPOSITE: Final[str] = ...
        PATCH: Final[str] = ...
    class NormSchedule:
        NORM_DEFAULT: Final[int] = ...
        NORM_NONE: Final[int] = ...
        NORM_ALWAYS: Final[int] = ...
        NORM_INITIAL_ONLY: Final[int] = ...
        NORM_FINAL_ONLY: Final[int] = ...
        NORM_INITIAL_FINAL_ONLY: Final[int] = ...
        DEFAULT: Final[int] = ...
        NONE: Final[int] = ...
        ALWAYS: Final[int] = ...
        INITIAL_ONLY: Final[int] = ...
        FINAL_ONLY: Final[int] = ...
        INITIAL_FINAL_ONLY: Final[int] = ...
    class ConvergedReason:
        CONVERGED_ITERATING: Final[int] = ...
        ITERATING: Final[int] = ...
        CONVERGED_FNORM_ABS: Final[int] = ...
        CONVERGED_FNORM_RELATIVE: Final[int] = ...
        CONVERGED_SNORM_RELATIVE: Final[int] = ...
        CONVERGED_ITS: Final[int] = ...
        DIVERGED_FUNCTION_DOMAIN: Final[int] = ...
        DIVERGED_FUNCTION_NANORINF: Final[int] = ...
        DIVERGED_OBJECTIVE_DOMAIN: Final[int] = ...
        DIVERGED_OBJECTIVE_NANORINF: Final[int] = ...
        DIVERGED_JACOBIAN_DOMAIN: Final[int] = ...
        DIVERGED_FUNCTION_COUNT: Final[int] = ...
        DIVERGED_LINEAR_SOLVE: Final[int] = ...
        DIVERGED_MAX_IT: Final[int] = ...
        DIVERGED_LINE_SEARCH: Final[int] = ...
        DIVERGED_INNER: Final[int] = ...
        DIVERGED_LOCAL_MIN: Final[int] = ...
        DIVERGED_DTOL: Final[int] = ...
        DIVERGED_TR_DELTA: Final[int] = ...
    class NewtonALCorrectionType:
        EXACT: Final[int] = ...
        NORMAL: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, snes_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setApplicationContext(self, appctx: Any) -> None: ...
    def getApplicationContext(self) -> Any: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def setTRTolerances(self, delta_min: float | None = None, delta_max: float | None = None, delta_0: float | None = None) -> None: ...
    def getTRTolerances(self) -> tuple[float, float, float]: ...
    def setTRUpdateParameters(self, eta1: float | None = None, eta2: float | None = None, eta3: float | None = None, t1: float | None = None, t2: float | None = None) -> None: ...
    def getTRUpdateParameters(self) -> tuple[float, float, float, float, float]: ...
    def setFASInterpolation(self, level: int, mat: Mat) -> None: ...
    def getFASInterpolation(self, level: int) -> Mat: ...
    def setFASRestriction(self, level: int, mat: Mat) -> None: ...
    def getFASRestriction(self, level: int) -> Mat: ...
    def setFASInjection(self, level: int, mat: Mat) -> None: ...
    def getFASInjection(self, level: int) -> Mat: ...
    def setFASRScale(self, level: int, vec: Vec) -> None: ...
    def setFASLevels(self, levels: int, comms: Sequence[Comm] | None = None) -> None: ...
    def getFASLevels(self) -> int: ...
    def getFASCycleSNES(self, level: int) -> SNES: ...
    def getFASCoarseSolve(self) -> SNES: ...
    def getFASSmoother(self, level: int) -> SNES: ...
    def getFASSmootherDown(self, level: int) -> SNES: ...
    def getFASSmootherUp(self, level: int) -> SNES: ...
    def getNPC(self) -> SNES: ...
    def hasNPC(self) -> bool: ...
    def setNPC(self, snes: SNES) -> None: ...
    def setNPCSide(self, side: PC.Side) -> None: ...
    def getNPCSide(self) -> PC.Side: ...
    def setLineSearchPreCheck(self, precheck: SNESLSPreFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setInitialGuess(self, initialguess: SNESGuessFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getInitialGuess(self) -> SNESGuessFunction: ...
    def setFunction(self, function: SNESFunction | None, f: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getFunction(self) -> SNESFunction: ...
    def setUpdate(self, update: SNESUpdateFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getUpdate(self) -> SNESUpdateFunction: ...
    def setJacobian(self, jacobian: SNESJacobianFunction | None, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getJacobian(self) -> tuple[Mat, Mat, SNESJacobianFunction]: ...
    def setObjective(self, objective: SNESObjFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getObjective(self) -> SNESObjFunction: ...
    def computeFunction(self, x: Vec, f: Vec) -> None: ...
    def computeJacobian(self, x: Vec, J: Mat, P: Mat | None = None) -> None: ...
    def computeObjective(self, x: Vec) -> float: ...
    def setNGS(self, ngs: SNESNGSFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getNGS(self) -> SNESNGSFunction: ...
    def computeNGS(self, x: Vec, b: Vec | None = None) -> None: ...
    def setTolerances(self, rtol: float | None = None, atol: float | None = None, stol: float | None = None, max_it: int | None = None) -> None: ...
    def getTolerances(self) -> tuple[float, float, float, int]: ...
    def setDivergenceTolerance(self, dtol: float) -> None: ...
    def getDivergenceTolerance(self) -> float: ...
    def setNormSchedule(self, normsched: NormSchedule) -> None: ...
    def getNormSchedule(self) -> NormSchedule: ...
    def setConvergenceTest(self, converged: SNESConvergedFunction | Literal['skip', 'default'], args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getConvergenceTest(self) -> SNESConvergedFunction: ...
    def callConvergenceTest(self, its: int, xnorm: float, ynorm: float, fnorm: float) -> ConvergedReason: ...
    def converged(self, its: int, xnorm: float, ynorm: float, fnorm: float) -> None: ...
    def setConvergenceHistory(self, length=None, reset=False) -> None: ...
    def getConvergenceHistory(self) -> tuple[ArrayReal, ArrayInt]: ...
    def logConvergenceHistory(self, norm: float, linear_its: int = 0) -> None: ...
    def setResetCounters(self, reset: bool = True) -> None: ...
    def setMonitor(self, monitor: SNESMonitorFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getMonitor(self) -> list[tuple[SNESMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def monitorCancel(self) -> None: ...
    def monitor(self, its, rnorm) -> None: ...
    def setMaxFunctionEvaluations(self, max_funcs: int) -> None: ...
    def getMaxFunctionEvaluations(self) -> int: ...
    def getFunctionEvaluations(self) -> int: ...
    def setMaxStepFailures(self, max_fails: int) -> None: ...
    def getMaxStepFailures(self) -> int: ...
    def getStepFailures(self) -> int: ...
    def setMaxKSPFailures(self, max_fails: int) -> None: ...
    def getMaxKSPFailures(self) -> int: ...
    def getKSPFailures(self) -> int: ...
    def setUp(self) -> None: ...
    def setUpMatrices(self) -> None: ...
    def reset(self) -> None: ...
    def solve(self, b: Vec | None = None, x: Vec | None = None) -> None: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def setErrorIfNotConverged(self, flag: bool) -> None: ...
    def getErrorIfNotConverged(self) -> bool: ...
    def setIterationNumber(self, its: int) -> None: ...
    def getIterationNumber(self) -> int: ...
    def setForceIteration(self, force: bool) -> None: ...
    def setFunctionNorm(self, norm: float) -> None: ...
    def getFunctionNorm(self) -> float: ...
    def getLinearSolveIterations(self) -> int: ...
    def getRhs(self) -> Vec: ...
    def getSolution(self) -> Vec: ...
    def setSolution(self, vec: Vec) -> None: ...
    def getSolutionUpdate(self) -> Vec: ...
    def setKSP(self, ksp: KSP) -> None: ...
    def getKSP(self) -> KSP: ...
    def setUseEW(self, flag: bool = True, *targs: Any, **kargs: Any) -> None: ...
    def getUseEW(self) -> bool: ...
    def setParamsEW(self, version: int | None = None, rtol_0: float | None = None, rtol_max: float | None = None, gamma: float | None = None, alpha: float | None = None, alpha2: float | None = None, threshold: float | None = None) -> None: ...
    def getParamsEW(self) -> dict[str, int | float]: ...
    def setUseKSP(self, flag=True) -> None: ...
    def getUseKSP(self) -> bool: ...
    def setUseMF(self, flag=True) -> None: ...
    def getUseMF(self) -> bool: ...
    def setUseFD(self, flag=True) -> None: ...
    def getUseFD(self) -> bool: ...
    def setVariableBounds(self, xl: Vec, xu: Vec) -> None: ...
    def getVariableBounds(self) -> tuple[Vec, Vec]: ...
    def getVIInactiveSet(self) -> IS: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def getCompositeSNES(self, n: int) -> SNES: ...
    def getCompositeNumber(self) -> int: ...
    def getNASMSNES(self, n: int) -> SNES: ...
    def getNASMNumber(self) -> int: ...
    def setPatchCellNumbering(self, sec: Section) -> None: ...
    def setPatchDiscretisationInfo(self, dms, bs, cellNodeMaps, subspaceOffsets, ghostBcNodes, globalBcNodes) -> None: ...
    def setPatchComputeOperator(self, operator, args=None, kargs=None) -> None: ...
    def setPatchComputeFunction(self, function, args=None, kargs=None) -> None: ...
    def setPatchConstructType(self, typ, operator=None, args=None, kargs=None) -> None: ...
    def getLineSearch(self) -> SNESLineSearch: ...
    def setLineSearch(self, linesearch: SNESLineSearch) -> None: ...
    def setNewtonALFunction(self, function: SNESFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getNewtonALLoadParameter(self) -> float: ...
    def setNewtonALCorrectionType(self, corrtype: NewtonALCorrectionType) -> None: ...
    appctx: Any
    dm: DM
    npc: SNES
    vec_sol: Vec
    vec_upd: Vec
    vec_rhs: Vec
    ksp: KSP
    use_ksp: bool
    use_ew: bool
    rtol: float
    atol: float
    stol: float
    max_it: int
    max_funcs: int
    its: int
    norm: float
    history: tuple[ArrayReal, ArrayInt]
    reason: ConvergedReason
    is_iterating: bool
    is_converged: bool
    is_diverged: bool
    use_mf: bool
    use_fd: bool
    linesearch: SNESLineSearch
    setAppCtx = setApplicationContext
    getAppCtx = getApplicationContext
    cancelMonitor = monitorCancel
    setMaxNonlinearStepFailures = setMaxStepFailures
    getMaxNonlinearStepFailures = getMaxStepFailures
    getNonlinearStepFailures = getStepFailures
    setMaxLinearSolveFailures = setMaxKSPFailures
    getMaxLinearSolveFailures = getMaxKSPFailures
    getLinearSolveFailures = getKSPFailures

class SNESLineSearch(Object):
    class Type:
        BT: Final[str] = ...
        NLEQERR: Final[str] = ...
        BASIC: Final[str] = ...
        NONE: Final[str] = ...
        SECANT: Final[str] = ...
        CP: Final[str] = ...
        SHELL: Final[str] = ...
        NCGLINEAR: Final[str] = ...
        BISECTION: Final[str] = ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setFromOptions(self) -> None: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def getType(self) -> str: ...
    def setType(self, ls_type: Type | str) -> None: ...
    def getTolerances(self) -> tuple[float, float, float, float, float, int]: ...
    def setTolerances(self, minstep: float | None = None, maxstep: float | None = None, rtol: float | None = None, atol: float | None = None, ltol: float | None = None, max_its: int | None = None) -> None: ...
    def getOrder(self) -> int: ...
    def setOrder(self, order: int) -> None: ...
    def destroy(self) -> Self: ...

class TS(Object):
    class Type:
        EULER: Final[str] = ...
        BEULER: Final[str] = ...
        BASICSYMPLECTIC: Final[str] = ...
        PSEUDO: Final[str] = ...
        CN: Final[str] = ...
        SUNDIALS: Final[str] = ...
        RK: Final[str] = ...
        PYTHON: Final[str] = ...
        THETA: Final[str] = ...
        ALPHA: Final[str] = ...
        ALPHA2: Final[str] = ...
        GLLE: Final[str] = ...
        GLEE: Final[str] = ...
        SSP: Final[str] = ...
        ARKIMEX: Final[str] = ...
        DIRK: Final[str] = ...
        ROSW: Final[str] = ...
        EIMEX: Final[str] = ...
        MIMEX: Final[str] = ...
        BDF: Final[str] = ...
        RADAU5: Final[str] = ...
        MPRK: Final[str] = ...
        DISCGRAD: Final[str] = ...
        FE: Final[str] = ...
        BE: Final[str] = ...
        TH: Final[str] = ...
        CRANK_NICOLSON: Final[str] = ...
        RUNGE_KUTTA: Final[str] = ...
    class RKType:
        RK1FE: Final[str] = ...
        RK2A: Final[str] = ...
        RK2B: Final[str] = ...
        RK4: Final[str] = ...
        RK3BS: Final[str] = ...
        RK3: Final[str] = ...
        RK5F: Final[str] = ...
        RK5DP: Final[str] = ...
        RK5BS: Final[str] = ...
        RK6VR: Final[str] = ...
        RK7VR: Final[str] = ...
        RK8VR: Final[str] = ...
    class ARKIMEXType:
        ARKIMEX1BEE: Final[str] = ...
        ARKIMEXA2: Final[str] = ...
        ARKIMEXL2: Final[str] = ...
        ARKIMEXARS122: Final[str] = ...
        ARKIMEX2C: Final[str] = ...
        ARKIMEX2D: Final[str] = ...
        ARKIMEX2E: Final[str] = ...
        ARKIMEXPRSSP2: Final[str] = ...
        ARKIMEX3: Final[str] = ...
        ARKIMEXBPR3: Final[str] = ...
        ARKIMEXARS443: Final[str] = ...
        ARKIMEX4: Final[str] = ...
        ARKIMEX5: Final[str] = ...
    class DIRKType:
        DIRKS212: Final[str] = ...
        DIRKES122SAL: Final[str] = ...
        DIRKES213SAL: Final[str] = ...
        DIRKES324SAL: Final[str] = ...
        DIRKES325SAL: Final[str] = ...
        DIRK657A: Final[str] = ...
        DIRKES648SA: Final[str] = ...
        DIRK658A: Final[str] = ...
        DIRKS659A: Final[str] = ...
        DIRK7510SAL: Final[str] = ...
        DIRKES7510SA: Final[str] = ...
        DIRK759A: Final[str] = ...
        DIRKS7511SAL: Final[str] = ...
        DIRK8614A: Final[str] = ...
        DIRK8616SAL: Final[str] = ...
        DIRKES8516SAL: Final[str] = ...
    class ProblemType:
        LINEAR: Final[int] = ...
        NONLINEAR: Final[int] = ...
    class EquationType:
        UNSPECIFIED: Final[int] = ...
        EXPLICIT: Final[int] = ...
        ODE_EXPLICIT: Final[int] = ...
        DAE_SEMI_EXPLICIT_INDEX1: Final[int] = ...
        DAE_SEMI_EXPLICIT_INDEX2: Final[int] = ...
        DAE_SEMI_EXPLICIT_INDEX3: Final[int] = ...
        DAE_SEMI_EXPLICIT_INDEXHI: Final[int] = ...
        IMPLICIT: Final[int] = ...
        ODE_IMPLICIT: Final[int] = ...
        DAE_IMPLICIT_INDEX1: Final[int] = ...
        DAE_IMPLICIT_INDEX2: Final[int] = ...
        DAE_IMPLICIT_INDEX3: Final[int] = ...
        DAE_IMPLICIT_INDEXHI: Final[int] = ...
    class ExactFinalTime:
        UNSPECIFIED: Final[int] = ...
        STEPOVER: Final[int] = ...
        INTERPOLATE: Final[int] = ...
        MATCHSTEP: Final[int] = ...
    
    class ConvergedReason:
        CONVERGED_ITERATING: Final[int] = ...
        ITERATING: Final[int] = ...
        CONVERGED_TIME: Final[int] = ...
        CONVERGED_ITS: Final[int] = ...
        CONVERGED_USER: Final[int] = ...
        CONVERGED_EVENT: Final[int] = ...
        DIVERGED_NONLINEAR_SOLVE: Final[int] = ...
        DIVERGED_STEP_REJECTED: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def load(self, viewer: Viewer) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def clone(self) -> TS: ...
    def setType(self, ts_type: Type | str) -> None: ...
    def setRKType(self, ts_type: RKType | str) -> None: ...
    def setARKIMEXType(self, ts_type: ARKIMEXType | str) -> None: ...
    def setARKIMEXFullyImplicit(self, flag: bool) -> None: ...
    def setARKIMEXFastSlowSplit(self, flag: bool) -> None: ...
    def getType(self) -> str: ...
    def getRKType(self) -> str: ...
    def getARKIMEXType(self) -> str: ...
    def setDIRKType(self, ts_type: DIRKType | str) -> None: ...
    def getDIRKType(self) -> str: ...
    def setProblemType(self, ptype: ProblemType) -> None: ...
    def getProblemType(self) -> ProblemType: ...
    def setEquationType(self, eqtype: EquationType) -> None: ...
    def getEquationType(self) -> EquationType: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def getAppCtx(self) -> Any: ...
    def setRHSFunction(self, function: TSRHSFunction | None, f: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setRHSJacobian(self, jacobian: TSRHSJacobian | None, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def computeRHSFunction(self, t: float, x: Vec, f: Vec) -> None: ...
    def computeRHSFunctionLinear(self, t: float, x: Vec, f: Vec) -> None: ...
    def computeRHSJacobian(self, t: float, x: Vec, J: Mat, P: Mat | None = None) -> None: ...
    def computeRHSJacobianConstant(self, t: float, x: Vec, J: Mat, P: Mat | None = None) -> None: ...
    def getRHSFunction(self) -> tuple[Vec, TSRHSFunction]: ...
    def getRHSJacobian(self) -> tuple[Mat, Mat, TSRHSJacobian]: ...
    def setIFunction(self, function: TSIFunction | None, f: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setIJacobian(self, jacobian: TSIJacobian | None, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setIJacobianP(self, jacobian, J: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def computeIFunction(self, t: float, x: Vec, xdot: Vec, f: Vec, imex: bool = False) -> None: ...
    def computeIJacobian(self, t: float, x: Vec, xdot: Vec, a: float, J: Mat, P: Mat | None = None, imex: bool = False) -> None: ...
    def computeIJacobianP(self, t: float, x: Vec, xdot: Vec, a: float, J: Mat, imex: bool = False) -> None: ...
    def getIFunction(self) -> tuple[Vec, TSIFunction]: ...
    def getIJacobian(self) -> tuple[Mat, Mat, TSIJacobian]: ...
    def setI2Function(self, function: TSI2Function | None, f: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setI2Jacobian(self, jacobian: TSI2Jacobian | None, J: Mat | None = None, P: Mat | None = None, args=None, kargs=None) -> None: ...
    def computeI2Function(self, t: float, x: Vec, xdot: Vec, xdotdot: Vec, f: Vec) -> None: ...
    def computeI2Jacobian(self, t: float, x: Vec, xdot: Vec, xdotdot: Vec, v: float, a: float, J: Mat, P: Mat | None = None) -> None: ...
    def getI2Function(self) -> tuple[Vec, TSI2Function]: ...
    def getI2Jacobian(self) -> tuple[Mat, Mat, TSI2Jacobian]: ...
    def setRHSSplitIS(self, splitname: str, iss: IS) -> None: ...
    def setRHSSplitRHSFunction(self, splitname: str, function: TSRHSFunction, r: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setRHSSplitIFunction(self, splitname: str, function: TSIFunction, r: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setRHSSplitIJacobian(self, splitname: str, jacobian: TSRHSJacobian, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setSolution(self, u: Vec) -> None: ...
    def getSolution(self) -> Vec: ...
    def setSolution2(self, u: Vec, v: Vec) -> None: ...
    def getSolution2(self) -> tuple[Vec, Vec]: ...
    def setEvaluationTimes(self, tspan: Sequence[float]) -> None: ...
    def getEvaluationTimes(self) -> ArrayReal: ...
    def getEvaluationSolutions(self) -> tuple[ArrayReal, list[Vec]]: ...
    def setTimeSpan(self, tspan: Sequence[float]) -> None: ...
    def getTimeSpanSolutions(self) -> list[Vec]: ...
    def getSNES(self) -> SNES: ...
    def getKSP(self) -> KSP: ...
    def getDM(self) -> DM: ...
    def setDM(self, dm: DM) -> None: ...
    def setTime(self, t: float) -> None: ...
    def getTime(self) -> float: ...
    def getPrevTime(self) -> float: ...
    def getSolveTime(self) -> float: ...
    def setTimeStep(self, time_step: float) -> None: ...
    def getTimeStep(self) -> float: ...
    def setStepNumber(self, step_number: int) -> None: ...
    def getStepNumber(self) -> int: ...
    def setMaxTime(self, max_time: float) -> None: ...
    def getMaxTime(self) -> float: ...
    def setMaxSteps(self, max_steps: int) -> None: ...
    def getMaxSteps(self) -> int: ...
    def getSNESIterations(self) -> int: ...
    def getKSPIterations(self) -> int: ...
    def setMaxStepRejections(self, n: int) -> None: ...
    def getStepRejections(self) -> int: ...
    def setMaxSNESFailures(self, n: int) -> None: ...
    def getSNESFailures(self) -> int: ...
    def setErrorIfStepFails(self, flag: bool = True) -> None: ...
    def setTolerances(self, rtol: float | None = None, atol: float | None = None) -> None: ...
    def getTolerances(self) -> tuple[float, float]: ...
    def setExactFinalTime(self, option: ExactFinalTime) -> None: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def setMonitor(self, monitor: TSMonitorFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getMonitor(self) -> list[tuple[TSMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def monitorCancel(self) -> None: ...
    def monitor(self, step: int, time: float, u: Vec | None = None) -> None: ...
    def setEventHandler(self, direction: Sequence[int], terminate: Sequence[bool], indicator: TSIndicatorFunction | None, postevent: TSPostEventFunction | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setEventTolerances(self, tol: float | None = None, vtol: Sequence[float] | None = None) -> None: ...
    def getNumEvents(self) -> int: ...
    def setPreStep(self, prestep: TSPreStepFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getPreStep(self) -> tuple[TSPreStepFunction, tuple[Any, ...] | None, dict[str, Any] | None]: ...
    def setPostStep(self, poststep: TSPostStepFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getPostStep(self) -> tuple[TSPostStepFunction, tuple[Any, ...] | None, dict[str, Any] | None]: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def step(self) -> None: ...
    def restartStep(self) -> None: ...
    def rollBack(self) -> None: ...
    def solve(self, u: Vec | None = None) -> None: ...
    def interpolate(self, t: float, u: Vec) -> None: ...
    def setStepLimits(self, hmin: float, hmax: float) -> None: ...
    def getStepLimits(self) -> tuple[float, float]: ...
    def setSaveTrajectory(self) -> None: ...
    def removeTrajectory(self) -> None: ...
    def getCostIntegral(self) -> Vec: ...
    def setCostGradients(self, vl: Vec | Sequence[Vec] | None, vm: Vec | Sequence[Vec] | None = None) -> None: ...
    def getCostGradients(self) -> tuple[list[Vec], list[Vec]]: ...
    def setRHSJacobianP(self, rhsjacobianp: TSRHSJacobianP | None, A: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def createQuadratureTS(self, forward: bool = True) -> TS: ...
    def getQuadratureTS(self) -> tuple[bool, TS]: ...
    def computeRHSJacobianP(self, t: float, x: Vec, J: Mat) -> None: ...
    def adjointSetSteps(self, adjoint_steps: int) -> None: ...
    def adjointSetUp(self) -> None: ...
    def adjointSolve(self) -> None: ...
    def adjointStep(self) -> None: ...
    def adjointReset(self) -> None: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def setTheta(self, theta: float) -> None: ...
    def getTheta(self) -> float: ...
    def setThetaEndpoint(self, flag=True) -> None: ...
    def getThetaEndpoint(self) -> bool: ...
    def setAlphaRadius(self, radius: float) -> None: ...
    def setAlphaParams(self, alpha_m: float | None = None, alpha_f: float | None = None, gamma: float | None = None) -> None: ...
    def getAlphaParams(self) -> tuple[float, float, float]: ...
    appctx: Any
    dm: DM
    problem_type: ProblemType
    equation_type: EquationType
    snes: SNES
    ksp: KSP
    vec_sol: Vec
    time: float
    time_step: None
    step_number: int
    max_time: float
    max_steps: int
    rtol: float
    atol: float
    reason: ConvergedReason
    iterating: bool
    converged: bool
    diverged: bool
    getTimeSpan = getEvaluationTimes
    cancelMonitor = monitorCancel

class TAO(Object):
    class Type:
        LMVM: Final[str] = ...
        NLS: Final[str] = ...
        NTR: Final[str] = ...
        NTL: Final[str] = ...
        CG: Final[str] = ...
        TRON: Final[str] = ...
        OWLQN: Final[str] = ...
        BMRM: Final[str] = ...
        BLMVM: Final[str] = ...
        BQNLS: Final[str] = ...
        BNCG: Final[str] = ...
        BNLS: Final[str] = ...
        BNTR: Final[str] = ...
        BNTL: Final[str] = ...
        BQNKLS: Final[str] = ...
        BQNKTR: Final[str] = ...
        BQNKTL: Final[str] = ...
        BQPIP: Final[str] = ...
        GPCG: Final[str] = ...
        NM: Final[str] = ...
        POUNDERS: Final[str] = ...
        BRGN: Final[str] = ...
        LCL: Final[str] = ...
        SSILS: Final[str] = ...
        SSFLS: Final[str] = ...
        ASILS: Final[str] = ...
        ASFLS: Final[str] = ...
        IPM: Final[str] = ...
        PDIPM: Final[str] = ...
        SHELL: Final[str] = ...
        ADMM: Final[str] = ...
        ALMM: Final[str] = ...
        PYTHON: Final[str] = ...
    class ConvergedReason:
        CONTINUE_ITERATING: Final[int] = ...
        CONVERGED_ITERATING: Final[int] = ...
        ITERATING: Final[int] = ...
        CONVERGED_GATOL: Final[int] = ...
        CONVERGED_GRTOL: Final[int] = ...
        CONVERGED_GTTOL: Final[int] = ...
        CONVERGED_STEPTOL: Final[int] = ...
        CONVERGED_MINF: Final[int] = ...
        CONVERGED_USER: Final[int] = ...
        DIVERGED_MAXITS: Final[int] = ...
        DIVERGED_NAN: Final[int] = ...
        DIVERGED_MAXFCN: Final[int] = ...
        DIVERGED_LS_FAILURE: Final[int] = ...
        DIVERGED_TR_REDUCTION: Final[int] = ...
        DIVERGED_USER: Final[int] = ...
    class BNCGType:
        GD: Final[int] = ...
        PCGD: Final[int] = ...
        HS: Final[int] = ...
        FR: Final[int] = ...
        PRP: Final[int] = ...
        PRP_PLUS: Final[int] = ...
        DY: Final[int] = ...
        HZ: Final[int] = ...
        DK: Final[int] = ...
        KD: Final[int] = ...
        SSML_BFGS: Final[int] = ...
        SSML_DFP: Final[int] = ...
        SSML_BRDN: Final[int] = ...
    class ALMMType:
        CLASSIC: Final[int] = ...
        PHR: Final[int] = ...
    
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, tao_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def setInitialTrustRegionRadius(self, radius: float) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def getAppCtx(self) -> Any: ...
    def setSolution(self, x: Vec) -> None: ...
    def setObjective(self, objective: TAOObjectiveFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setResidual(self, residual: TAOResidualFunction, R: Vec, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setJacobianResidual(self, jacobian: TAOJacobianResidualFunction, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setGradient(self, gradient: TAOGradientFunction, g: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getObjective(self) -> TAOObjectiveFunction: ...
    def getGradient(self) -> tuple[Vec, TAOGradientFunction]: ...
    def setObjectiveGradient(self, objgrad: TAOObjectiveGradientFunction, g: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getObjectiveAndGradient(self) -> tuple[Vec, TAOObjectiveGradientFunction]: ...
    def setVariableBounds(self, varbounds: tuple[Vec, Vec] | TAOVariableBoundsFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setConstraints(self, constraints: TAOConstraintsFunction, C: Vec | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setHessian(self, hessian: TAOHessianFunction, H: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getHessian(self) -> tuple[Mat, Mat, TAOHessianFunction]: ...
    def setJacobian(self, jacobian: TAOJacobianFunction, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setStateDesignIS(self, state: IS | None = None, design: IS | None = None) -> None: ...
    def setJacobianState(self, jacobian_state, J: Mat | None = None, P: Mat | None = None, I: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setJacobianDesign(self, jacobian_design, J: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getLMVMMat(self) -> Mat: ...
    def setLMVMMat(self, M: Mat) -> None: ...
    def setEqualityConstraints(self, equality_constraints, c: Vec, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getEqualityConstraints(self) -> tuple[Vec, tuple[TAOConstraintsFunction, tuple[Any, ...] | None, dict[str, Any] | None]]: ...
    def setJacobianEquality(self, jacobian_equality, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getJacobianEquality(self) -> tuple[Mat, Mat, tuple[TAOConstraintsJacobianFunction, tuple[Any, ...] | None, dict[str, Any] | None]]: ...
    def setInequalityConstraints(self, inequality_constraints, c: Vec, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getInequalityConstraints(self) -> tuple[Vec, tuple[TAOConstraintsFunction, tuple[Any, ...] | None, dict[str, Any] | None]]: ...
    def setJacobianInequality(self, jacobian_inequality, J: Mat | None = None, P: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getJacobianInequality(self) -> tuple[Mat, Mat, tuple[TAOConstraintsJacobianFunction, tuple[Any, ...] | None, dict[str, Any] | None]]: ...
    def setUpdate(self, update: TAOUpdateFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getUpdate(self) -> tuple[TAOUpdateFunction, tuple[Any, ...], dict[str, Any]]: ...
    def computeObjective(self, x: Vec) -> float: ...
    def computeResidual(self, x: Vec, f: Vec) -> None: ...
    def computeGradient(self, x: Vec, g: Vec) -> None: ...
    def computeObjectiveGradient(self, x: Vec, g: Vec) -> float: ...
    def computeDualVariables(self, xl: Vec, xu: Vec) -> None: ...
    def computeVariableBounds(self, xl: Vec, xu: Vec) -> None: ...
    def computeConstraints(self, x: Vec, c: Vec) -> None: ...
    def computeHessian(self, x: Vec, H: Mat, P: Mat | None = None) -> None: ...
    def computeJacobian(self, x: Vec, J: Mat, P: Mat | None = None) -> None: ...
    def setTolerances(self, gatol: float | None = None, grtol: float | None = None, gttol: float | None = None) -> None: ...
    def getTolerances(self) -> tuple[float, float, float]: ...
    def setMaximumIterations(self, mit: int) -> float: ...
    def getMaximumIterations(self) -> int: ...
    def setMaximumFunctionEvaluations(self, mit: int) -> None: ...
    def getMaximumFunctionEvaluations(self) -> int: ...
    def setConstraintTolerances(self, catol: float | None = None, crtol: float | None = None) -> None: ...
    def getConstraintTolerances(self) -> tuple[float, float]: ...
    def setConvergenceTest(self, converged: TAOConvergedFunction | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getConvergenceTest(self) -> tuple[TAOConvergedFunction, tuple[Any, ...], dict[str, Any]]: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def setMonitor(self, monitor: TAOMonitorFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def getMonitor(self) -> list[tuple[TAOMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def cancelMonitor(self) -> None: ...
    def monitor(self, its: int | None = None, f: float | None = None, res: float | None = None, cnorm: float | None = None, step: float | None = None) -> None: ...
    def solve(self, x: Vec | None = None) -> None: ...
    def getSolution(self) -> Vec: ...
    def setGradientNorm(self, mat: Mat) -> None: ...
    def getGradientNorm(self) -> Mat: ...
    def setLMVMH0(self, mat: Mat) -> None: ...
    def getLMVMH0(self) -> Mat: ...
    def getLMVMH0KSP(self) -> KSP: ...
    def getVariableBounds(self) -> tuple[Vec, Vec]: ...
    def setBNCGType(self, cg_type: BNCGType) -> None: ...
    def getBNCGType(self) -> BNCGType: ...
    def setIterationNumber(self, its: int) -> None: ...
    def getIterationNumber(self) -> int: ...
    def getObjectiveValue(self) -> float: ...
    def getSolutionNorm(self) -> tuple[float, float, float]: ...
    def getSolutionStatus(self) -> tuple[int, float, float, float, float, ConvergedReason]: ...
    def checkConverged(self) -> ConvergedReason: ...
    def getKSP(self) -> KSP: ...
    def getALMMSubsolver(self) -> TAO: ...
    def getALMMType(self) -> ALMMType: ...
    def setALMMSubsolver(self, subsolver: TAO) -> None: ...
    def setALMMType(self, tao_almm_type: ALMMType) -> None: ...
    def getBRGNSubsolver(self) -> TAO: ...
    def setBRGNRegularizerObjectiveGradient(self, objgrad, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setBRGNRegularizerHessian(self, hessian, H: Mat | None = None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setBRGNRegularizerWeight(self, weight: float) -> None: ...
    def setBRGNSmoothL1Epsilon(self, epsilon: float) -> None: ...
    def setBRGNDictionaryMatrix(self, D: Mat) -> None: ...
    def getBRGNDampingVector(self) -> Vec: ...
    def createPython(self, context: Any = None, comm: Comm | None = None) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def getPythonContext(self) -> Any: ...
    def setPythonType(self, py_type: str) -> None: ...
    def getPythonType(self) -> str: ...
    def getLineSearch(self) -> TAOLineSearch: ...
    appctx: Any
    ksp: KSP
    ftol: Any
    gtol: Any
    ctol: Any
    its: int
    gnorm: float
    cnorm: float
    solution: Vec
    objective: float
    function: float
    gradient: Vec
    reason: ConvergedReason
    iterating: bool
    converged: bool
    diverged: bool
    getFunctionValue = getObjectiveValue
    setInitial = setSolution

class TAOLineSearch(Object):
    class Type:
        UNIT: Final[str] = ...
        ARMIJO: Final[str] = ...
        MORETHUENTE: Final[str] = ...
        IPM: Final[str] = ...
        OWARMIJO: Final[str] = ...
        GPCG: Final[str] = ...
    class ConvergedReason:
        CONTINUE_SEARCH: Final[int] = ...
        FAILED_INFORNAN: Final[int] = ...
        FAILED_BADPARAMETER: Final[int] = ...
        FAILED_ASCENT: Final[int] = ...
        SUCCESS: Final[int] = ...
        SUCCESS_USER: Final[int] = ...
        HALTED_OTHER: Final[int] = ...
        HALTED_MAXFCN: Final[int] = ...
        HALTED_UPPERBOUND: Final[int] = ...
        HALTED_LOWERBOUND: Final[int] = ...
        HALTED_RTOL: Final[int] = ...
        HALTED_USER: Final[int] = ...
    
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm=None) -> Self: ...
    def setType(self, ls_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def setOptionsPrefix(self, prefix: str | None = None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def setObjective(self, objective: TAOLSObjectiveFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setGradient(self, gradient: TAOLSGradientFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setObjectiveGradient(self, objgrad: TAOLSObjectiveGradientFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def useTAORoutine(self, tao: TAO) -> None: ...
    def apply(self, x: Vec, g: Vec, s: Vec) -> tuple[float, float, str]: ...
    def setInitialStepLength(self, s: float) -> None: ...

class AO(Object):
    class Type:
        BASIC: Final[str] = ...
        ADVANCED: Final[str] = ...
        MAPPING: Final[str] = ...
        MEMORYSCALABLE: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def createBasic(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = None, comm: Comm | None = None) -> Self: ...
    def createMemoryScalable(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = None, comm: Comm | None = None) -> Self: ...
    def createMapping(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = None, comm: Comm | None = None) -> Self: ...
    def getType(self) -> str: ...
    def app2petsc(self, indices: Sequence[int] | IS) -> Sequence[int] | IS: ...
    def petsc2app(self, indices: Sequence[int] | IS) -> Sequence[int] | IS: ...

class DM(Object):
    class Type:
        DA: Final[str] = ...
        COMPOSITE: Final[str] = ...
        SLICED: Final[str] = ...
        SHELL: Final[str] = ...
        PLEX: Final[str] = ...
        REDUNDANT: Final[str] = ...
        PATCH: Final[str] = ...
        MOAB: Final[str] = ...
        NETWORK: Final[str] = ...
        FOREST: Final[str] = ...
        P4EST: Final[str] = ...
        P8EST: Final[str] = ...
        SWARM: Final[str] = ...
        PRODUCT: Final[str] = ...
        STAG: Final[str] = ...
    class BoundaryType:
        NONE: Final[int] = ...
        GHOSTED: Final[int] = ...
        MIRROR: Final[int] = ...
        PERIODIC: Final[int] = ...
        TWIST: Final[int] = ...
    class PolytopeType:
        POINT: Final[int] = ...
        SEGMENT: Final[int] = ...
        POINT_PRISM_TENSOR: Final[int] = ...
        TRIANGLE: Final[int] = ...
        QUADRILATERAL: Final[int] = ...
        SEG_PRISM_TENSOR: Final[int] = ...
        TETRAHEDRON: Final[int] = ...
        HEXAHEDRON: Final[int] = ...
        TRI_PRISM: Final[int] = ...
        TRI_PRISM_TENSOR: Final[int] = ...
        QUAD_PRISM_TENSOR: Final[int] = ...
        PYRAMID: Final[int] = ...
        FV_GHOST: Final[int] = ...
        INTERIOR_GHOST: Final[int] = ...
        UNKNOWN: Final[int] = ...
        UNKNOWN_CELL: Final[int] = ...
        UNKNOWN_FACE: Final[int] = ...
    class ReorderDefaultFlag:
        NOTSET: Final[int] = ...
        FALSE: Final[int] = ...
        TRUE: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def load(self, viewer: Viewer) -> Self: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def clone(self) -> DM: ...
    def setType(self, dm_type: DM.Type | str) -> None: ...
    def getType(self) -> str: ...
    def getDimension(self) -> int: ...
    def setDimension(self, dim: int) -> None: ...
    def getCoordinateDim(self) -> int: ...
    def setCoordinateDim(self, dim: int) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def getOptionsPrefix(self) -> str: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def getAppCtx(self) -> Any: ...
    def getUseNatural(self) -> bool: ...
    def setUseNatural(self, useNatural: bool) -> None: ...
    def setBasicAdjacency(self, useCone: bool, useClosure: bool) -> None: ...
    def getBasicAdjacency(self) -> tuple[bool, bool]: ...
    def setFieldAdjacency(self, field: int, useCone: bool, useClosure: bool) -> None: ...
    def getFieldAdjacency(self, field: int) -> tuple[bool, bool]: ...
    def createSubDM(self, fields: Sequence[int]) -> tuple[IS, DM]: ...
    def setAuxiliaryVec(self, aux: Vec, label: DMLabel | None, value=0, part=0) -> None: ...
    def getAuxiliaryVec(self, label: str | None = None, value: int | None = 0, part: int | None = 0) -> Vec: ...
    def setNumFields(self, numFields: int) -> None: ...
    def getNumFields(self) -> int: ...
    def setField(self, index: int, field: Object, label: str | None = None) -> None: ...
    def getField(self, index: int) -> tuple[Object, None]: ...
    def addField(self, field: Object, label: str | None = None) -> None: ...
    def clearFields(self) -> None: ...
    def copyFields(self, dm: DM, minDegree=None, maxDegree=None) -> None: ...
    def createDS(self) -> None: ...
    def clearDS(self) -> None: ...
    def getDS(self) -> DS: ...
    def copyDS(self, dm: DM, minDegree=None, maxDegree=None) -> None: ...
    def copyDisc(self, dm: DM) -> None: ...
    def getBlockSize(self) -> int: ...
    def setVecType(self, vec_type: Vec.Type | str) -> None: ...
    def createGlobalVec(self) -> Vec: ...
    def createLocalVec(self) -> Vec: ...
    def getGlobalVec(self, name: str | None = None) -> Vec: ...
    def restoreGlobalVec(self, vg: Vec, name: str | None = None) -> None: ...
    def getLocalVec(self, name: str | None = None) -> Vec: ...
    def restoreLocalVec(self, vl: Vec, name: str | None = None) -> None: ...
    def globalToLocal(self, vg: Vec, vl: Vec, addv: InsertModeSpec | None = None) -> None: ...
    def localToGlobal(self, vl: Vec, vg: Vec, addv: InsertModeSpec | None = None) -> None: ...
    def localToLocal(self, vl: Vec, vlg: Vec, addv: InsertModeSpec | None = None) -> None: ...
    def getLGMap(self) -> LGMap: ...
    def getCoarseDM(self) -> DM: ...
    def setCoarseDM(self, dm: DM) -> None: ...
    def getCoordinateDM(self) -> DM: ...
    def getCoordinateSection(self) -> Section: ...
    def setCoordinates(self, c: Vec) -> None: ...
    def getCoordinates(self) -> Vec: ...
    def setCoordinatesLocal(self, c: Vec) -> None: ...
    def getCoordinatesLocal(self) -> Vec: ...
    def setCellCoordinateDM(self, dm: DM) -> None: ...
    def getCellCoordinateDM(self) -> DM: ...
    def setCellCoordinateSection(self, dim: int, sec: Section) -> None: ...
    def getCellCoordinateSection(self) -> Section: ...
    def setCellCoordinates(self, c: Vec) -> None: ...
    def getCellCoordinates(self) -> Vec: ...
    def setCellCoordinatesLocal(self, c: Vec) -> None: ...
    def getCellCoordinatesLocal(self) -> Vec: ...
    def setCoordinateDisc(self, disc: FE, localized: bool, project: bool) -> Self: ...
    def getCoordinatesLocalized(self) -> bool: ...
    def getBoundingBox(self) -> tuple[tuple[float, float], ...]: ...
    def getLocalBoundingBox(self) -> tuple[tuple[float, float], ...]: ...
    def localizeCoordinates(self) -> None: ...
    def getPeriodicity(self) -> tuple[ArrayReal, ArrayReal, ArrayReal]: ...
    def setPeriodicity(self, maxCell: Sequence[float], Lstart: Sequence[float], L: Sequence[float]) -> None: ...
    def setMatType(self, mat_type: Mat.Type | str) -> None: ...
    def createMat(self) -> Mat: ...
    def createMassMatrix(self, dmf: DM) -> Mat: ...
    def createInterpolation(self, dm: DM) -> tuple[Mat, Vec]: ...
    def createInjection(self, dm: DM) -> Mat: ...
    def createRestriction(self, dm: DM) -> Mat: ...
    def convert(self, dm_type: DM.Type | str) -> DM: ...
    def refine(self, comm: Comm | None = None) -> DM: ...
    def coarsen(self, comm: Comm | None = None) -> DM: ...
    def refineHierarchy(self, nlevels: int) -> list: ...
    def coarsenHierarchy(self, nlevels: int) -> list: ...
    def getRefineLevel(self) -> int: ...
    def setRefineLevel(self, level: int) -> None: ...
    def getCoarsenLevel(self) -> int: ...
    def adaptLabel(self, label: str) -> DM: ...
    def adaptMetric(self, metric: Vec, bdLabel: str | None = None, rgLabel: str | None = None) -> DM: ...
    def getLabel(self, name: str) -> DMLabel: ...
    def setLocalSection(self, sec: Section) -> None: ...
    def getLocalSection(self) -> Section: ...
    def setGlobalSection(self, sec: Section) -> None: ...
    def getGlobalSection(self) -> Section: ...
    def createSectionSF(self, localsec: Section, globalsec: Section) -> None: ...
    def getSectionSF(self) -> SF: ...
    def setSectionSF(self, sf: SF) -> None: ...
    def getPointSF(self) -> SF: ...
    def setPointSF(self, sf: SF) -> None: ...
    def getNumLabels(self) -> int: ...
    def getLabelName(self, index: int) -> str: ...
    def hasLabel(self, name: str) -> bool: ...
    def createLabel(self, name: str) -> None: ...
    def removeLabel(self, name: str) -> None: ...
    def getLabelValue(self, name: str, point: int) -> int: ...
    def setLabelValue(self, name: str, point: int, value: int) -> None: ...
    def clearLabelValue(self, name: str, point: int, value: int) -> None: ...
    def getLabelSize(self, name: str) -> int: ...
    def getLabelIdIS(self, name: str) -> IS: ...
    def getStratumSize(self, name: str, value: int) -> int: ...
    def getStratumIS(self, name: str, value: int) -> IS: ...
    def clearLabelStratum(self, name: str, value: int) -> None: ...
    def setLabelOutput(self, name: str, output: bool) -> None: ...
    def getLabelOutput(self, name: str) -> bool: ...
    def setKSPComputeOperators(self, operators, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def createFieldDecomposition(self) -> tuple[list, list, list]: ...
    def setSNESFunction(self, function: SNESFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setSNESJacobian(self, jacobian: SNESJacobianFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def addCoarsenHook(self, coarsenhook: DMCoarsenHookFunction, restricthook: DMRestrictHookFunction, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    appctx: object
    ds: DS
    setSection = setLocalSection
    getSection = getLocalSection
    setDefaultSection = setLocalSection
    getDefaultSection = getLocalSection
    setDefaultLocalSection = setLocalSection
    getDefaultLocalSection = getLocalSection
    setDefaultGlobalSection = setGlobalSection
    getDefaultGlobalSection = getGlobalSection
    createDefaultSF = createSectionSF
    getDefaultSF = getSectionSF
    setDefaultSF = setSectionSF
    createGlobalVector = createGlobalVec
    createLocalVector = createLocalVec
    getMatrix = createMat
    createMatrix = createMat

class DMPlexTransform(Object):
    def apply(self, dm: DM) -> DM: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def destroy(self) -> Self: ...
    def getType(self) -> str: ...
    def setUp(self) -> Self: ...
    def setType(self, tr_type: DMPlexTransformType | str) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setFromOptions(self) -> None: ...
    def view(self, viewer: Viewer | None = None) -> None: ...

class CellDM(Object):
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, dm: DM, fields: Sequence[str], coords: Sequence[str]) -> Self: ...
    def getDM(self) -> DM: ...
    def getCellID(self) -> str: ...
    def getBlockSize(self, sw: DM) -> int: ...
    def getFields(self) -> list[str]: ...
    def getCoordinateFields(self) -> list[str]: ...

class DS(Object):
    class Type:
        BASIC: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, ds_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> Self: ...
    def getSpatialDimension(self) -> int: ...
    def getCoordinateDimension(self) -> int: ...
    def getNumFields(self) -> int: ...
    def getFieldIndex(self, disc: Object) -> int: ...
    def getTotalDimensions(self) -> int: ...
    def getTotalComponents(self) -> int: ...
    def getDimensions(self) -> ArrayInt: ...
    def getComponents(self) -> ArrayInt: ...
    def setDiscretisation(self, f: int, disc: Object) -> None: ...

class Partitioner(Object):
    class Type:
        PARMETIS: Final[str] = ...
        PTSCOTCH: Final[str] = ...
        CHACO: Final[str] = ...
        SIMPLE: Final[str] = ...
        SHELL: Final[str] = ...
        GATHER: Final[str] = ...
        MATPARTITIONING: Final[str] = ...
        MULTISTAGE: Final[str] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def destroy(self) -> Self: ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def setType(self, part_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def reset(self) -> None: ...
    def setShellPartition(self, numProcs: int, sizes: Sequence[int] | None = None, points: Sequence[int] | None = None) -> None: ...

class DMLabel(Object):
    def destroy(self) -> Self: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def create(self, name: str, comm: Comm | None = None) -> Self: ...
    def duplicate(self) -> DMLabel: ...
    def reset(self) -> None: ...
    def insertIS(self, iset: IS, value: int) -> Self: ...
    def setValue(self, point: int, value: int) -> None: ...
    def getValue(self, point: int) -> int: ...
    def getDefaultValue(self) -> int: ...
    def setDefaultValue(self, value: int) -> None: ...
    def clearValue(self, point: int, value: int) -> None: ...
    def addStratum(self, value: int) -> None: ...
    def addStrata(self, strata: Sequence[int]) -> None: ...
    def addStrataIS(self, iset: IS) -> None: ...
    def getNumValues(self) -> int: ...
    def getValueIS(self) -> IS: ...
    def stratumHasPoint(self, value: int, point: int) -> bool: ...
    def hasStratum(self, value: int) -> bool: ...
    def getStratumSize(self, stratum: int) -> int: ...
    def getStratumIS(self, stratum: int) -> IS: ...
    def setStratumIS(self, stratum: int, iset: IS) -> None: ...
    def clearStratum(self, stratum: int) -> None: ...
    def computeIndex(self) -> None: ...
    def createIndex(self, pStart: int, pEnd: int) -> None: ...
    def destroyIndex(self) -> None: ...
    def hasValue(self, value: int) -> bool: ...
    def hasPoint(self, point: int) -> bool: ...
    def getBounds(self) -> tuple[int, int]: ...
    def filter(self, start: int, end: int) -> None: ...
    def permute(self, permutation: IS) -> DMLabel: ...
    def distribute(self, sf: SF) -> DMLabel: ...
    def gather(self, sf: SF) -> DMLabel: ...
    def convertToSection(self) -> tuple[Section, IS]: ...
    def getNonEmptyStratumValuesIS(self) -> IS: ...

class Regressor(Object):
    class Type:
        LINEAR: Final[str] = ...
    class LinearType:
        OLS: Final[int] = ...
        LASSO: Final[int] = ...
        RIDGE: Final[int] = ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def create(self, comm=None) -> Self: ...
    def setRegularizerWeight(self, weight: float) -> None: ...
    def setFromOptions(self) -> None: ...
    def setUp(self) -> None: ...
    def fit(self, X: Mat, y: Vec) -> None: ...
    def predict(self, X: Mat, y: Vec) -> None: ...
    def getTAO(self) -> TAO: ...
    def reset(self) -> None: ...
    def destroy(self) -> Self: ...
    def setType(self, regressor_type: Type | str) -> None: ...
    def getType(self) -> str: ...
    def setLinearFitIntercept(self, flag: bool) -> None: ...
    def setLinearUseKSP(self, flag: bool) -> None: ...
    def getLinearKSP(self) -> KSP: ...
    def getLinearCoefficients(self) -> Vec: ...
    def getLinearIntercept(self) -> Scalar: ...
    def setLinearType(self, lineartype: RegressorLinearType) -> None: ...
    def getLinearType(self) -> RegressorLinearType: ...

class Options:
    def __init__(self, prefix: str | None = None) -> None: ...
    def create(self) -> Self: ...
    def destroy(self) -> Self: ...
    def clear(self) -> Self: ...
    def view(self, viewer: Viewer | None = None) -> None: ...
    def prefixPush(self, prefix: str | Options | Object | None) -> None: ...
    def prefixPop(self) -> None: ...
    def hasName(self, name: str) -> bool: ...
    def used(self, name: str) -> bool: ...
    def setValue(self, name: str, value: bool | int | float | Scalar | Sequence[bool] | Sequence[int] | Sequence[float] | Sequence[Scalar] | str) -> None: ...
    def delValue(self, name: str) -> None: ...
    def getBool(self, name: str, default=None) -> bool: ...
    def getBoolArray(self, name: str, default=None) -> ArrayBool: ...
    def getInt(self, name: str, default=None) -> int: ...
    def getIntArray(self, name: str, default=None) -> ArrayInt: ...
    def getReal(self, name: str, default=None) -> float: ...
    def getRealArray(self, name: str, default=None) -> ArrayReal: ...
    def getScalar(self, name: str, default=None) -> Scalar: ...
    def getScalarArray(self, name: str, default=None) -> ArrayScalar: ...
    def getString(self, name: str, default=None) -> str: ...
    def insertString(self, string: str) -> None: ...
    def getAll(self) -> dict[str, str]: ...
    prefix: str

class Sys:
    @classmethod
    def getVersion(cls, devel: bool = False, date: bool = False, author: bool = False) -> tuple[int, int, int]: ...
    @classmethod
    def getVersionInfo(cls) -> dict[str, bool | int | str]: ...
    @classmethod
    def isInitialized(cls) -> bool: ...
    @classmethod
    def isFinalized(cls) -> bool: ...
    @classmethod
    def getDefaultComm(cls) -> Comm: ...
    @classmethod
    def setDefaultComm(cls, comm: Comm | None) -> None: ...
    @classmethod
    def Print(cls, *args: Any, sep: str = ' ', end: str = '\n', comm: Comm | None = None, **kwargs: Any) -> None: ...
    @classmethod
    def syncPrint(cls, *args: Any, sep: str = ' ', end: str = '\n', flush: bool = False, comm: Comm | None = None, **kwargs: Any) -> None: ...
    @classmethod
    def syncFlush(cls, comm: Comm | None = None) -> None: ...
    @classmethod
    def splitOwnership(cls, size: int | tuple[int, int], bsize: int | None = None, comm: Comm | None = None) -> tuple[int, int]: ...
    @classmethod
    def sleep(cls, seconds: float = 1.0) -> None: ...
    @classmethod
    def pushErrorHandler(cls, errhandler: str) -> None: ...
    @classmethod
    def popErrorHandler(cls) -> None: ...
    @classmethod
    def popSignalHandler(cls) -> None: ...
    @classmethod
    def infoAllow(cls, flag: bool, filename: str | None = None, mode: str = 'w') -> None: ...
    @classmethod
    def registerCitation(cls, citation: str) -> None: ...
    @classmethod
    def hasExternalPackage(cls, package: str) -> bool: ...

class Log:
    @classmethod
    def Stage(cls, name: str) -> LogStage: ...
    @classmethod
    def Class(cls, name: str) -> LogClass: ...
    @classmethod
    def Event(cls, name: str, klass: LogClass | None = None) -> LogEvent: ...
    @classmethod
    def begin(cls) -> None: ...
    @classmethod
    def view(cls, viewer: Viewer | None = None) -> None: ...
    @classmethod
    def logFlops(cls, flops: float) -> None: ...
    @classmethod
    def addFlops(cls, flops: float) -> None: ...
    @classmethod
    def getFlops(cls) -> float: ...
    @classmethod
    def getTime(cls) -> float: ...
    @classmethod
    def getCPUTime(cls) -> float: ...
    @classmethod
    def EventDecorator(cls, name=None, klass=None) -> Any: ...
    @classmethod
    def isActive(cls) -> bool: ...

class LogStage:
    def __int__(self) -> int: ...
    def push(self) -> None: ...
    def pop(self) -> None: ...
    def getName(self) -> str: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def getActive(self) -> bool: ...
    def setActive(self, flag: bool) -> None: ...
    def getVisible(self) -> bool: ...
    def setVisible(self, flag: bool) -> None: ...
    id: int
    name: str
    active: bool
    visible: bool

class LogClass:
    def __int__(self) -> int: ...
    def getName(self) -> str: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def getActive(self) -> bool: ...
    def setActive(self, flag: bool) -> None: ...
    id: int
    name: str
    active: bool

class LogEvent:
    def __int__(self) -> int: ...
    def begin(self, *objs) -> None: ...
    def end(self, *objs) -> None: ...
    def getName(self) -> str: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def getActive(self) -> bool: ...
    def setActive(self, flag: bool) -> None: ...
    def getActiveAll(self) -> bool: ...
    def setActiveAll(self, flag: bool) -> None: ...
    def getPerfInfo(self, stage: int | None = None) -> dict: ...
    id: int
    name: str
    active: bool
    active_all: bool

class ViewerHDF5(Viewer):
    def create(self, name: str, mode: Viewer.FileMode | str | None = None, comm: Comm | None = None) -> Self: ... # type: ignore[override]
    def pushTimestepping(self) -> None: ...
    def popTimestepping(self) -> None: ...
    def getTimestep(self) -> int: ...
    def setTimestep(self, timestep: int) -> None: ...
    def incrementTimestep(self) -> None: ...
    def pushGroup(self, group: str) -> None: ...
    def popGroup(self) -> None: ...
    def getGroup(self) -> str: ...

class DMDA(DM):
    class StencilType:
        STAR: Final[int] = ...
        BOX: Final[int] = ...
    class InterpolationType:
        Q0: Final[int] = ...
        Q1: Final[int] = ...
    class ElementType:
        P1: Final[int] = ...
        Q1: Final[int] = ...
    def create(self, dim: int | None = None, dof: int | None = None, sizes: DimsSpec | None = None, proc_sizes: DimsSpec | None = None, boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = None, stencil_type: StencilType | None = None, stencil_width: int | None = None, setup: bool = True, ownership_ranges: tuple[Sequence[int], ...] | None = None, comm: Comm | None = None) -> Self: ... # type: ignore[override]
    def duplicate(self, dof: int | None = None, boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = None, stencil_type: StencilType | None = None, stencil_width: int | None = None) -> DMDA: ...
    def setDim(self, dim: int) -> None: ...
    def getDim(self) -> int: ...
    def setDof(self, dof: int) -> None: ...
    def getDof(self) -> int: ...
    def setSizes(self, sizes: DimsSpec) -> None: ...
    def getSizes(self) -> tuple[int, ...]: ...
    def setProcSizes(self, proc_sizes: DimsSpec) -> None: ...
    def getProcSizes(self) -> tuple[int, ...]: ...
    def setBoundaryType(self, boundary_type: tuple[DM.BoundaryType | int | str | bool, ...]) -> None: ...
    def getBoundaryType(self) -> tuple[DM.BoundaryType, ...]: ...
    def setStencilType(self, stencil_type: StencilType) -> None: ...
    def getStencilType(self) -> StencilType: ...
    def setStencilWidth(self, stencil_width: int) -> None: ...
    def getStencilWidth(self) -> int: ...
    def setStencil(self, stencil_type: StencilType, stencil_width: int) -> None: ...
    def getStencil(self) -> tuple[StencilType, int]: ...
    def getRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getGhostRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getOwnershipRanges(self) -> tuple[ArrayInt, ...]: ...
    def getCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getGhostCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def setFieldName(self, field: int, name: str) -> None: ...
    def getFieldName(self, field: int) -> str: ...
    def getVecArray(self, vec: Vec, readonly: bool = False) -> Any: ...
    def setUniformCoordinates(self, xmin: float = 0, xmax: float = 1, ymin: float = 0, ymax: float = 1, zmin: float = 0, zmax: float = 1) -> None: ...
    def setCoordinateName(self, index: int, name: str) -> None: ...
    def getCoordinateName(self, index: int) -> str: ...
    def createNaturalVec(self) -> Vec: ...
    def globalToNatural(self, vg: Vec, vn: Vec, addv: InsertMode | None = None) -> None: ...
    def naturalToGlobal(self, vn: Vec, vg: Vec, addv: InsertMode | None = None) -> None: ...
    def getAO(self) -> AO: ...
    def getScatter(self) -> tuple[Scatter, Scatter]: ...
    def setRefinementFactor(self, refine_x: int = 2, refine_y: int = 2, refine_z: int = 2) -> None: ...
    def getRefinementFactor(self) -> tuple[int, ...]: ...
    def setInterpolationType(self, interp_type: InterpolationType) -> None: ...
    def getInterpolationType(self) -> InterpolationType: ...
    def setElementType(self, elem_type: ElementType | str) -> None: ...
    def getElementType(self) -> ElementType: ...
    def getElements(self, elem_type: ElementType | None = None) -> ArrayInt: ...
    dim: int
    dof: int
    sizes: tuple[int, ...]
    proc_sizes: tuple[int, ...]
    boundary_type: tuple[DM.BoundaryType, ...]
    stencil: tuple[StencilType, int]
    stencil_type: str
    stencil_width: int
    ranges: tuple[tuple[int, int], ...]
    ghost_ranges: tuple[tuple[int, int], ...]
    corners: tuple[tuple[int, ...], tuple[int, ...]]
    ghost_corners: tuple[tuple[int, ...], tuple[int, ...]]
    createNaturalVector = createNaturalVec

class DMPlex(DM):
    def create(self, comm: Comm | None = None) -> Self: ...
    def createFromCellList(self, dim: int, cells: Sequence[int], coords: Sequence[float], interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createBoxMesh(self, faces: Sequence[int], lower: Sequence[float] | None = (0, 0, 0), upper: Sequence[float] | None = (1, 1, 1), simplex: bool | None = True, periodic: Sequence | str | int | bool | None = False, interpolate: bool | None = True, localizationHeight: int | None = 0, sparseLocalize: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createBoxSurfaceMesh(self, faces: Sequence[int], lower: Sequence[float] | None = (0, 0, 0), upper: Sequence[float] | None = (1, 1, 1), interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createFromFile(self, filename: str, plexname: str | None = 'unnamed', interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createCGNS(self, cgid: int, interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createCGNSFromFile(self, filename: str, interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createExodusFromFile(self, filename: str, interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createExodus(self, exoid: int, interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createGmsh(self, viewer: Viewer, interpolate: bool | None = True, comm: Comm | None = None) -> Self: ...
    def createCoordinateSpace(self, degree: int, localized: bool, project: bool) -> None: ...
    def createCohesiveSubmesh(self, hasLagrange: bool, value: int) -> DMPlex: ...
    def filter(self, label: DMLabel | None = None, value: int | None = None, ignoreHalo: bool = False, sanitizeSubMesh: bool = False, comm: Comm | None = None) -> tuple[DMPlex, SF]: ...
    def getChart(self) -> tuple[int, int]: ...
    def setChart(self, pStart: int, pEnd: int) -> None: ...
    def getConeSize(self, p: int) -> int: ...
    def setConeSize(self, p: int, size: int) -> None: ...
    def getCone(self, p: int) -> ArrayInt: ...
    def setCone(self, p: int, cone: Sequence[int], orientation: Sequence[int] | None = None) -> None: ...
    def insertCone(self, p: int, conePos: int, conePoint: int) -> None: ...
    def insertConeOrientation(self, p: int, conePos: int, coneOrientation: int) -> None: ...
    def getConeOrientation(self, p: int) -> ArrayInt: ...
    def setConeOrientation(self, p: int, orientation: Sequence[int]) -> None: ...
    def setCellType(self, p: int, ctype: DM.PolytopeType) -> None: ...
    def getCellType(self, p: int) -> DM.PolytopeType: ...
    def getCellTypeLabel(self) -> DMLabel: ...
    def getSupportSize(self, p: int) -> int: ...
    def setSupportSize(self, p: int, size: int) -> None: ...
    def getSupport(self, p: int) -> ArrayInt: ...
    def setSupport(self, p: int, supp: Sequence[int]) -> None: ...
    def getMaxSizes(self) -> tuple[int, int]: ...
    def symmetrize(self) -> None: ...
    def stratify(self) -> None: ...
    def orient(self) -> None: ...
    def getCellNumbering(self) -> IS: ...
    def getVertexNumbering(self) -> IS: ...
    def createPointNumbering(self) -> IS: ...
    def getDepth(self) -> int: ...
    def getDepthStratum(self, svalue: int) -> tuple[int, int]: ...
    def getHeightStratum(self, svalue: int) -> tuple[int, int]: ...
    def getPointDepth(self, point: int) -> int: ...
    def getPointHeight(self, point: int) -> int: ...
    def getMeet(self, points: Sequence[int]) -> ArrayInt: ...
    def getJoin(self, points: Sequence[int]) -> ArrayInt: ...
    def getFullJoin(self, points: Sequence[int]) -> ArrayInt: ...
    def getTransitiveClosure(self, p: int, useCone: bool | None = True) -> tuple[ArrayInt, ArrayInt]: ...
    def vecGetClosure(self, sec: Section, vec: Vec, p: int) -> ArrayScalar: ...
    def getVecClosure(self, sec: Section, vec: Vec, point: int) -> ArrayScalar: ...
    def setVecClosure(self, sec: Section, vec: Vec, point: int, values: Sequence[Scalar], addv: InsertModeSpec | None = None) -> None: ...
    def setMatClosure(self, sec: Section, gsec: Section, mat: Mat, point: int, values: Sequence[Scalar], addv: InsertModeSpec | None = None) -> None: ...
    def generate(self, boundary: DMPlex, name: str | None = None, interpolate: bool | None = True) -> Self: ...
    def setTriangleOptions(self, opts: str) -> None: ...
    def setTetGenOptions(self, opts: str) -> None: ...
    def markBoundaryFaces(self, label: str, value: int | None = None) -> DMLabel: ...
    def labelComplete(self, label: DMLabel) -> None: ...
    def labelCohesiveComplete(self, label: DMLabel, bdlabel: DMLabel, bdvalue: int, flip: bool, split: bool, subdm: DMPlex) -> None: ...
    def setAdjacencyUseAnchors(self, useAnchors: bool = True) -> None: ...
    def getAdjacencyUseAnchors(self) -> bool: ...
    def getAdjacency(self, p: int) -> ArrayInt: ...
    def setPartitioner(self, part: Partitioner) -> None: ...
    def getPartitioner(self) -> Partitioner: ...
    def rebalanceSharedPoints(self, entityDepth: int | None = 0, useInitialGuess: bool | None = True, parallel: bool | None = True) -> bool: ...
    def distribute(self, overlap: int | None = 0) -> SF | None: ...
    def distributeOverlap(self, overlap: int | None = 0) -> SF: ...
    def isDistributed(self) -> bool: ...
    def isSimplex(self) -> bool: ...
    def distributeGetDefault(self) -> bool: ...
    def distributeSetDefault(self, flag: bool) -> None: ...
    def distributionSetName(self, name: str) -> None: ...
    def distributionGetName(self) -> str: ...
    def interpolate(self) -> None: ...
    def uninterpolate(self) -> None: ...
    def distributeField(self, sf: SF, sec: Section, vec: Vec, newsec: Section | None = None, newvec: Vec | None = None) -> tuple[Section, Vec]: ...
    def getMinRadius(self) -> float: ...
    def createCoarsePointIS(self) -> IS: ...
    def createSection(self, numComp: Sequence[int], numDof: Sequence[int], bcField: Sequence[int] | None = None, bcComps: Sequence[IS] | None = None, bcPoints: Sequence[IS] | None = None, perm: IS | None = None) -> Section: ...
    def getPointLocal(self, point: int) -> tuple[int, int]: ...
    def getPointLocalField(self, point: int, field: int) -> tuple[int, int]: ...
    def getPointGlobal(self, point: int) -> tuple[int, int]: ...
    def getPointGlobalField(self, point: int, field: int) -> tuple[int, int]: ...
    def createClosureIndex(self, sec: Section) -> None: ...
    def setRefinementUniform(self, refinementUniform: bool | None = True) -> None: ...
    def getRefinementUniform(self) -> bool: ...
    def setRefinementLimit(self, refinementLimit: float) -> None: ...
    def getRefinementLimit(self) -> float: ...
    def getOrdering(self, otype: Mat.OrderingType) -> IS: ...
    def permute(self, perm: IS) -> DMPlex: ...
    def reorderGetDefault(self) -> DM.ReorderDefaultFlag: ...
    def reorderSetDefault(self, flag: DM.ReorderDefaultFlag) -> None: ...
    def computeCellGeometryFVM(self, cell: int) -> tuple[float, ArrayReal, ArrayReal]: ...
    def constructGhostCells(self, labelName: str | None = None) -> int: ...
    def getSubpointIS(self) -> IS: ...
    def getSubpointMap(self) -> DMLabel: ...
    def metricSetFromOptions(self) -> None: ...
    def metricSetUniform(self, uniform: bool) -> None: ...
    def metricIsUniform(self) -> bool: ...
    def metricSetIsotropic(self, isotropic: bool) -> None: ...
    def metricIsIsotropic(self) -> bool: ...
    def metricSetRestrictAnisotropyFirst(self, restrictAnisotropyFirst: bool) -> None: ...
    def metricRestrictAnisotropyFirst(self) -> bool: ...
    def metricSetNoInsertion(self, noInsert: bool) -> None: ...
    def metricNoInsertion(self) -> bool: ...
    def metricSetNoSwapping(self, noSwap: bool) -> None: ...
    def metricNoSwapping(self) -> bool: ...
    def metricSetNoMovement(self, noMove: bool) -> None: ...
    def metricNoMovement(self) -> bool: ...
    def metricSetNoSurf(self, noSurf: bool) -> None: ...
    def metricNoSurf(self) -> bool: ...
    def metricSetVerbosity(self, verbosity: int) -> None: ...
    def metricGetVerbosity(self) -> int: ...
    def metricSetNumIterations(self, numIter: int) -> None: ...
    def metricGetNumIterations(self) -> int: ...
    def metricSetMinimumMagnitude(self, h_min: float) -> None: ...
    def metricGetMinimumMagnitude(self) -> float: ...
    def metricSetMaximumMagnitude(self, h_max: float) -> None: ...
    def metricGetMaximumMagnitude(self) -> float: ...
    def metricSetMaximumAnisotropy(self, a_max: float) -> None: ...
    def metricGetMaximumAnisotropy(self) -> float: ...
    def metricSetTargetComplexity(self, targetComplexity: float) -> None: ...
    def metricGetTargetComplexity(self) -> float: ...
    def metricSetNormalizationOrder(self, p: float) -> None: ...
    def metricGetNormalizationOrder(self) -> float: ...
    def metricSetGradationFactor(self, beta: float) -> None: ...
    def metricGetGradationFactor(self) -> float: ...
    def metricSetHausdorffNumber(self, hausd: float) -> None: ...
    def metricGetHausdorffNumber(self) -> float: ...
    def metricCreate(self, field: int | None = 0) -> Vec: ...
    def metricCreateUniform(self, alpha: float, field: int | None = 0) -> Vec: ...
    def metricCreateIsotropic(self, indicator: Vec, field: int | None = 0) -> Vec: ...
    def metricDeterminantCreate(self, field: int | None = 0) -> tuple[Vec, DM]: ...
    def metricEnforceSPD(self, metric: Vec, ometric: Vec, determinant: Vec, restrictSizes: bool | None = False, restrictAnisotropy: bool | None = False) -> tuple[Vec, Vec]: ...
    def metricNormalize(self, metric: Vec, ometric: Vec, determinant: Vec, restrictSizes: bool | None = True, restrictAnisotropy: bool | None = True) -> tuple[Vec, Vec]: ...
    def metricAverage2(self, metric1: Vec, metric2: Vec, metricAvg: Vec) -> Vec: ...
    def metricAverage3(self, metric1: Vec, metric2: Vec, metric3: Vec, metricAvg: Vec) -> Vec: ...
    def metricIntersection2(self, metric1: Vec, metric2: Vec, metricInt: Vec) -> Vec: ...
    def metricIntersection3(self, metric1: Vec, metric2: Vec, metric3: Vec, metricInt: Vec) -> Vec: ...
    def computeGradientClementInterpolant(self, locX: Vec, locC: Vec) -> Vec: ...
    def topologyView(self, viewer: Viewer) -> None: ...
    def coordinatesView(self, viewer: Viewer) -> None: ...
    def labelsView(self, viewer: Viewer) -> None: ...
    def sectionView(self, viewer: Viewer, sectiondm: DM) -> None: ...
    def globalVectorView(self, viewer: Viewer, sectiondm: DM, vec: Vec) -> None: ...
    def localVectorView(self, viewer: Viewer, sectiondm: DM, vec: Vec) -> None: ...
    def topologyLoad(self, viewer: Viewer) -> SF: ...
    def coordinatesLoad(self, viewer: Viewer, sfxc: SF) -> None: ...
    def labelsLoad(self, viewer: Viewer, sfxc: SF) -> None: ...
    def sectionLoad(self, viewer: Viewer, sectiondm: DM, sfxc: SF) -> tuple[SF, SF]: ...
    def globalVectorLoad(self, viewer: Viewer, sectiondm: DM, sf: SF, vec: Vec) -> None: ...
    def localVectorLoad(self, viewer: Viewer, sectiondm: DM, sf: SF, vec: Vec) -> None: ...
    def createNaturalVec(self) -> Vec: ...
    def naturalToGlobalBegin(self, nv: Vec, gv: Vec) -> None: ...
    def naturalToGlobalEnd(self, nv: Vec, gv: Vec) -> None: ...
    def globalToNaturalBegin(self, gv: Vec, nv: Vec) -> None: ...
    def globalToNaturalEnd(self, gv: Vec, nv: Vec) -> None: ...
    def setMigrationSF(self, sf: SF) -> None: ...
    def getMigrationSF(self) -> SF: ...
    def createGlobalToNaturalSF(self, section: Section, sfMigration: SF) -> SF: ...
    def migrateGlobalToNaturalSF(self, dmOld: DM, sfNaturalOld: SF, sfMigration: SF) -> SF: ...

class DMStag(DM):
    class StencilType:
        STAR: Final[int] = ...
        BOX: Final[int] = ...
        NONE: Final[int] = ...
    class StencilLocation:
        NULLLOC: Final[int] = ...
        BACK_DOWN_LEFT: Final[int] = ...
        BACK_DOWN: Final[int] = ...
        BACK_DOWN_RIGHT: Final[int] = ...
        BACK_LEFT: Final[int] = ...
        BACK: Final[int] = ...
        BACK_RIGHT: Final[int] = ...
        BACK_UP_LEFT: Final[int] = ...
        BACK_UP: Final[int] = ...
        BACK_UP_RIGHT: Final[int] = ...
        DOWN_LEFT: Final[int] = ...
        DOWN: Final[int] = ...
        DOWN_RIGHT: Final[int] = ...
        LEFT: Final[int] = ...
        ELEMENT: Final[int] = ...
        RIGHT: Final[int] = ...
        UP_LEFT: Final[int] = ...
        UP: Final[int] = ...
        UP_RIGHT: Final[int] = ...
        FRONT_DOWN_LEFT: Final[int] = ...
        FRONT_DOWN: Final[int] = ...
        FRONT_DOWN_RIGHT: Final[int] = ...
        FRONT_LEFT: Final[int] = ...
        FRONT: Final[int] = ...
        FRONT_RIGHT: Final[int] = ...
        FRONT_UP_LEFT: Final[int] = ...
        FRONT_UP: Final[int] = ...
        FRONT_UP_RIGHT: Final[int] = ...
    def create(self, dim: int, dofs: tuple[int, ...] | None = None, sizes: tuple[int, ...] | None = None, boundary_types: tuple[DM.BoundaryType | int | str | bool, ...] | None = None, stencil_type: StencilType | None = None, stencil_width: int | None = None, proc_sizes: tuple[int, ...] | None = None, ownership_ranges: tuple[Sequence[int], ...] | None = None, comm: Comm | None = None, setUp: bool | None = False) -> Self: ... # type: ignore[override]
    def setStencilWidth(self, swidth: int) -> None: ...
    def setStencilType(self, stenciltype: StencilType | str) -> None: ...
    def setBoundaryTypes(self, boundary_types: tuple[DM.BoundaryType | int | str | bool, ...]) -> None: ...
    def setDof(self, dofs: tuple[int, ...]) -> None: ...
    def setGlobalSizes(self, sizes: tuple[int, ...]) -> None: ...
    def setProcSizes(self, sizes: tuple[int, ...]) -> None: ...
    def setOwnershipRanges(self, ranges: tuple[Sequence[int], ...]) -> None: ...
    def getDim(self) -> int: ...
    def getEntriesPerElement(self) -> int: ...
    def getStencilWidth(self) -> int: ...
    def getDof(self) -> tuple[int, ...]: ...
    def getCorners(self) -> tuple[tuple[int, ...], tuple[int, ...], tuple[int, ...]]: ...
    def getGhostCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getLocalSizes(self) -> tuple[int, ...]: ...
    def getGlobalSizes(self) -> tuple[int, ...]: ...
    def getProcSizes(self) -> tuple[int, ...]: ...
    def getStencilType(self) -> str: ...
    def getOwnershipRanges(self) -> tuple[Sequence[int], ...]: ...
    def getBoundaryTypes(self) -> tuple[str, ...]: ...
    def getIsFirstRank(self) -> tuple[int, ...]: ...
    def getIsLastRank(self) -> tuple[int, ...]: ...
    def setUniformCoordinatesExplicit(self, xmin: float = 0, xmax: float = 1, ymin: float = 0, ymax: float = 1, zmin: float = 0, zmax: float = 1) -> None: ...
    def setUniformCoordinatesProduct(self, xmin: float = 0, xmax: float = 1, ymin: float = 0, ymax: float = 1, zmin: float = 0, zmax: float = 1) -> None: ...
    def setUniformCoordinates(self, xmin: float = 0, xmax: float = 1, ymin: float = 0, ymax: float = 1, zmin: float = 0, zmax: float = 1) -> None: ...
    def setCoordinateDMType(self, dmtype: DM.Type) -> None: ...
    def getLocationSlot(self, loc: StencilLocation, c: int) -> int: ...
    def getProductCoordinateLocationSlot(self, loc: StencilLocation) -> None: ...
    def getLocationDof(self, loc: StencilLocation) -> int: ...
    def migrateVec(self, vec: Vec, dmTo: DM, vecTo: Vec) -> None: ...
    def createCompatibleDMStag(self, dofs: tuple[int, ...]) -> DM: ...
    def VecSplitToDMDA(self, vec: Vec, loc: StencilLocation, c: int) -> tuple[DMDA, Vec]: ...
    def getVecArray(self, vec: Vec) -> None: ...
    def get1dCoordinatecArrays(self) -> None: ...
    dim: int
    dofs: tuple[int, ...]
    entries_per_element: int
    global_sizes: tuple[int, ...]
    local_sizes: tuple[int, ...]
    proc_sizes: tuple[int, ...]
    boundary_types: tuple[str, ...]
    stencil_type: str
    stencil_width: int
    corners: tuple[tuple[int, ...], tuple[int, ...]]
    ghost_corners: tuple[tuple[int, ...], tuple[int, ...]]

class DMComposite(DM):
    def create(self, comm: Comm | None = None) -> Self: ...
    def addDM(self, dm: DM, *args: DM) -> None: ...
    def getNumber(self) -> int: ...
    def getEntries(self) -> list[DM]: ...
    def scatter(self, gvec: Vec, lvecs: Sequence[Vec]) -> None: ...
    def gather(self, gvec: Vec, imode: InsertModeSpec, lvecs: Sequence[Vec]) -> None: ...
    def getGlobalISs(self) -> list[IS]: ...
    def getLocalISs(self) -> list[IS]: ...
    def getLGMaps(self) -> list[LGMap]: ...
    def getAccess(self, gvec: Vec, locs: Sequence[int] | None = None) -> Any: ...
    getNumberDM = getNumber

class DMShell(DM):
    def create(self, comm: Comm | None = None) -> Self: ...
    def setMatrix(self, mat: Mat) -> None: ...
    def setGlobalVector(self, gv: Vec) -> None: ...
    def setLocalVector(self, lv: Vec) -> None: ...
    def setCreateGlobalVector(self, create_gvec: Callable[[DM], Vec] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateLocalVector(self, create_lvec: Callable[[DM], Vec] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setGlobalToLocal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = None, begin_kargs: dict[str, Any] | None = None, end_args: tuple[Any, ...] | None = None, end_kargs: dict[str, Any] | None = None) -> None: ...
    def setGlobalToLocalVecScatter(self, gtol: Scatter) -> None: ...
    def setLocalToGlobal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = None, begin_kargs: dict[str, Any] | None = None, end_args: tuple[Any, ...] | None = None, end_kargs: dict[str, Any] | None = None) -> None: ...
    def setLocalToGlobalVecScatter(self, ltog: Scatter) -> None: ...
    def setLocalToLocal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = None, begin_kargs: dict[str, Any] | None = None, end_args: tuple[Any, ...] | None = None, end_kargs: dict[str, Any] | None = None) -> None: ...
    def setLocalToLocalVecScatter(self, ltol: Scatter) -> None: ...
    def setCreateMatrix(self, create_matrix: Callable[[DM], Mat] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCoarsen(self, coarsen: Callable[[DM, Comm], DM] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setRefine(self, refine: Callable[[DM, Comm], DM] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateInterpolation(self, create_interpolation: Callable[[DM, DM], tuple[Mat, Vec]] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateInjection(self, create_injection: Callable[[DM, DM], Mat] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateRestriction(self, create_restriction: Callable[[DM, DM], Mat] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateFieldDecomposition(self, decomp: Callable[[DM], tuple[list[str] | None, list[IS] | None, list[DM] | None]] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateDomainDecomposition(self, decomp: Callable[[DM], tuple[list[str] | None, list[IS] | None, list[IS] | None, list[DM] | None]] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateDomainDecompositionScatters(self, scatter: Callable[[DM, list[DM]], tuple[list[Scatter], list[Scatter], list[Scatter]]] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...
    def setCreateSubDM(self, create_subdm: Callable[[DM, Sequence[int]], tuple[IS, DM]] | None, args: tuple[Any, ...] | None = None, kargs: dict[str, Any] | None = None) -> None: ...

class DMSwarm(DM):
    class Type:
        BASIC: Final[int] = ...
        PIC: Final[int] = ...
    class MigrateType:
        MIGRATE_BASIC: Final[int] = ...
        MIGRATE_DMCELLNSCATTER: Final[int] = ...
        MIGRATE_DMCELLEXACT: Final[int] = ...
        MIGRATE_USER: Final[int] = ...
    class CollectType:
        COLLECT_BASIC: Final[int] = ...
        COLLECT_DMDABOUNDINGBOX: Final[int] = ...
        COLLECT_GENERAL: Final[int] = ...
        COLLECT_USER: Final[int] = ...
    class PICLayoutType:
        LAYOUT_REGULAR: Final[int] = ...
        LAYOUT_GAUSS: Final[int] = ...
        LAYOUT_SUBDIVISION: Final[int] = ...
    def create(self, comm: Comm | None = None) -> Self: ...
    def createGlobalVectorFromField(self, fieldname: str) -> Vec: ...
    def destroyGlobalVectorFromField(self, fieldname: str) -> None: ...
    def createGlobalVectorFromFields(self, fieldnames: Sequence[str]) -> Vec: ...
    def destroyGlobalVectorFromFields(self, fieldnames: Sequence[str]) -> None: ...
    def createLocalVectorFromField(self, fieldname: str) -> Vec: ...
    def destroyLocalVectorFromField(self, fieldname: str) -> None: ...
    def createLocalVectorFromFields(self, fieldnames: Sequence[str]) -> Vec: ...
    def destroyLocalVectorFromFields(self, fieldnames: Sequence[str]) -> None: ...
    def initializeFieldRegister(self) -> None: ...
    def finalizeFieldRegister(self) -> None: ...
    def setLocalSizes(self, nlocal: int, buffer: int) -> Self: ...
    def registerField(self, fieldname: str, blocksize: int, dtype: type | dtype = ScalarType) -> None: ...
    def getField(self, fieldname: str) -> Sequence[int | float | complex]: ... # type: ignore[override]
    def restoreField(self, fieldname: str) -> None: ...
    def vectorDefineField(self, fieldname: str) -> None: ...
    def addPoint(self) -> None: ...
    def addNPoints(self, npoints: int) -> None: ...
    def removePoint(self) -> None: ...
    def removePointAtIndex(self, index: int) -> None: ...
    def copyPoint(self, pi: int, pj: int) -> None: ...
    def getLocalSize(self) -> int: ...
    def getSize(self) -> int: ...
    def migrate(self, remove_sent_points: bool = False) -> None: ...
    def collectViewCreate(self) -> None: ...
    def collectViewDestroy(self) -> None: ...
    def setCellDM(self, dm: DM) -> None: ...
    def getCellDM(self) -> DM: ...
    def setType(self, dmswarm_type: Type | str) -> None: ... # type: ignore[override]
    def setPointsUniformCoordinates(self, min: Sequence[float], max: Sequence[float], npoints: Sequence[int], mode: InsertMode | None = None) -> Self: ...
    def setPointCoordinates(self, coordinates: Sequence[float], redundant: bool = False, mode: InsertMode | None = None) -> None: ...
    def insertPointUsingCellDM(self, layoutType: PICLayoutType, fill_param: int) -> None: ...
    def setPointCoordinatesCellwise(self, coordinates: Sequence[float]) -> None: ...
    def viewFieldsXDMF(self, filename: str, fieldnames: Sequence[str]) -> None: ...
    def viewXDMF(self, filename: str) -> None: ...
    def sortGetAccess(self) -> None: ...
    def sortRestoreAccess(self) -> None: ...
    def sortGetPointsPerCell(self, e: int) -> list[int]: ...
    def sortGetNumberOfPointsPerCell(self, e: int) -> int: ...
    def sortGetIsValid(self) -> bool: ...
    def sortGetSizes(self) -> tuple[int, int]: ...
    def projectFields(self, dm: DM, fieldnames: Sequence[str], vecs: Sequence[Vec], mode: ScatterModeSpec = None) -> None: ...
    def addCellDM(self, celldm: CellDM) -> None: ...
    def setCellDMActive(self, name: str) -> None: ...
    def getCellDMActive(self) -> CellDM: ...
    def getCellDMByName(self, name: str) -> CellDM: ...
    def getCellDMNames(self) -> list[str]: ...
    def computeMoments(self, coord: str, weight: str) -> list[float]: ...

class DMInterpolation:
    def create(self, comm: Comm | None = None) -> Self: ...
    def destroy(self) -> Self: ...
    def evaluate(self, dm: DM, x: Vec, v: Vec | None = None) -> Vec: ...
    def getCoordinates(self) -> Vec: ...
    def getDim(self) -> int: ...
    def getDof(self) -> int: ...
    def setDim(self, dim: int) -> None: ...
    def setDof(self, dof: int) -> None: ...
    def setUp(self, dm: DM, redundantPoints: bool = False, ignoreOutsideDomain: bool = False) -> None: ...
    def getVector(self) -> Vec: ...
    def restoreVector(self, vec: Vec) -> None: ...

class InsertMode:
    NOT_SET_VALUES: Final[int] = ...
    INSERT_VALUES: Final[int] = ...
    ADD_VALUES: Final[int] = ...
    MAX_VALUES: Final[int] = ...
    INSERT_ALL_VALUES: Final[int] = ...
    ADD_ALL_VALUES: Final[int] = ...
    INSERT_BC_VALUES: Final[int] = ...
    ADD_BC_VALUES: Final[int] = ...
    INSERT: Final[int] = ...
    ADD: Final[int] = ...
    MAX: Final[int] = ...
    INSERT_ALL: Final[int] = ...
    ADD_ALL: Final[int] = ...
    INSERT_BC: Final[int] = ...
    ADD_BC: Final[int] = ...

class ScatterMode:
    SCATTER_FORWARD: Final[int] = ...
    SCATTER_REVERSE: Final[int] = ...
    SCATTER_FORWARD_LOCAL: Final[int] = ...
    SCATTER_REVERSE_LOCAL: Final[int] = ...
    FORWARD: Final[int] = ...
    REVERSE: Final[int] = ...
    FORWARD_LOCAL: Final[int] = ...
    REVERSE_LOCAL: Final[int] = ...

class NormType:
    NORM_1: Final[int] = ...
    NORM_2: Final[int] = ...
    NORM_1_AND_2: Final[int] = ...
    NORM_FROBENIUS: Final[int] = ...
    NORM_INFINITY: Final[int] = ...
    NORM_MAX: Final[int] = ...
    N1: Final[int] = ...
    N2: Final[int] = ...
    N12: Final[int] = ...
    MAX: Final[int] = ...
    FROBENIUS: Final[int] = ...
    INFINITY: Final[int] = ...
    FRB: Final[int] = ...
    INF: Final[int] = ...

class Error(RuntimeError):
    def __init__(self, ierr: int = 0) -> None: ...
    def __bool__(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

def garbage_cleanup(comm: Comm | None = None) -> None: ...
def garbage_view(comm: Comm | None = None) -> None: ...


class DMPlexTransformType:
    REFINEREGULAR: Final[str] = ...
    REFINEALFELD: Final[str] = ...
    REFINEPOWELLSABIN: Final[str] = ...
    REFINEBOUNDARYLAYER: Final[str] = ...
    REFINESBR: Final[str] = ...
    REFINETOBOX: Final[str] = ...
    REFINETOSIMPLEX: Final[str] = ...
    REFINE1D: Final[str] = ...
    EXTRUDE: Final[str] = ...
    TRANSFORMFILTER: Final[str] = ...

class RegressorLinearType:
    OLS: Final[int] = ...
    LASSO: Final[int] = ...
    RIDGE: Final[int] = ...

class _IS_buffer:
    ...

class _Vec_buffer:
    ...

class _Vec_LocalForm:
    ...

class _DMDA_Vec_array:
    starts: Any
    sizes: Any
    shape: Any
    strides: Any
    array: Any

class _DMComposite_access:
    ...

def _initialize(args=None, comm=None): ...
def _pre_finalize(): ...
def _finalize(): ...
def _push_python_vfprintf(): ...
def _pop_python_vfprintf(): ...
def _stdout_is_stderr(): ...

INFINITY: Final[float] = ...
NINFINITY: Final[float] = ...
PINFINITY: Final[float] = ...
__pyx_capi__: Final[dict[str, Any]] = ...
__type_registry__: Final[dict[int, type[Object]]] = ...
__arch__: Final[str] = ...

