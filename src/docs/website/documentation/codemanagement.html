<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
  <title>PETSc: Docs:&nbsp;&nbsp; Code Management</title>
</head>
<body bgcolor="#d5eaff">
<table width="100%">
  <tbody>
    <tr>
      <td valign="top" width="25%">
      <h1><font color="#ff0000" size="7">PETSc</font></h1>
      <ul>
        <li><a href="../index.html"><strong>Home</strong></a></li>
      </ul>
      </td>
      <td width="75%"><!--##begin-->
      <h1>Docs:&nbsp; Code Management</h1>
<!--##end--> </td>
    </tr>
    <tr>
      <td colspan="2" width="100%">
      <hr color="#ff5b5b" size="4"> </td>
    </tr>
    <tr>
      <td valign="top" width="25%">
      <ul>
        <li><a href="../download/index.html"><strong>Download</strong></a></li>
        <li><a href="../features/index.html"><strong>Features</strong></a></li>
        <li><a href="index.html"><strong>Documentation</strong></a>
          <ul>
            <li><a href="index.html#Manual"><strong>Manual pages and
Users Manual</strong></a></li>
            <li><a href="referencing.html"><strong>Referencing&nbsp;
PETSc</strong></a></li>
            <li><a href="tutorials/index.html"><strong>Tutorials</strong></a></li>
            <li><strong><a href="installation.html">Installation</a> </strong></li>
            <li><strong></strong><strong><a href="ams.html">AMS</a></strong></li>
            <li><strong><a href="changes/index.html">Changes</a></strong></li>
            <li><strong><a href="bugreporting.html">Bug Reporting</a></strong></li>
            <li><strong><font color="#ff0000">Code Management</font></strong></li>
            <li><strong><a href="faq.html">FAQ</a> </strong></li>
            <li><strong><a href="copyright.html">License</a> </strong></li>
          </ul>
        </li>
        <li><a href="../publications/index.html"><strong>Applications/Publications</strong></a></li>
        <li><a href="../miscellaneous/index.html"><strong>Miscellaneous</strong></a></li>
        <li><a href="../miscellaneous/external.html"><strong>External
Software</strong></a></li>
        <li><a href="../developers/index.html"><strong>Developers Site</strong></a></li>
      </ul>
      </td>
      <td valign="top" width="75%"><!--##begin--> In this file we list
some of the techniques that may be used to increase one's
efficiency when developing PETSc application codes. We have learned to
use these techniques ourselves, and they have improved our efficiency
tremendously.
      <p align="center"><strong><big><big>Editing and Compiling</big></big></strong></p>
      <p>The biggest time sink in code development is generally the
cycle of EDIT-COMPILE-LINK-RUN. We often see users working in a
single window with a cycle such as: </p>
      <ul>
        <li>Edit a file with VI. </li>
        <li>Exit VI. </li>
        <li>Run make and see some error messages. </li>
        <li>Start VI and try to fix the errors; often starting VI hides
the error messages so that users cannot remember all of them
and thus do not fix all the compiler errors. </li>
        <li>Run make generating a bunch of object (.o) files. </li>
        <li>Link the executable (which also removes the .o files).
Users may delete the .o files because they anticipate compiling
the next time on a different machine that uses a different
compiler. </li>
        <li>Run the executable. </li>
        <li>Detect some error condition and restart the cycle. </li>
      </ul>
      <p>In addition, during this process the user often moves manually
among different directories for editing, compiling, and running.</p>
      <p><font size="4"><strong>Several easy ways to improve the cycle:</strong></font>
      </p>
      <ul>
        <li>Work in two windows next to each other. </li>
        <li>Keep the editor running all the time, rather than
continually exiting and entering it. </li>
        <li>Organize directories so code is not scattered all over the
place. </li>
        <li>Never use scripts to run makefiles. (This is a common trick
by people who have trouble getting make to do exactly what they
want.)  Instead, learn a bit more about how PETSc uses make to
compile complicated application codes portably, quickly, and easily.</li>
        <li>If an application generates lots of .o files, store them in
libraries (.a files), with names that indicate the type of
machine and optimization levels. For example, PETSc's libraries
are stored in the directory ${PETSC_DIR}/${PETSC_ARCH}/lib/.
Thus, when switching to another machine that shares the same
file system, one does not have to remember to delete a bunch of
.o files and edit makefiles accordingly. </li>
        <li>To alleviate the need for jumping between directories every
time a test run is made, store the executable in the directory
where it has been compiled when possible. </li>
      </ul>
      <p>Several PETSc authors worked previously for years using
exclusively VI for editing. We have found that EMACS improves one's
programming efficiency enormously. For example, </p>
      <ul>
        <li>EMACS has a feature to allow the user to compile using make
and have the editor automatically jump to the line of source
code where the compiler detects an error, even when not
currently editing the erroneous file.</li>
        <li>The etags feature of EMACS enables one to search quickly
through a group of user-defined source files (and/or PETSc
source files) regardless of the directory in which they are located.
Etags usage tips (where M- denotes the "meta" key in EMACS):
          <ul>
            <li>To access the predefined PETSc tags in EMACS, type M-x
visit-tags-table and specify the file ${PETSC_DIR}/TAGS </li>
            <li>To move to where a PETSc function is defined, enter M-.
This is useful for viewing manpages and locating source
code. </li>
            <li>To search for a string and move to the first
occurrence, use M-x tags-search Then, to locate later
occurrences, type M-, In particular, this is useful for quickly
locating examples of usage of certain PETSc routines. </li>
            <li>Another quite helpful command is M-x tags-query-replace
which replaces occurrences of a string hroughout all tagged
files (can retain any entries if desired); this enables quick and
painless revisions of source code, particularly when routines are
spread throughout many files and directories. </li>
          </ul>
        </li>
      </ul>
      <ul>
        <li>Also, EMACS easily enables:
          <ul>
            <li>editing files that reside in any directory and
retaining one's place within each of them </li>
            <li>searching for files in any directory as one attempts to
load them into the editor </li>
          </ul>
        </li>
      </ul>
      <p>Admittedly, it takes a while to get the hang of using EMACS.
But we've found that the increase in our programming efficiency has
been well worth the time spent learning to use this editor. We
seriously believe that we could not have developed PETSc as it is today
if we had not switched to EMACS.<br>
      </p>
      <p>VI and Eclipse also provide tools for quickly finding things
and searching in PETSc source code, see the Emacs, VI/Vim and Eclipse
sections of the <a
 href="http://www.mcs.anl.gov/petsc/petsc-dev/docs/manual.pdf">users
manual</a>.
        <a href="http://gnu.org/s/global">GNU Global</a> is a richer alternative to
        etags, see the user's manual for more details.<br>
      </p>
      <p align="center"><strong><big><big><big>Debugging</big></big></big></strong></p>
      <p>Most code development for PETSc codes should be done on one
processor; hence, using a standard debugger such as dbx, gdb, xdbx,
etc. is fine. For debugging parallel runs we suggest <strong>Totalview</strong>
if it is available on your machine. Otherwise, you can run each
process in a separate debugger; this is not the same as using a
parallel debugger, but in most cases it is not so bad. The PETSc
run-time options -start_in_debugger [-display xdisplay:0] will
open separate windows and debuggers for each process. You should
debug using the debugging versions of the libraries (run ./configure
with the
additional option --with-debugging=1 (the default)).</p>
      <p>It really pays to learn how to use a debugger; you will end up
writing more interesting and far more ambitious codes once it
is easy for you to track down problems in the codes.</p>
      <p align="center"><font size="6"><strong>Other suggestions</strong></font></p>
      <ul>
        <li>Choose consistent and obvious names for variables and
functions. (Short variable names may be faster to type, but by
using longer names you don't have to remember what they represent since
it is clear from the name.) </li>
        <li>Use informative comments. </li>
        <li>Leave space in the code to make it readable. </li>
        <li>Line things up in the code for readability. Remember that
any code written for an application will be visited <strong>over
and over</strong> again, so spending an extra 20 percent of
effort on it the first time will make each of those visits faster and
more efficient. </li>
        <li>Realize that you <strong>will</strong> have to debug your
code. <strong>No one</strong> writes perfect code, so always write
code
that may be debugged and learn how to use a debugger. In most
cases using the debugger to track down problems is much faster than using
print statements. </li>
        <li><strong>Never</strong> hardwire a large problem size into
your code. Instead, allow a command line option to run a small
problem. We've seen people developing codes who have to wait 15
minutes after starting a run to reach the crashing point; this is an
inefficient way of developing code. </li>
        <li>Develop your code on the simplest machine to which you have
access. We have accounts on a variety of large parallel machines,
but we write and initially test all our code on laptops or workstations
because the user interface is friendlier, and the
turn-around time for compiling and running is much faster than
for the parallel machines. We use the parallel machines only
for large jobs. Since PETSc code is completely portable, switching to
a parallel machine from our laptop/workstation development environment simply means
logging into another machine -- there are no code or makefile
changes. </li>
        <li>Never develop code directly on an MPP; your productivity
will be much lower than if you developed on a well-organized
workstation. </li>
        <li>Keep your machines' operating systems and compilers
up-to-date (or force your systems people to do this :-). You
should always work with whatever tools are currently the best
available. It may seem that you are saving time by not spending the
time upgrading your system, but, in fact, your loss in
efficiency by sticking with an outdated system is probably
larger than then the time required to keep it up-to-date. </li>
      </ul>
      <p align="center"><font size="6"><strong>Fortran notes</strong></font></p>
      <p>Since Fortran77 does not provide type checking of routine
input/output parameters, we find that many errors encountered
within PETSc Fortran77 programs result from accidentally using
incorrect calling sequences. Thus, if your Fortran program is crashing,
one of the first things to check is that all subroutines are being
called with the correct arguments. <br>
      </p>
      <p>When passing floating point numbers into Fortran subroutines,
always make sure you have them marked as double precision (e.g.,
pass in 10.d0 instead of 10.0). Otherwise, the compiler interprets
the input as a single precision number, which can cause crashes or
other mysterious problems. Make sure to declare all variables (do not
use the implicit feature of Fortran). In fact, we <strong>highly</strong>
recommend using the <strong>implicit none</strong> option at the
begining of each Fortran subroutine you write.<br>
      </p>
      <p>Fortran 90 provides the ability to do some type checking of
subroutine calls by using Fortran 90 interfaces or modules. PETSc now
provides
interfaces and modules for Fortran 90; see the <a
 href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Sys/UsingFortran.html">manual
page</a> for how to use them.<br>
<!--##end--> </p>
      </td>
    </tr>
    <tr>
      <td colspan="2" width="100%">
      <hr color="#ff5b5b" size="4"> </td>
    </tr>
  </tbody>
</table>
</body>
</html>
