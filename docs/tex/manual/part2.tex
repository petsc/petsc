%
% NOTES:  
%  - Be sure to place captions BEFORE labels in figures and tables!
%    Otherwise, numbering will be incorrect.  For example, use the following:
%       \caption{TAO Info}
%       \label{fig:taoinfo}
%  - Use \break to indicate a line break (needed to prevent long strings in
%    \tt mode from running of the page)
%
% ---------------------------------------------------------------

\chapter{Using TAO Solvers}
%\sindex{continuous optimization}
\label{chapter:tao_solver}

TAO contains unconstrained minimization, bound-constrained minimization, 
nonlinear complementarity, nonlinear least squares solvers, and solvers
for optimization problems with partial differential equation constraints.
The structure of these problems can differ significantly, but TAO has a 
similar interface to all of its solvers.  
Routines that most solvers have in common are discussed in 
this chapter.
A complete list of options can be found by consulting the manual pages.
Many of the options can also be set at the command line.  These options
can also be found in manual pages or by
running a program with the {\tt -help} option.

\section{Header File}

TAO applications written in C/C++ should have the statement 
\begin{verbatim}
   #include "tao.h"
\end{verbatim}
\noindent
in each file that uses a routine in the TAO libraries.
All of the required lower level include files such as ``taosolver.h''
and ``tao\_sys.h,'' as well as ``petsc.h,'' ``petscvec.h,'' and
``petscmat.h''
are automatically included by this high-level file.


\section{Initialize and Finalize}

The first TAO routine in any application should be {\tt TaoInitialize()}.
Most TAO programs begin with a call to
\findex{TaoInitialize()}
\begin{verbatim}
   TaoInitialize(int *argc,char ***argv,char *filename, 
                        char *help_message);
\end{verbatim}
which initializes TAO, as well as MPI, PETSc, and other packages
to which TAO applications may link (if these have not yet
been initialized elsewhere).  
In particular, the arguments {\tt argc} and 
{\tt argv} are the command line arguments delivered in all C and C++
programs; these arguments initialize the options database.  
\sindex{command line arguments} The argument {\tt filename}
optionally indicates an alternative name for an options file, which by
default is called {\tt .petscrc} and resides in the user's home directory.

One of the last routines\findex{TaoFinalize()} that all TAO programs should 
call is 
\begin{verbatim}
   TaoFinalize();
\end{verbatim}
which finalizes TAO and any other libraries that may have been
initialized during the {\tt TaoInitialize()} phase.
For example, {\tt TaoFinalize()}
calls {\tt PetscFinalize()} 
if {\tt TaoInitialize()}
began PETSc. If PETSc was initiated externally from TAO (by either
the user or another software package), then the user is
responsible for calling {\tt PetscFinalize()}. 

In Fortran, the initialization and finalization commands are
\begin{verbatim}
  call TaoInitialize(filename, ierr)
  call TaoFinalize(ierr)
\end{verbatim}
respectively. 

\section{Creation and Destruction}

A TAO solver can be created by calling the
\findex{TaoCreate()}
\begin{verbatim}
   TaoCreate(MPI_Comm comm,TaoSolver *newsolver);
\end{verbatim}
routine. 
Much like creating PETSc vector and matrix objects, 
the first argument is an MPI {\em communicator}.
An MPI \cite{using-mpi} communicator
indicates a collection of processors that will be used to evaluate the
objective function, compute constraints, and provide derivative information.
When only one processor is being used, the communicator {\tt PETSC\_COMM\_SELF}
can be used with no understanding of MPI.
Even parallel users need to be familiar with only the basic concepts 
of message passing and  distributed-memory computing. 
Most applications running TAO in
parallel environments can employ the communicator {\tt
PETSC\_COMM\_WORLD} to indicate all processes known to PETSc in a given run.

The routine
\findex{TaoSetType()}
\begin{verbatim}
   TaoSetType(TaoSolver tao,TaoType type);
\end{verbatim}
\noindent
can be used to set the algorithm TAO uses to solve the application.
The various types of TAO solvers and the flags that identify them 
will be discussed in the following chapters.
The solution method should be carefully chosen depending upon
the problem that is being solved.  Some solvers, for instance, are meant for
problems with no constraints, while other solvers acknowledge constraints
in the problem and handle them accordingly.
The user must also be aware of the derivative information that is available.
Some solvers require second-order information, while other solvers require
only gradient or function information.
The command line option \texttt{-tao\_method} (or equivalently 
\texttt{-tao\_type}) followed by a TAO method
will override any method specified by the second argument.
The command line option {\tt -tao\_method tao\_lmvm}, for instance,
will specify the limited memory variable metric method for unconstrained
optimization.  Note that the {\tt TaoType} variable is a string that requires
quotation marks in an application program, but quotation marks are not required
at the command line.

Each TAO solver that has been created should also be destroyed using
the  
\findex{TaoDestroy()}
\begin{verbatim}
   TaoDestroy(TaoSolver tao);
\end{verbatim}
command. 
This routine frees the internal data structures used by the solver.


\section{TAO Applications}
\sindex{application}
\label{section:taoapplication}
\label{section:petscapp}

The solvers in TAO address applications that have a set of variables, an objective
function, and possibly constraints on the variables.  Many solvers also
require derivatives
of the objective and constraint functions.
To use the TAO solvers, the application developer must 
define a set of variables, implement routines that evaluate the 
objective function and constraint functions, and pass this information
to a TAO application object.   

TAO uses vector and matrix objects to pass this information from the
application to the solver.   The set of variables, for instance, is
represented in a vector.
The gradient of an objective function $f: \, \Re^n \to \Re$,
evaluated at a point, is also represented as a vector.
Matrices,  on the other hand,
can be used to represent the Hessian of $f$ or the Jacobian of a constraint
function $c: \, \Re^n \to \Re^m$.  The TAO solvers use
these objects to compute a solution to the application.

\subsection{Defining Variables}
In all of the optimization solvers, the application must provide
a {\bf Vec} object of appropriate dimension to represent the variables.
This vector will be cloned by the solvers to create additional work
space within the solver.
If this vector is distributed over multiple processors, it
should have a parallel distribution that allows
for efficient scaling, inner products, and
function evaluations.  This vector can be passed to the
application object using the  \findex{TaoAppSetInitialSolutionVec()}
\begin{verbatim}
   TaoSetInitialVector(TaoSolver,Vec);
\end{verbatim}
routine. 
When using this routine, the application should initialize the vector with
an approximate solution of the optimization problem before calling the
TAO solver.
This vector will be used by the TAO solver to store the solution.
Elsewhere in the application, 
this solution vector can be retrieved from the application object 
using the  \findex{TaoGetSolutionVector()}
\begin{verbatim}
   TaoGetSolutionVector(TaoSolver,Vec *);
\end{verbatim}
routine. 
This routine takes the address of a {\tt Vec} in the second argument and sets it to
the solution vector used in the application.

\subsection{Application Context}  \sindex{application context}
Writing a TAO application may require
use of an {\em application context}.
An application context is a structure or object defined by an
application developer, passed
into a routine also written by the application developer, 
and used within the routine to perform its stated task.
 
For example, a routine that evaluates an objective function may need
parameters, work vectors, and other information.   This information,
which may be specific to an application and necessary to evaluate the objective,
can be collected in a single structure and used as one of the
arguments in the routine.
The address of this structure will be cast as type {\tt (void*)} and passed to
the routine in the final argument.
There are many examples of these structures in the examples included in the
TAO distribution.

This technique offers several advantages.
In particular, it allows for a uniform interface between TAO and 
the applications.   The fundamental information needed by TAO 
appears in the arguments of the routine, while data specific to an application
and its implementation is confined to an opaque pointer.
The routines can access information created outside the 
local scope without the use of global variables.
The TAO solvers and application objects will never access this structure, 
so the application developer has complete freedom to define it.  In fact,
these contexts are completely optional -- a NULL pointer can be used.



\subsection{Objective Function and Gradient Routines}\label{sec:fghj}

TAO solvers that minimize an objective function require
the application to evaluate the objective function.  Some solvers
may also require the application to evaluate
derivatives of the objective function.  
Routines that perform these computations must be identified
to the application object and must follow a strict calling sequence.

Routines should follow the form
\begin{verbatim}
   PetscErrorCode EvaluateObjective(TaoSolver,Vec,PetscReal*,void*);
\end{verbatim}
in order to evaluate an objective function $f: \, \Re^n \to \Re$. 
The first argument is the TAO Solver object, the second argument is the
$n$-dimensional vector that identifies where the objective should be evaluated, 
and the fourth argument is an application context.
This routine should use the third argument to return the objective value 
evaluated at the point
specified by the vector in the second argument.

This routine, and the application context, should be passed to the 
application object using
the  \findex{TaoSetObjectiveRoutine()}
\begin{verbatim}
   TaoSetObjectiveRoutine(TaoSolver,
                     PetscErrorCode(*)(TaoSolver,Vec,PetscReal*,void*),
                     void*);
\end{verbatim}
routine. 
The first argument in this routine is the TAO solver object, 
the second argument is a function pointer to the routine that 
evaluates the objective, and the third
argument is the pointer to an appropriate application context.  
Although the final argument may point to anything, it must be cast as a {\tt (void*)} type.
This pointer will be passed back to the developer in the fourth argument of the
routine that evaluates the objective.  In this routine, the pointer can be cast
back to the appropriate type.  Examples of these structures and their 
usage are provided in the distribution.

Many TAO solvers also require gradient information from the 
application \sindex{gradients}.
  The gradient of the objective function is specified in a similar manner.
Routines that evaluate the gradient should have the calling sequence
\begin{verbatim}
   PetscErrorCode EvaluateGradient(TaoSolver,Vec,Vec,void*);
\end{verbatim}
\noindent
where the first
argument is the TAO solver object, the second argument is the variable
vector, the third argument is the gradient vector, and the fourth argument is
the user-defined application context.  Only the third argument in this
routine is different from the arguments in the routine for evaluating
the objective function.  The numbers in the gradient vector have no
meaning when passed into this routine, but should represent the gradient
of the objective at the specified point at the end of the routine.
This routine, and the user-defined pointer, can be passed to the application
object using the  \findex{TaoSetGradientRoutine()}
\begin{verbatim}
   TaoSetGradientRoutine(TaoSolver,
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                     void *);
\end{verbatim}
routine. 
In this routine, the first argument is the TaoSolver object, the second argument
is the function pointer, and the third object is the application context, cast
to {\tt (void*)}.

Instead of evaluating the objective and its gradient in separate
routines, TAO also allows the user to evaluate the function and the gradient
in the same routine.  In fact, some solvers are more efficient when
both function and gradient information can be computed in the same routine.
These routines should follow the form
\begin{verbatim}
   PetscErrorCode EvaluateFunctionAndGradient(TaoSolver,Vec,
                     PetscReal*,Vec,void*);
\end{verbatim}
\noindent
where the first
argument is the TAO solver, and the second
argument points to the input vector for use in evaluating the
function and gradient. The third argument should return the
function value, while the fourth argument should return the gradient vector,
and the fifth argument is a pointer to a user-defined context.
This context and the name of the routine should be set with the
call \findex{TaoSetObjectiveAndGradientRoutine()}
\begin{verbatim}
   TaoSetObjectiveAndGradientRoutine(TaoSolver,
                     PetscErrorCode (*)(TaoSolver,Vec,PetscReal*,Vec,void*),
                     void *);
\end{verbatim}
where the arguments are the TAO application, a
function name, and a pointer to a user-defined context.


The TAO example problems demonstrate the use of these application contexts
as well as specific instances of function, gradient, and Hessian 
evaluation routines.
All of these routines should return the integer $0$ after 
successful completion and a nonzero integer if the function
is undefined at that point or an error occurred.

\subsection{Hessian Evaluation}
\label{sec:matrixfree}
\label{sec:finitedifference}

Some optimization routines also require a Hessian matrix from the user.
The routine that evaluates the Hessian should have the form 
\begin{verbatim}
   PetscErrorCode EvaluateHessian(TaoSolver,Vec,Mat*,Mat*,MatStructure*,
                     void*);
\end{verbatim}
where the first argument of this routine is a TAO solver object.  The
second
argument is the point at which the Hessian should be evaluated.  The
third argument is the Hessian matrix, and the sixth argument is a
user-defined context.
Since the Hessian matrix is usually used in solving
a system of linear equations, a preconditioner for the matrix is often
needed.  The fourth argument is the matrix that will be used
for preconditioning the linear system.  In most cases, this
matrix will be the same as the Hessian matrix.  The fifth
argument is the flag used to set the Hessian matrix and
linear solver in the routine {\tt KSPSetOperators()}.

One can set the Hessian evaluation routine by calling the \sindex{Hessian}
\findex{TaoSetHessianRoutine()}
\begin{verbatim}
   TaoSetHessianRoutine(TaoSolver,Mat H, Mat Hpre,
                     PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,
                     MatStructure*,void*), void *);
\end{verbatim}
routine. 
The first argument is the TAO Solver object, the second and third arguments
are the Mat object where the Hessian will be stored and the Mat object
that will be used for the preconditioning (they may be the same). The fourth 
argument is the function that evaluates the Hessian, 
and the fifth argument is a pointer to a user defined context,
cast to {\tt (void*)}.

\subsubsection{Finite Differences} \sindex{finite differences}
Finite differences approximations can be used to compute the gradient and the
Hessian of an objective
function.  These approximations will slow down the solve considerably and 
are primarily  
recommended for checking the accuracy of hand-coded gradients and Hessians.
These routines are
\findex{TaoDefaultComputeGradient()}
\begin{verbatim}
   TaoDefaultComputeGradient(TaoSolver, Vec, Vec, void*);
\end{verbatim}
and 
\findex{TaoDefaultComputeHessian()}
\begin{verbatim}
   TaoDefaultComputeHessian(TaoSolver, Vec, Mat*, Mat*, 
                     MatStructure*, void*);
\end{verbatim}
respectively, and can be set using {\tt
TaoSetGradientRoutine()} and 
{\tt TaoSetHessianRoutine()} or through the options database with the
options {\tt -tao\_fdgrad} and {\tt -tao\_fd}.

The efficiency of the finite difference Hessian can be improved if the
coloring of the matrix is known.  If the application programmer creates
a PETSc {\tt MatFDColoring} object, it can be applied to the finite 
difference approximation by setting the Hessian evaluation routine to
\begin{verbatim}
   TaoDefaultComputeHessianColor(TaoSolver, Vec, Mat*, Mat*, 
                     MatStructure*, void* );
\end{verbatim}
and using the {\tt MatFDColoring} object as
the last ({\tt void *}) argument to {\tt TaoSetHessianRoutine()}.

It is also possible to use finite difference approximations to directly check
the correctness of the gradient and/or Hessian evaluation routines.
This can be done from the command line using the special TAO solver 
{\tt tao\_fd\_test} together with the options
{\tt -tao\_test\_gradient} or {\tt -tao\_test\_hessian}.

\subsubsection{Matrix-Free Methods}
TAO fully supports matrix-free methods. The matrices specified in the
Hessian evaluation routine need not be conventional
matrices; instead, they can point to the data required to implement a
particular matrix-free method.  The matrix-free variant is allowed
{\em only} when the linear systems are solved by an iterative method
in combination with no preconditioning ({\tt PCNONE} or {\tt -pc\_type none}),
a user-provided preconditioner matrix, or a user-provided preconditioner
shell ({\tt PCSHELL}); that is,
obviously matrix-free methods cannot be used if a direct solver is to 
be employed. \sindex{matrix-free options} %\findex{PCSHELL}
Details about using matrix-free methods are provided in the
PETSc users manual \cite{petsc-user-ref}.


\subsection{Bounds on Variables}\label{sec:bounds}

Some optimization problems also impose constraints upon the variables.
The constraints may impose simple bounds upon the variables, or
require that the variables satisfy a set of linear or  nonlinear equations.

The simplest type of constraint upon an optimization problem puts lower
or upper bounds upon the variables. 
Vectors that represent lower and upper bounds for each variable 
can be set with the   \sindex{bounds}\findex{TaoSetVariableBounds}
\begin{verbatim}
   TaoSetVariableBounds(TaoSolver,Vec,Vec);
\end{verbatim}
command. 
The first vector and second vectors should contain the lower and upper 
bounds, respectively.
When no upper or lower bound exists for a variable, the bound
may be set to {\tt TAO\_INFINITY} or {\tt TAO\_NINFINITY}.
After the two bound vectors have been set, they may be accessed with the
with the command  {\tt TaoGetVariableBounds()}.

Alternatively, it may be more convenient for the user to designate a routine 
for computing these bounds
that the solver will call before starting its algorithm.  This routine will
have the form
\begin{verbatim}
   PetscErrorCode EvaluateBounds(TaoSolver,Vec,Vec,void*);
\end{verbatim}
where the two vectors, representing the lower and upper bounds respectfully, 
will be computed.

This routine can be set with the 
\begin{verbatim}
   TaoSetVariableBoundsRoutine(TaoSolver
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),void*);
\end{verbatim}
command.
   
Since not all solvers recognize the presence of bound constraints on 
variables, the user must be careful 
to select a type of solver that acknowledges these bounds.


\section{Solving}
Once the application and solver have been set up, the solver can be 
\findex{TaoSolve()} called using the 
\begin{verbatim}
   TaoSolve(TaoSolver);
\end{verbatim}
routine.
%This routine will call the TAO solver. 
We discuss several universal options below. 

\subsection{Convergence}\label{sec:customize}

Although TAO and its solvers set default parameters that are useful
for many problems, it may be necessary for the user to modify these
parameters to change the behavior and convergence of various algorithms.

One convergence criterion for most algorithms concerns the
of digits of accuracy needed in the solution.  In particular,
the convergence test employed by TAO attempts to stop when
the error in the constraints is less than $\epsilon_{crtol}$,
and either
\[
\begin{array}{lcl}
f(X) - f(X^*)  &\leq& \epsilon_{fatol}, \\
|f(X) - f(X^*)| / |f(X^*)| &\leq& \epsilon_{frtol},\\
||g(X)|| &\leq& \epsilon_{gatol}, \\
||g(X)||/|f(X)| &\leq& \epsilon_{grtol}, \quad \mbox{or} \\
||g(X)||/|g(X_0)| &\leq& \epsilon_{gttol},
\end{array}
\]
where $X$ is the current approximation to the true solution $X^*$
and $X_0$ is the initial guess.
$X^*$ is unknown, so TAO estimates $f(X) - f(X^*)$ with either 
the square of the norm of the gradient or the duality gap.
A relative tolerance of $\epsilon_{frtol}=0.01$ indicates that two
significant digits are desired in the objective function.
Each solver sets its own  convergence tolerances, but they can
be changed using the routine
\findex{TaoSetTolerances()} 
\sindex{convergence tests}
{\tt TaoSetTolerances()}.
Another set of convergence tolerances 
terminate the solver when the norm of the gradient function
(or Lagrangian function for bound-constrained problems)
is sufficiently close to zero.

Other stopping criteria include a minimum trust-region radius or 
a maximum number of iterations.  These parameters can be set with
the routines {\tt Tao\-Set\-Trust\-Region\-Tolerance()}\sindex{trust region}\findex{TaoSetTrustRegionTolerance}
and {\tt Tao\-Set\-Max\-imum\-Iter\-ations()}\findex{TaoSetMaximumIterations()}.
Similarly, a maximum number of function evaluations can be set 
with the command 
\findex{TaoSetMaximumFunctionEvaluations()}
{\tt Tao\-Set\-Max\-imum\-Func\-tion\-Evaluations()}.
The stopping criteria can
also be set using command line options such as \texttt{-tao\_fatol}, 
\texttt{-tao\_max\_it}, and \texttt{-tao\_max\_funcs}.

\subsection{Viewing Status}

To see parameters and performance statistics for the solver, the
routine
\begin{verbatim}
   TaoView(TaoSolver tao)
\end{verbatim}
can be used.  This routine will display to standard output the number
of function evaluations need by the solver and other information
specific to the solver.  This same output can be produced by using the 
command line option {\tt -tao\_view}.

The progress of the optimization solver can be monitored with
the runtime option {\tt -tao\_monitor}.  Although monitoring routines
can be customized, the default monitoring routine will print out 
several relevant statistics to the screen.

The user also has access to information about the current solution.
The current iteration number, objective function value, gradient
norm, infeasibility norm, and step length 
can be retrieved with the  
\findex{TaoGetSolutionStatus()}
\begin{verbatim}
   TaoGetSolutionStatus(TaoSolver tao, PetscInt *iterate, PetscReal *f,
                     PetscReal *gnorm, PetscReal *cnorm, PetscReal *xdiff,
                     TaoSolverTerminationReason *reason)
\end{verbatim}
command. 
The last argument returns a code that indicates the reason that the solver 
terminated.  Positive 
numbers indicate that a solution has been found, while negative numbers
indicate a failure.  A list of reasons can be found in the manual page
for {\tt Tao\-Get\-Termination\-Reason()}.

\subsection{Obtaining a Solution}

After exiting the {\tt Tao\-Solve()} function, the solution, gradient, and 
\findex{TaoGetSolution()} dual variables (if available) can be recovered 
with the 
\begin{verbatim}
   TaoGetSolutionVector(TaoSolver, Vec *X);
   TaoGetGradientVector(TaoSolver, Vec *G);
   TaoComputeDualVariables(TaoSolver, Vec X, Vec Duals);
\end{verbatim}
routines. 
Note that the {\tt Vec} returned by {\tt TaoGetSolutionVector} will be
the same vector passed in to {\tt TaoSetInitialVector}.  This information 
can be obtained during user-defined routines such as a function evaluation 
and customized monitoring routine, or after the solver has terminated.




\subsection{Additional Options}
Additional options for the TAO solver 
can be be set from the command line using the  \sindex{options}
\findex{TaoSetOptions()}
\begin{verbatim}
   TaoSetFromOptions(TaoSolver)
\end{verbatim}
routine. 
This command also provides information about runtime options when the
user includes the {\tt -help } option on the command line.

\section{Special Problem Structures}
Below we discuss how to exploit the special structures for three classes
of problems that TAO solves. 

\subsection{PDE-Constrained Optimization}\label{sec:pde_applications}
TAO can solve PDE-constrained optimization applications 
of the form
\[
\begin{array}{ll}
\displaystyle \min_{u,v} & f(u,v) \\
\mbox{subject to} & g(u,v) = 0
\end{array}
\]
where the state variable $u$ is the solution to the discretized partial 
differential equation defined by $g$ and parametrized by the design 
variable $v$, and $f$ is an objective function.  In this case, the 
user needs to set routines for computing the objective function
and its gradient, the constraints, and the Jacobian of the constraints
with respect to the state and design variables.  TAO also needs to know 
which variables in the solution vector correspond to state variables, 
and which to design variables.

The objective and gradient routines are set as for other TAO applications,
with {\tt Tao\-Set\-Object\-ive\-Routine()} and {\tt
Tao\-Set\-Gradient\-Routine()}.  The user can also provide a fused
objective function and gradient
evaluation with {\tt Tao\-Set\-Objective\-And\-Gradient\-Routine()}.
The input and output vectors include the combined state and design 
variables.  Index sets for the state and design variables must be 
passed to TAO using the function
\begin{verbatim}
   TaoSetStateDesignIS(TaoSolver, IS, IS);
\end{verbatim}
where the first IS is a PETSc Index\-Set containing the indices of the
state variables and the second IS the design variables.

Nonlinear equation constraints have the general form $c(x) = 0$ where 
$c: \Re^n \to \Re^m$.  These constraints should be specified in a routine, 
written by the user, that evaluates $c(x)$.  The routine that evaluates
the 
constraint equations should have the form
\begin{verbatim}
   PetscErrorCode EvaluateConstraints(TaoSolver,Vec,Vec,void*);
\end{verbatim}
where the first argument of this routine is a TAO solver object.  The
second argument is the variable vector at which the constraint function
should be evaluated.  
The third argument is the vector of function values $c(x)$, and the fourth
argument is a pointer to a user-defined context.  This routine and the 
user-defined context should be set in the TAO solver with the 
\findex{TaoSetConstraintsRoutine()}
\begin{verbatim}
   TaoSetConstraintsRoutine(TaoSolver,Vec,
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                     void*);
\end{verbatim}
command. 
In this function, the first argument is the TAO solver object, the second 
argument a vector in which to store the constraints, the third argument is
a function point to the routine for evaluating the constraints, and the
and the fourth argument is a pointer to a user-defined context.

The Jacobian of $c(x)$ is the matrix in $\Re^{m \times n}$ such that each 
column contains the partial derivatives of $c(x)$ with respect to one 
variable.  The evaluation of the Jacobian of $c$ should be performed 
by calling the 
\begin{verbatim}
   PetscErrorCode JacobianState(TaoSolver,Vec,Mat*,Mat*,Mat*,
                     MatStructure*, void*);
   PetscErrorCode JacobianDesign(TaoSolver,Vec,Mat*,void*);
\end{verbatim}
routines. 
In these functions, the second argument is the variable vector at which to 
evaluate the Jacobian matrix, the third argument is the Jacobian matrix,
and the last argument is a pointer to a user-defined context. The fourth
and
fifth arguments of the Jacobian evaluation with respect to the state
variables
are for providing PETSc matrix objects for the preconditioner on for
applying
the inverse of the state Jacobian.  This inverse matrix may be 
{\tt PETSC\_NULL}, in which case TAO will use a PETSc KSP method to
solve the state system.  These evaluation routines should be registered 
with TAO using the 
\begin{verbatim}
   TaoSetJacobianStateRoutine(TaoSolver,Mat,Mat,Mat,
                     PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,
                     MatStructure*,void*), void*);
   TaoSetJacobianDesignRoutine(TaoSolver,Mat,
                     PetscErrorCode (*)(TaoSolver,Vec,Mat*,void*), 
                     void*);
\end{verbatim}
routines. 
The first argument is the TAO solver object, the second argument is the
matrix 
in which the Jacobian information can be stored.  For the state Jacobian,
the 
third argument is the matrix that will be used for preconditioning and the 
fourth argument is an optional matrix for the inverse of the state
Jacobian.
One can use {\tt PETSC\_NULL} for this inverse argument and let PETSc
apply 
the inverse using a KSP method, but faster results may be obtained by
manipulating the structure of the Jacobian and providing an inverse.
The fifth argument is the function pointer, and the sixth argument is
an optional user-defined context.  Since no solve is performed with the
design Jacobian, there is no need to provide preconditioner or inverse
matrices.


\subsection{Nonlinear Least Squares}\label{sec:evalsof}
In the case of nonlinear least square applications, we are solving
the optimization problem
\[
\begin{array}{ll}
\displaystyle \min_{x} & \displaystyle \sum_i (f_i(x) - d_i)^2
\end{array}
\]
For these problems, the objective function value should be computed as a 
vector of residuals, $f_i(x) - d_i$, for better algorithmic results using 
a separable objective function, computed with a function of the form
\begin{verbatim}
   PetscErrorCode EvaluateSeparableFunction(TaoSolver,Vec,Vec,void*);
\end{verbatim}
and set with the
\begin{verbatim}
   TaoSetSeparableObjectiveRoutine(TaoSolver,
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                     void *);
\end{verbatim}
routine.

\begin{comment}
The computation of the Jacobian of the separable objective routine 
should be in a routine that looks like
\begin{verbatim}
   PetscErrorCode EvaluateJacobian(TaoSolver,Vec,Mat*,Mat*,MatStructure*,
                     void*);
\end{verbatim}
This function can be registered with TAO using the function
\begin{verbatim}
   TaoSetJacobianRoutine(TaoSolver,Mat J, Mat Jpre,
                     PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,
                     MatStructure*,void*), void *);
\end{verbatim}
The first argument is the TAO solver object, the second and third arguments
are the Mat object where the Jacobian will be stored and the Mat object
that will be used for the preconditioning (they may be the same). The
fourth 
argument is the function that evaluates the Jacobian, 
and the fifth argument is a pointer to a user defined context,
cast as a {\tt void*} pointer.
\end{comment}



\subsection{Complementarity}
Complementarity applications have equality constraints in the form of 
nonlinear equations 
$C(X) = 0$, where $C: \Re^n \to \Re^m$.
These constraints should be specified in a 
routine written by the user with the form
\begin{verbatim}
   PetscErrorCode EqualityConstraints(TaoSolver,Vec,Vec,void*);
\end{verbatim}
that evaluates {\tt C(X)}.
\noindent
The first argument of this routine is a TAO solver object.  The second argument
is the variable vector $X$ at which the constraint function should be 
evaluated.  
The third argument is the output vector of function values $C(X)$, and the fourth
argument is a pointer to a user-defined context.

This routine and the user-defined context 
must be registered with TAO by using the
\findex{TaoSetConstraintsRoutine()}
\begin{verbatim}
   TaoSetConstraintRoutine(TaoSolver, Vec,
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                     void*);
\end{verbatim}
command. 
\noindent
In this command, the first argument is TAO Solver object,
the second argument is vector in which to store the function values,
the third argument is the user-defined routine that evaluates $C(X)$,
and the fourth argument is a pointer to a user-defined context that will
be passed back to the user.

The Jacobian of the function is the matrix in $\Re^{m \times n}$
such that each column contains the partial derivatives of {\tt f} with respect
to one variable. 
The evaluation of the Jacobian of $C$ should be performed in a routine
of the form
\begin{verbatim}
   PetscErrorCode EvaluateJacobian(TaoSolver,Vec,Mat*,Mat*,MatStructure*,
                     void*);
\end{verbatim}
\noindent
In this function, the first argument is the TAO Solver object and the 
second argument is the variable vector at which to evaluate the 
Jacobian matrix. The third argument is the Jacobian matrix,
and the sixth argument is a pointer to a user-defined context.
Since the Jacobian matrix may be used in solving a system of linear equations,
a preconditioner for the matrix may be needed.  The fourth argument is the matrix that will be used
for preconditioning the linear system.  In most cases, this
matrix will be the same as the Hessian matrix.  The fifth
argument is the flag used to set the Jacobian matrix and
linear solver in the routine {\tt KSPSetOperators()}.

This routine should be specified to TAO using the
\findex{TaoAppSetJacobianRoutine()}
\begin{verbatim}
   TaoSetJacobianRoutine(TaoSolver,Mat J, Mat Jpre,
                     PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*, 
                     MatStructure*,void*), void*);
\end{verbatim}
\noindent
command.
The first argument is the TAO Solver object, the second
and third arguments are the Mat objects in which the Jacobian will be stored
and the Mat object that will be used for the preconditioning (they may
be the same).
the fourth argument is the function pointer, and the fifth argument is
an optional user-defined context.
The Jacobian matrix should be created in a way such that the product of 
it and the variable vector can be stored in the constraint vector.




\section{Using FORTRAN}
\label{chapter:fortran}
Most of the functionality of TAO can be accessed from Fortran 77 or 
Fortran 90.  Note, however, that we recommend the use of C and/or C++ 
because these languages contain several extremely powerful concepts 
that Fortran 77/90 does not.  The TAO Fortran interface works with 
both F77 and F90 compilers.

Since Fortran77 does not provide type checking of routine input/output
parameters, we find that many errors encountered within TAO Fortran
programs result from accidentally using incorrect calling sequences.
Such mistakes are immediately detected during compilation when using
C/C++.  Thus, using a mixture of C/C++ and Fortran often works well
for programmers who wish to employ Fortran for the core numerical
routines within their applications.  In particular, one can
effectively write TAO driver routines in C/C++, thereby preserving
flexibility within the program, and still use Fortran when desired for
underlying numerical computations.

% \section{Differences between TAO Interfaces for C and Fortran}

Only a few differences exist between the C and Fortran TAO interfaces,
all of which are due to differences in Fortran syntax.  All Fortran
routines have the same names as the corresponding C versions, and
command line options are fully supported. The routine arguments follow
the usual Fortran conventions; the user need not worry about passing
pointers or values.  The calling sequences for the Fortran version are
in most cases identical to the C version, except for the error
checking variable discussed in Section \ref{sec:fortran_errors}.  In
addition, the Fortran routines {\tt TaoInitialize(character(*) filename,int ierr)} and {\tt TaoGetConvergenceHistory()}
differ slightly from their C counterparts; see the manual page for
details.

\subsection{Include Files}
\label{sec:fortran_includes}

TAO users must employ the Fortran file suffix {\tt .F}
rather than {\tt .f}.  This convention enables use of the CPP
preprocessor, which allows the use of the {\em \#include} statements
that define TAO objects and variables. (Familiarity with the CPP
preprocessor is not needed for writing TAO Fortran code; one can
simply begin by copying a TAO Fortran example and its corresponding
makefile.)  

The TAO directory {\tt \$\{TAO\_DIR\}/include/finclude}
contains the Fortran include files
and should be used via statements 
such as 
\begin{verbatim}
   #include "include/finclude/petscvec.h"
\end{verbatim}
Since one must be very careful to include each file no more than once
in a Fortran routine, application programmers must manually include
each file needed for the various TAO (or other supplementary)
components within their program.  This approach differs from the TAO
C interface, where the user need only include the highest level
file, for example, {\tt tao.h}, which then automatically
includes all of the required lower level files.  As shown in the
various Fortran example programs in the TAO distribution, in Fortran
one must explicitly list {\em each} of the include files.


\subsection{Error Checking}
\label{sec:fortran_errors}

In the Fortran version, each TAO routine has as its final argument
an integer error variable, in contrast to the C/C++ interface convention 
of providing the error variable as the routine's return value.  The error
code is set to be nonzero if an error has been detected; otherwise, it
is zero.  For example, the Fortran and C variants of {\tt TaoSolve()} are
given, respectively, as 
\begin{verbatim}
   call TaoSolve(TaoSolver tao, PetscErrorCode ierr)
   ierr = TaoSolve(TaoSolver tao)
\end{verbatim}
where {\tt ierr} denotes the error variable.

Fortran programmers can use the error codes in writing their own
tracebacks.  For example, one could use code such as 
\begin{verbatim}
   call TaoSolve(tao, ierr)
   if (ierr .ne. 0) then
       print *, 'Error in routine ...'
       return
   endif
\end{verbatim}
to define such a traceback. 
In addition, Fortran programmers can check these error codes with the
macro {\tt CHKERRQ()}, which terminates all process when an error
is encountered.  See the PETSc user manual for details.  The most
common reason for crashing TAO or PETSc Fortran code is forgetting 
the final {\tt ierr} argument.

\subsection{Compiling and Linking Fortran Programs}
\label{sec:fortcompile}

Figure \ref{fig:make4} shows a sample makefile that can be used for
TAO Fortran programs.  A debugging version of the program 
{\tt rosenbrock1f} can be compiled with {\tt make rosenbrock1f}.

\begin{figure}[tbh]
{\footnotesize
\begin{verbatim}   
       CFLAGS    = 
       FFLAGS    = 
       CPPFLAGS  =
       FPPFLAGS  =
       
       include ${TAO_DIR}/conf/tao_base
   
       rosenbrock1f: rosenbrock1f.o  tao_chkopts
                 -${FLINKER} -o rosenbrock1f rosenbrock1f.o ${TAO_LIB} ${PETSC_LIB}
        ${RM} rosenbrock1f.o
\end{verbatim} % $
\noindent
}
\caption{Sample TAO makefile for a single Fortran program}
\label{fig:make4}
\end{figure}

\subsection{Additional Issues}

The TAO library interfaces to the PETSc library for
low-level system functionality as well as linear algebra support.  The
PETSc users manual discusses additional Fortran issues in these areas,
including
\begin{itemize}
\item array arguments (e.g., {\tt VecGetArray()}),
\item calling Fortran Routines from C (and C Routines from Fortran),
\item passing null pointers,
\item duplicating multiple vectors, and
\item matrix and vector indices.
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual_tex"
%%% End: 
