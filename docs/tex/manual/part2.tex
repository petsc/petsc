%
% NOTES:  
%  - Be sure to place captions BEFORE labels in figures and tables!
%    Otherwise, numbering will be incorrect.  For example, use the following:
%       \caption{TAO Info}
%       \label{fig:taoinfo}
%  - Use \break to indicate a line break (needed to prevent long strings in
%    \tt mode from running of the page)
%
% ---------------------------------------------------------------

\chapter{Using TAO Solvers}
%\sindex{continuous optimization}
\label{chapter:tao_solver}

TAO contains unconstrained minimization, bound constrained minimization, 
and nonlinear least squares solvers.
The structure of these problems can differ significantly, 
but TAO has a similar interface to all of its solvers.  
Routines that most solvers have in common will be discussed in 
this chapter.
A complete list of options can be found by consulting the manual pages.
Many of the options can also be set at the command line.  These options
can also be found in manual pages or by
running a program with the {\tt -help} option.


\section{Initialize and Finalize}
The first TAO routine in any application should be {\tt TaoInitialize()}.
Most TAO programs begin with a call to
\findex{TaoInitialize()}
\begin{verbatim}
   TaoInitialize(int *argc,char ***argv,char *filename, 
                        char *help_message);
\end{verbatim}
\noindent
This command initializes TAO, as well as MPI, PETSc, and other packages
to which TAO applications may link (if these have not yet
been initialized elsewhere).  
In particular, the arguments {\tt argc} and 
{\tt argv} are the command line arguments delivered in all C and C++
programs; these arguments initialize the options database.  
\sindex{command line arguments} The argument {\tt filename}
optionally indicates an alternative name for an options file, which by
default is called {\tt .petscrc} and resides in the user's home directory.

One of the last routines\findex{TaoFinalize()} that all TAO programs should 
call is 
\begin{verbatim}
   TaoFinalize();
\end{verbatim}
\noindent
This routine finalizes TAO and any other libraries that may have been
initialized during the {\tt TaoInitialize()} phase.
For example, {\tt TaoFinalize()}
calls {\tt PetscFinalize()} 
if {\tt TaoInitialize()}
began PETSc. If PETSc was initiated externally from TAO (by either
the user or another software package), then the user is
responsible for calling {\tt PetscFinalize()}. 

In Fortran, the initialization and finalization commands are
\begin{verbatim}
  call TaoInitialize(filename, ierr)
  call TaoFinalize(ierr)
\end{verbatim}

\section{Creation and Destruction}

A TAO solver can be created with
the command 
\findex{TaoSolverCreate()}
\begin{verbatim}
   ierr = TaoSolverCreate(MPI_Comm comm,TaoSolver *newsolver);
\end{verbatim}
\noindent
Much like creating PETSc vector and matrix objects, 
the first argument is an MPI {\em communicator}.
An MPI \cite{using-mpi} communicator
indicates a collection of processors that will be used to evaluate the
objective function, compute constraints, and provide derivative information.
When only one processor is being used, the communicator {\tt PETSC\_COMM\_SELF}
can be used with no understanding of MPI.
Even parallel users need to be familiar with only the basic concepts 
of message passing and  distributed-memory computing. 
Most applications running TAO in
parallel environments can employ the communicator {\tt
PETSC\_COMM\_WORLD} to indicate all processes known to PETSc in a given run.

The routine
\findex{TaoSolverSetType()}
\begin{verbatim}
   ierr = TaoSolverSetType(TaoSolver tao, TaoType type);
\end{verbatim}
\noindent
can be used to set the algorithm TAO uses to solve the application.
The various types of TAO solvers and the flags that identify them 
will be discussed in the following chapters.
The solution method should be carefully chosen depending upon
the problem that is being solved.  Some solvers, for instance, are meant for
problems with no constraints, while other solvers acknowledge constraints
in the problem and solve them accordingly.
The user must also be aware of the derivative information that is available.
Some solvers require second-order information, while other solvers require
only gradient or function information.
The command line option \texttt{-tao\_method} (or equivalently 
\texttt{-tao\_type}) followed by an TAO method
will override any method specified by the second argument.
The command line option {\tt -tao\_method tao\_lmvm}, for instance,
will specify the limited memory variable metric method for unconstrained
optimization.  Note that the {\tt TaoType} variable is a string that requires
quotation marks in an application program, but quotation marks are not required
at the command line.

Each TAO solver that has been created should also be destroyed using
the command 
\findex{TaoSolverDestroy()}
\begin{verbatim}
   ierr = TaoSolverDestroy(TaoSolver tao);
\end{verbatim}
\noindent 
This routine frees the internal data structures used by the solver.


\section{TAO Applications}
\sindex{application}
\label{section:taoapplication}
\label{section:petscapp}

The solvers in TAO address applications that have a set of variables, an objective
function, and constraints on the variables.  Many solvers also require derivatives
of the objective and constraint functions.
To use the TAO solvers, the application developer must 
define a set of variables, implement routines that evaluate the 
objective function and constraint functions, and pass this information
to a TAO application object.   

TAO uses vector and matrix objects to pass this information from the
application to the solver.   The set of variables, for instance, is
represented in a vector.
The gradient of an objective function $f: \, \Re^n \to \Re$,
evaluated at a point, is also represented as a vector.
Matrices,  on the other hand,
can be used to represent the Hessian of $f$ or the Jacobian of a constraint
function $c: \, \Re^n \to \Re^m$.  The TAO solvers use
these objects to compute a solution to the application.

The PETSc package provides parallel and serial implementations of these
objects and offers additional tools intended for high-performance 
scientific applications.
The {\bf Vec} and {\bf Mat} types in PETSc
represent the vectors and matrices in a TAO application.
This chapter will describe how to create these an application object
and give it the necessary properties.  This chapter will also describe how to use
the TAO solvers in conjunction with this application object.

\section{Header File}

TAO applications written in C/C++ should have the statement 
\begin{verbatim}
   #include "tao.h"
\end{verbatim}
\noindent
in each file that uses a routine in the TAO libraries.
All of the required lower level include files such as ``taosolver.h''
and ``tao\_sys.h''
are automatically included within this high-level file.


\section{Defining Variables}
In all of the optimization solvers, the application must provide
a {\bf Vec} object of appropriate dimension to represent the variables.
This vector will be cloned by the solvers to create additional work
space within the solver.
If this vector is distributed over multiple processors, it
should have a parallel distribution that allows
for efficient scaling, inner products, and
function evaluations.  This vector can be passed to the
application object using the routine \findex{TaoAppSetInitialSolutionVec()}
\begin{verbatim}
   TaoSolverSetInitialVector(TaoSolver,Vec);
\end{verbatim}
When using this routine, the application should initialize the vector with
an approximate solution of the optimization problem before calling the
TAO solver.
This vector will be used by the TAO solver to store the solution.
Elsewhere in the application, 
this solution vector can be retieved from the application object 
using the routine \findex{TaoSolverGetSolutionVector()}
\begin{verbatim}
   TaoSolverGetSolutionVector(TaoSolver, Vec *);
\end{verbatim}
This routine takes the address of a {\tt Vec} in the second argument and sets it to
the solution vector used in the application.

\section{Application Context}  \sindex{application context}
Writing a TAO application may require
use of an {\em application context}.
An application context is a structure or object defined by an
application developer, passed
into a routine also written by the application developer, 
and used within the routine to perform its stated task.
 
For example, a routine that evaluates an objective function may need
parameters, work vectors, and other information.   This information,
which may be specific to an application and necessary to evaluate the objective,
can be collected in a single structure and used as one of the
arguments in the routine.
The address of this structure will be cast as type {\tt (void*)} and passed to
the routine in the final argument.
There are many examples of these structures in the examples included in the
TAO distribution.

This technique offers several advantages.
In particular, it allows for a uniform interface between TAO and 
the applications.   The fundamental information needed by TAO 
appears in the arguments of the routine, while data specific to an application
and its implementation is confined to an opaque pointer.
The routines can access information created outside the 
local scope without the use of global variables.
The TAO solvers and application objects will never access this structure, 
so the application developer has complete freedom to define it.  In fact,
these contexts are completely optional -- a NULL pointer can be used.



\section{Objective Function and Gradient Routines}\label{sec:fghj}

TAO solvers that minimize an objective function require
the application to evaluate the objective function.  Some solvers
may also require the application to evaluate
derivatives of the objective function.  
Routines that perform these computations must be identified
to the application object and must follow a strict calling sequence.

Routines that evaluate an objective function $f: \, \Re^n \to \Re$,
should follow the form:
\begin{verbatim}
   EvaluateObjective(TaoSolver,Vec,PetscReal*,void*);
\end{verbatim}
\noindent
The first argument is the TAO Solver object, the second argument is the
$n$-dimensional vector that identifies where the objective should be evaluated, 
and the fourth argument is an application context.
This routine should use the third argument to return the objective value 
evaluated at the point
specified the by the vector in the second argument.

This routine, and the application context, should be passed to the 
application object using
the routine \findex{TaoSolverSetObjectiveRoutine()}
\begin{verbatim}
   TaoAppSetObjectiveRoutine(TaoSolver,
                             PetscErrorCode(*)(TaoSolver,Vec,PetscReal*,void*),
                             void*);
\end{verbatim}
\noindent
The first argument in this routine is the TAO solver object, 
the second argument is a function pointer to the routine that 
evaluates the objective, and the third
argument is the pointer an appropriate application context.  

Although final argument may point to anything, it must be cast as a {\tt (void*)} type.
This pointer will be passed back to the developer in the fourth argument of the
routine that evaluates the objective.  In this routine, the pointer can be cast
back to the appropriate type.  Examples of these structures and there usage
are provides in the distribution.


   Most TAO solvers also require gradient information from the 
application \sindex{gradients}.
  The gradient of the objective function can be specified in a similar manner.
Routines that evaluate the gradient should have the calling sequence
\begin{verbatim}
   EvaluateGradient(TaoSolver,Vec,Vec,void*);
\end{verbatim}
\noindent
In this routine, the first
argument is the TAO solver object, the second argument is the variable
vector, the third argument is the gradient vector, and the fourth argument is
the user-defined application context.  Only the third argument in this
routine is different from the arguments in the routine that evaluates
the objective function.  The numbers in the gradient vector have no
meaning when passed into this routine, but should represent the gradient
of the objective at the specified point at the end of the routine.
This routine, and the user-defined pointer, can be passed to the application
object using the routine: \findex{TaoSolverSetGradientRoutine()}
\begin{verbatim}
   TaoSolverSetGradientRoutine(TaoSolver,
                            PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                            void *);
\end{verbatim}
\noindent
In this routine, the first argument is the TaoSolver object, the second argument
is the function pointer, and the third object is the application context, cast
to {\tt (void*)}.

   Instead of evaluating the objective and its gradient in separate
routines, TAO also allows the user to evaluate the function and the gradient
at the same routine.  In fact, some solvers are more efficient when
both function and gradient information can be computed in the same routine.
These routines should follow the form
\begin{verbatim}
   EvaluateFunctionAndGradient(TaoSolver,Vec,PetscReal*,Vec,void*);
\end{verbatim}
\noindent
where the first
argument is the TAO solver, and the second
argument points to the input vector for use in evaluating the
function and gradient. The third argument should return the
function value, while the fourth argument should return the gradient vector,
and the fifth argument is a pointer to a user-defined context.
This context and the name of the routine should be set with the
call: \findex{TaoSolverSetObjectiveAndGradientRoutine()}
\begin{verbatim}
   TaoSolverSetObjectiveAndGradientRoutine(TaoSolver,
                     PetscErrorCode (*)(TaoSolver,Vec,PetscReal*,Vec,void*),
                     void *);
\end{verbatim}
\noindent
The arguments of this routine are the TAO application, a
function name, and a pointer to a user-defined context.


The TAO example problems demonstrate the use of these application contexts
as well as specific instances of function, gradient, and Hessian 
evaluation routines.
All of these routines should return the integer $0$ after 
successful completion and a nonzero integer if the function
is undefined at that point or an error occurred.

\section{Hessian Evaluation}
\label{sec:matrixfree}
\label{sec:finitedifference}

Some optimization routines also require a Hessian matrix from the user.
The routine that evaluates the Hessian should have the form:
\begin{verbatim}
   EvaluateHessian(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*);
\end{verbatim}
\noindent
The first argument of this routine is a TAO solver object.  The second
argument is the point at which the Hessian should be evaluated.  The
third argument is the Hessian matrix, and the sixth argument is a
user-defined context.
Since the Hessian matrix is usually used in solving
a system of linear equations, a preconditioner for the matrix is often
needed.  The fourth argument is the matrix that will be used
for preconditioning the linear system.  In most cases, this
matrix will be the same as the Hessian matrix.  The fifth
argument is the flag used to set the Hessian matrix and
linear solver in the routine {\tt KSPSetOperators()}.

One can set the Hessian evaluation routine by calling \sindex{Hessian}
\findex{TaoSolverSetHessianRoutine()}
\begin{verbatim}
   PetscErrorCode TaoSolverSetHessianRoutine(TaoSolver,Mat H, Mat Hpre,
                PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*),
                void *);
\end{verbatim}
\noindent
The first argument is the TAO application, the second and third arguments
are the Mat object where the Hessian will be stored and the Mat object
that will be used for the preconditioning (they may be the same). The fourth 
argument is the function that evaluates the Hessian, 
and the fifth argument is a pointer to a user defined context,
cast as a {\tt void*} pointer.

\subsection{Finite Differences} \sindex{finite differences}
Finite differences approximations can be used to compute the gradient and the
Hessian of an objective
function.  These approximations will slow down the solve considerably and are only 
recommended for checking the accuracy of hand-coded gradients and Hessians.
These routines are 

\findex{TaoSolverDefaultComputeGradient()}
\begin{verbatim}
  TaoSolverDefaultComputeGradient(TaoSolver, Vec, Vec, void*);
\end{verbatim}


\findex{TaoSolverDefaultComputeHessian()}
\begin{verbatim}
   TaoSolverDefaultComputeHessian(TaoSolver, Vec, Mat*, Mat*, 
                                MatStructure*, void*);
\end{verbatim}
\noindent
and \findex{TaoSolverDefaultComputeHessianColor()}
\begin{verbatim}
   TaoSolverDefaultComputeHessianColor(TaoSolver, Vec, Mat*, Mat*, 
                                      MatStructure*, void* );
\end{verbatim}
\noindent
These routines can be set using {\tt TaoSolverSetGradientRoutine()} and 
{\tt TaoSolverSetHessianRoutine()} or through the options database.
If finite differencing is used with coloring, the routine \findex{TaoSolverSetColoring()}
\begin{verbatim}
   TaoSolverSetColoring(TaoSolver, ISColoring);
\end{verbatim}
\noindent
should be used to specify the coloring.

It is also possible to use finite difference approximations to directly check
the correctness of an application's gradient and/or Hessian evaluation routines.
This can be done from the command lineusing the special TAO solver 
{\tt tao\_fd\_test} together with the options
{\tt -tao\_test\_gradient} or {\tt -tao\_test\_hessian}.


\subsection{Matrix-Free methods}
TAO fully supports matrix-free methods. The matrices specified in the
Hessian evaluation routine need not be conventional
matrices; instead, they can point to the data required to implement a
particular matrix-free method.  The matrix-free variant is allowed
{\em only} when the linear systems are solved by an iterative method
in combination with no preconditioning ({\tt PCNONE} or {\tt -pc\_type none}),
a user-provided preconditioner matrix, or a user-provided preconditioner
shell ({\tt PCSHELL}); that is,
obviously matrix-free methods cannot be used if a direct solver is to 
be employed. \sindex{matrix-free options} %\findex{PCSHELL}
Details about using matrix-free methods are provided in the
PETSc  Users Manual.


\section{Bounds on Variables}\label{sec:bounds}

Some optimization problems also impose constraints upon the variables.
The constraints may impose simple bounds upon the variables, or
require that the variables satisfy a set of linear or  nonlinear equations.

The simplest type of constraint upon an optimization problem puts lower
or upper bounds upon the variables. 
Vectors that represent lower and upper bounds for each variable 
can be set with the command  \sindex{bounds}\findex{TaoSolverSetVariableBounds}
\begin{verbatim}
   TaoSolverSetVariableBounds(TaoSolver,Vec,Vec);
\end{verbatim}
\noindent
The first vector and second vectors should contain the lower and upper 
bounds, respectively.
When no upper or lower bound exists for a variable, the bound
may be set to {\tt TAO\_INFINITY} or {\tt TAO\_NINFINITY}.
After the two bound vectors have been set, they may be accessed with the
with the command  {\tt TaoSolverGetVariableBounds()}.

Alternatively, it may be more convenient for the user to designate a routine 
for computing these bounds
that the solver will call before starting its algorithm.  This routine will
have the form
\begin{verbatim}
   ComputeBounds(TaoSolver,Vec,Vec,void*);
\end{verbatim}
where the two vectors, representing the lower and upper bounds respectfully, 
will be computed.

This routine can be set with the command
\begin{verbatim}
   TaoSolverSetVariableBoundsRoutine(TaoSolver
                          PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),void*);
\end{verbatim}
   
Since not all solvers use bounds on variables, the user must be careful 
to select a type of solver that acknowledges these bounds.

\section{Nonlinear Least Squares}
In the case of nonlinear least-square applications, the objective function
value should be computed as a vector of residuals for better algorithmic 
results.  This can be done by using a separable objective function, computed
with a function of the form
\begin{verbatim}
  EvaluateSeparableFunction(TaoSolver,Vec,Vec,void*);
\end{verbatim}
and set with
\begin{verbatim}
  TaoSolverSetSeparableObjectiveRoutine(TaoSolver,
                     PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                     void *);
\end{verbatim}

The computation of the Jacobian of the separable objective routine 
should be in a routine that looks like
\begin{verbatim}
   EvaluateJacobian(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*);
\end{verbatim}
This function can be registered with TAO using the function
\begin{verbatim}
   PetscErrorCode TaoSolverSetJacobianRoutine(TaoSolver,Mat J, Mat Jpre,
                PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*),
                void *);
\end{verbatim}
The first argument is the TAO solver object, the second and third arguments
are the Mat object where the Jacobian will be stored and the Mat object
that will be used for the preconditioning (they may be the same). The fourth 
argument is the function that evaluates the Jacobian, 
and the fifth argument is a pointer to a user defined context,
cast as a {\tt void*} pointer.

\section{PDE-Constrained Applications}\label{sec:pde_applications}
TAO can solve PDE-constrained optimization applications 
that have the form

We are interested in solving optimization problems of the form
\[
\begin{array}{ll}
\displaystyle \min_{u,v} & f(u,v) \\
\mbox{subject to} & g(u,v) = 0
\end{array}
\]
where the state variable $u$ is the solution to the partial differential 
equation defined by $g$ and parametrized by the design variable $v$, and 
$f$ is an objective function.  


In this case, the user needs to set routines for computing the objective,
gradient, constraints, jacobian with respect to the state variables, 
and jacobian with
respect to the design variables.  TAO also needs to know which variables
in the solution vector are state variables, and which are design variables.

The objective and gradient routines are set as for other TAO applications,
with {\tt TaoSolverSetObjectiveRoutine()} and {\tt TaoSolverSetGradientRoutine}.
These vectors include the combined state and design variables, the index set
containing the state variables must be passed to TAO using the function
\begin{verbatim}
  TaoSolverSetStateIS(TaoSolver, IS)
\end{verbatim}
where the IS is a PETSc Index Set describing which of the variables in the 
solution vector are state variables.

Constraints in the form of nonlinear equations have the form
$C(X) = 0$ where $C: \Re^n \to \Re^m$.
These constraints should be specified in a 
routine, written by the user, that evaluates {\tt C(X)}.
The routine that evaluates the constraint equations should have the form:
\begin{verbatim}
   PetscErrorCode EqualityConstraints(TaoSolver,Vec,Vec,void*);
\end{verbatim}
\noindent
The first argument of this routine is a TAO solver object.  The second argument
is the variable vector at which the constraint function should be evaluated.  
The third argument is the vector of function values {\tt C}, and the fourth
argument is a pointer to a user-defined context.
This routine  and the user-defined context 
should be set in the TAO solver with the command
\findex{TaoSolverSetConstraintsRoutine()}
\begin{verbatim}
   TaoSolverSetConstraintRoutine(TaoSolver,
                           PetscErrorCode (*)(TaoSolver,Vec,Vec,void*),
                           void*);
\end{verbatim}
\noindent
In this function, first argument is the TAO solver object,
the second argument is vector where the constraints routine should be
evaluated, the third argument is a vector in which to store the constraints,
and the fourth argument is a pointer to a user-defined context that will
be passed back to the user.

The Jacobian of the function {\tt C} is the matrix in $\Re^{m \times n}$
such that each column contains the partial derivatives of {\tt f} with respect
to one variable. 
The evaluation of the Jacobian of {\tt f} should be performed in routines
of the form
\begin{verbatim}
   PetscErrorCode JacobianState(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*);
   PetscErrorCode JacobianDesign(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*);
\end{verbatim}
\noindent
In this function, the second argument is the variable vector at which to 
evaluate the Jacobian matrix, the third argument is the Jacobian matrix,
and the sixth argument is a pointer to a user-defined context.
This routine should be specified using
\begin{verbatim}
   TaoSolverSetJacobianStateRoutine(TaoSolver,Mat,Mat,
              PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*), 
              void*);
   TaoSolverSetJacobianDesignRoutine(TaoSolver,Mat,Mat,
              PetscErrorCode (*)(TaoSolver,Vec,Mat*,Mat*,MatStructure*,void*), 
              void*);
\end{verbatim}
\noindent
The first argument is the TAO solver object, the second
argument is the matrix in which the information can be stored,
the third argument is the matrix that will be used for preconditioning,
the fourth argument is the function pointer, and the fifth argument is
an optional user-defined context.

\section{Monitors}

By default the TAO solvers run silently without displaying information
about the iterations. The user can initiate monitoring with the
command \findex{TaoSolverSetMonitor()} 
\begin{verbatim}
   PetscErrorCode TaoSolverSetMonitor(TaoSolver,
                     PetscErrorCode (*mon)(TaoSolver tao,void* mctx),
                     void *mctx);
\end{verbatim}
\noindent

The routine, {\tt mon} indicates a user-defined monitoring routine
and {\tt mctx} denotes an optional user-defined context for private 
data for the monitor routine.

The routine set by {\tt TaoSolverSetMonitor()} is called once during each
iteration of the optimization solver.  Hence, the
user can employ this routine for any application-specific computations
that should be done after the solution update. 
\findex{TaoSolverSetMonitor()}.
\begin{verbatim}
   TaoSolverSetMonitor(TaoSolver,
                    PetscErrorCode (*)(TaoSolver,void*),void *);
\end{verbatim}



% This linear solver object has a method
% that allows the user to adjust convergence tolerances.
% Alternatively, the
% specific data structures of the linear solver can be accessed and modified
% directly.
% comment from Lois: I don't like the wording of this last sentence.
\section{Linear Solvers}\label{sec:TaoLinearSolvers}
One of the most computationally intensive phases of many optimization
algorithms involves the solution of systems of linear equations.  
The performance
of the linear solver may be critical to an efficient computation
of the solution.
Since linear equation solvers often have a wide variety of options 
associated with them, TAO allows the user to access the linear
solver with the command

\findex{TaoSolverGetKSP()}
\begin{verbatim}
   TaoSolverGetKSP(TaoSolver, KSP *);
\end{verbatim}

\noindent
With access to the KSP object, users can customize it for their application
to achieve additional performance.


\section{Options}
Options for the TAO solver 
can be be set from the command line using the routine \sindex{options} \findex{TaoSetOptions()}
\begin{verbatim}
   TaoSolverSetFromOptions(TaoSolver)
\end{verbatim}
This command also provides information about runtime options when the
user includes the {\tt -help } option on the
command line.

\section{Solving}
Once the application and solver have been set up, the solver can be called using the routine
\findex{TaoSolverSolve()}
\begin{verbatim}
   TaoSolverSolve(TaoSolver);
\end{verbatim}
\noindent
This  routine will call the TAO solver. 
After exiting this function, the solution, gradient, and dual variables (if
available) can be
recovered with the routines:
\begin{verbatim}
   TaoSolverGetSolutionVector(TaoSolver, Vec*);
   TaoSolverGetGradientVector(TaoSolver, Vec*);
   TaoSolverComputeDualVariables(TaoSolver, Vec X, Vec Duals);
\end{verbatim}
\noindent
Note that the {\tt Vec} returned by {\tt TaoSolverGetSolutionVector} will be
the same vector passed in to {\tt TaoSolverSetInitialVector}.



\section{Compiling and Linking}

Portable TAO makefiles follow the rules and definitions
of PETSc makefiles.
In Figures \ref{fig:make3} we present a sample makefile.

\begin{figure}[tbh]
{\footnotesize
\begin{verbatim}   
       CFLAGS    = 
       FFLAGS    = 
       CPPFLAGS  =
       FPPFLAGS  =
       
       include ${TAO_DIR}/conf/tao_base
   
       minsurf1: minsurf1.o tao_chkopts
            -${CLINKER} -o minsurf1 minsurf1.o ${TAO_LIB} ${PETSC_LIB}
            ${RM} minsurf1.o
\end{verbatim} 
% $
\noindent
}
\caption{Sample TAO makefile for a single C program}
\label{fig:make3}
\end{figure}

This small makefile is suitable for maintaining a single program that
uses the TAO library.  The most important line in this makefile is the
line starting with {\tt include}:

\begin{verbatim}
   include ${TAO_DIR}/conf/tao_base
\end{verbatim}
\noindent % $
\findex{TAO_LIB}
This line includes other makefiles that provide the needed definitions
and rules for the particular base software installations (specified by
{\tt \$\{TAO\_DIR\}} and {\tt \$\{PETSC\_DIR\}}) and architecture
(specified by {\tt \$\{PETSC\_ARCH\}}), which are typically set as
environmental variables prior to compiling TAO source or programs.  As
listed in the sample makefile, the appropriate {\tt include} file is
automatically completely specified; the user should {\em not} alter
this statement within the makefile.
 
TAO applications should be linked with the
to the {\tt PETSC\_LIB} library
as well as the {\tt TAO\_LIB} library. This version uses
PETSc 3.2, and the {\tt PETSC\_DIR} variable
should be set accordingly.  Many examples of makefiles
can be found in the {\tt examples} directories.


\section{TAO Applications using FORTRAN}
\label{chapter:fortran}
Most of the functionality of TAO can be obtained by people who program
purely in Fortran 77 or Fortran 90.  Note, however, that we recommend
the use of C and/or C++ because these languages contain several
extremely powerful concepts that the Fortran77/90 family does not.
The TAO Fortran interface works with both F77 and F90 compilers.

Since Fortran77 does not provide type checking of routine input/output
parameters, we find that many errors encountered within TAO Fortran
programs result from accidentally using incorrect calling sequences.
Such mistakes are immediately detected during compilation when using
C/C++.  Thus, using a mixture of C/C++ and Fortran often works well
for programmers who wish to employ Fortran for the core numerical
routines within their applications.  In particular, one can
effectively write TAO driver routines in C++, thereby preserving
flexibility within the program, and still use Fortran when desired for
underlying numerical computations.

% \section{Differences between TAO Interfaces for C and Fortran}

Only a few differences exist between the C and Fortran TAO interfaces,
all of which are due to differences in Fortran syntax.  All Fortran
routines have the same names as the corresponding C versions, and
command line options are fully supported. The routine arguments follow
the usual Fortran conventions; the user need not worry about passing
pointers or values.  The calling sequences for the Fortran version are
in most cases identical to the C version, except for the error
checking variable discussed in Section \ref{sec:fortran_errors}.  In
addition, the Fortran routine {\tt TaoInitialize(character(*) filename,int ierr)}
differs slightly from its C counterpart; see the manual page for
details.


\subsection{Include Files}
\label{sec:fortran_includes}

%  In Fortran the
%  initialization command has the form
%  \begin{verbatim}
%     call TaoInitialize(character file_name,integer info)
%  \end{verbatim}\noindent
%  \begin{verbatim}
%     call Finalize(integer info)
%  \end{verbatim}\noindent

Currently, TAO users must employ the Fortran file suffix {\tt .F}
rather than {\tt .f}.  This convention enables use of the CPP
preprocessor, which allows the use of the {\em \#include} statements
that define TAO objects and variables. (Familiarity with the CPP
preprocessor is not needed for writing TAO Fortran code; one can
simply begin by copying a TAO Fortran example and its corresponding
makefile.)  

The TAO directory {\tt \$\{TAO\_DIR\}/include/finclude}
contains the Fortran include files
and should be used via statements 
such as the following:
\begin{verbatim}
    #include "include/finclude/includefile.h"
\end{verbatim}
\noindent
Since one must be very careful to include each file no more than once
in a Fortran routine, application programmers must manually include
each file needed for the various TAO (or other supplementary)
components within their program.  This approach differs from the TAO
C++ interface, where the user need only include the highest level
file, for example, {\tt tao.h}, which then automatically
includes all of the required lower level files.  As shown in the
various Fortran example programs in the TAO distribution, in Fortran
one must explicitly list {\em each} of the include files.


\subsection{Error Checking}
\label{sec:fortran_errors}

In the Fortran version, each TAO routine has as its final argument
an integer error variable, in contrast to the C++ convention of
providing the error variable as the routine's return value.  The error
code is set to be nonzero if an error has been detected; otherwise, it
is zero.  For example, the Fortran and C++ variants of {\tt TaoSolverSolve()} are
given, respectively, below, where {\tt ierr} denotes the error variable:
\begin{verbatim}
   call TaoSolverSolve(TaoSolver tao, PetscErrorCode ierr)
   ierr = TaoSolverSolve(TaoSolver tao)
\end{verbatim}
\noindent

Fortran programmers can use the error codes in writing their own
tracebacks.  For example, one could use code such as the following:
\begin{verbatim}
   call TaoSolverSolve(tao, ierr)
   if (ierr .ne. 0) then
       print *, 'Error in routine ...'
       return
   endif
\end{verbatim}
\noindent
In addition, Fortran programmers can check these error codes with the
macro {\tt CHKERRQ()}, which terminates all process when an error
is encountered.  See the PETSc users manual for details.  The most
common reason for crashing PETSc Fortran code is forgetting the final
{\tt ierr} argument.

Additional interface differences for Fortran users:
\begin{itemize}
\item \texttt{TaoSolverGetConvergenceHistory()} -- returns only the number of 
elements in the history.  Storage for the convergence information must 
be preallocated by the user and then registered with 
\texttt{TaoSolverSetConvergenceHistory()}.
\end{itemize}

\subsection{Compiling and Linking Fortran Programs}
\label{sec:fortcompile}

Figure \ref{fig:make4} shows a sample makefile that can be used for
TAO Fortran programs.  You can compile a debugging
version of the program {\tt rosenbrock1f} with 
{\tt make rosenbrock1f}.

\begin{figure}[tbh]
{\footnotesize
\begin{verbatim}   
       CFLAGS    = 
       FFLAGS    = 
       CPPFLAGS  =
       FPPFLAGS  =
       
       include ${TAO_DIR}/conf/tao_base
   
       rosenbrock1f: rosenbrock1f.o  tao_chkopts
                 -${FLINKER} -o rosenbrock1f rosenbrock1f.o ${TAO_FORTRAN_LIB} ${TAO_LIB} \
                                ${PETSC_LIB}
        ${RM} rosenbrock1f.o
\end{verbatim} % $
\noindent
}
\caption{Sample TAO makefile for a single Fortran program}
\label{fig:make4}
\end{figure}

\noindent
Note that the TAO Fortran interface library, given by {\tt
\$\{TAO\_LIB\}}, {\em must} \findex{TAO_FORTRAN_LIB} precede
the base TAO library, given by {\tt \$\{TAO\_LIB\}}, \findex{TAO_LIB}
on the link line.

\subsection{Additional Issues}

The TAO library currently interfaces to the PETSc library for
low-level system functionality as well as linear algebra support.  The
PETSc users manual discusses additional Fortran issues in these areas,
including
\begin{itemize}
\item array arguments (e.g., {\tt VecGetArray()}),
\item calling Fortran Routines from C (and C Routines from Fortran),
\item passing null pointers,
\item duplicating multiple vectors, and
\item matrix and vector indices.
\end{itemize}




\section{Convergence}\label{sec:customize}

Although TAO and its solvers set default parameters 
that are useful
for many problems, it may be necessary for the user to modify these
parameters to change the behavior and convergence of various algorithms.

One convergence criterion for most algorithms concerns the
of digits of accuracy needed in the solution.  In particular,
the convergence test employed by TAO attempts to stop when
the error in the constraints is less than $\epsilon_{crtol}$,
 and either
\[
\begin{array}{lcl}
f(X) - f(X^*)  &\leq& \epsilon_{fatol}, \\
|f(X) - f(X^*)| / |f(X^*)| &\leq& \epsilon_{frtol},\\
||g(X)|| &\leq& \epsilon_{gatol}, \\
||g(X)||/|f(X)| &\leq& \epsilon_{grtol}, or \\
||g(X)||/|g(X_0)| &\leq& \epsilon_{gttol},
\end{array}
\]
where $X$ is the current approximation to the true solution $X^*$
and $X_0$ is the initial guess.
$X^*$ is unknown, so TAO estimates $f(X) - f(X^*)$ with either 
the square of the norm of the gradient or the duality gap.
A relative tolerance of $\epsilon_{frtol}=0.01$ indicates that two
significant digits are desired in the objective function.
Each solver sets its own  convergence tolerances, but they can
be changed using the routine
{\tt TaoSolverSetTolerances()}\findex{TaoSolverSetTolerances()} 
\sindex{convergence tests}. 
Another set of convergence tolerances 
terminate the solver when the norm of the gradient function
(or Lagrangian function for bound-constrained problems)
is sufficiently close to zero.

Other stopping criteria include a minimum trust region radius or 
a maximum number of iterations.  These parameters can be set with
the routines {\tt TaoSolverSetTrustRegionTolerance()}\sindex{trust region}\findex{TaoSolverSetTrustRegionTolerance}
and {\tt TaoSolverSetMaximumIterations()}\findex{TaoSolverSetMaximumIterations()}.
Similarly, a maximum number of function evaluations can be set 
with the command 
{\tt TaoSolverSetMaximumFunctionEvaluations()}
\findex{TaoSolverSetMaximumFunctionEvaluations()}.

\section{Viewing Solutions}

The routine
\begin{verbatim}
   ierr =  TaoSolverSolve(TaoSolver tao)
\end{verbatim}
\noindent
will apply the solver to the application that has been created by the user.

To see parameters and performance statistics for the solver, the
routine
\begin{verbatim}
   ierr = TaoSolverView(TaoSolver tao)
\end{verbatim}
can be used.  This routine will display to standard output the number
of function evaluations need by the solver and other information
specific to the solver.  This same output can be produced by using the 
command line option {\tt -tao\_view}.

The progress of the optimization solver can be monitored with
the runtime option {\tt -tao\_monitor}.  Although monitoring routines
can be customized, the default monitoring routine will print out 
several relevant statistics to the screen.

The user also has access to information about the current solution.
The current iteration number, objective function value, gradient
norm, infeasibility norm, and step length 
can be retrieved with the command 
\findex{TaoSolverGetSolutionStatus()}
\begin{verbatim}
   ierr = TaoSolverGetSolutionStatus(TaoSolver tao, PetscInt *iterate, 
                            PetscReal *f, PetscReal *gnorm, PetscReal *cnorm,
                            PetscReal *xdiff, TaoSolverTerminationReason *reason)
\end{verbatim}
\noindent
The last argument returns
a code that indicates the reason that the solver terminated.  Positive 
numbers indicate that a solution has been found, while negative numbers
indicate a failure.  A list of reasons can be found in the manual page
for {\tt TaoSolverGetTerminationReason()}.

The user set
vectors containing the solution before solving
the problem, but pointers to these vectors can also be retrieved with the
command {\tt TaoGetSolution()}\findex{TaoGetSolution()}.
Dual variables and other relevant information are also available. 
This information can be obtained during
user-defined routines such as a function evaluation and customized
monitoring routine, or after the solver has terminated.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual_tex"
%%% End: 
