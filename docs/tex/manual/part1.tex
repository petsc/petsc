\chapter{Getting Started}
\label{chapter:intro_tao}

TAO can be used on a personal
computer with a single processor or within a parallel environment.  
Its basic usage involves only a few commands, but fully 
understanding its usage requires time.
Application programmers can easily begin to use TAO by working with 
the examples provided and then gradually learn more details according to
their needs.  The current version of TAO and the most recent help 
concerning installation and usage can be found at  
\url{http://www.mcs.anl.gov/tao}.

TAO version 2.0 requires an ANSI C or C++ compiler and version 3.2 of PETSc, 
available at \url{http://www.mcs.anl.gov/petsc}.  PETSc must be configured 
without complex variables, but it is now possible for TAO to work when PETSc 
is configured without a C++ compiler or with single or quad precision 
arithmetic.

During setup, the user must set an environmental variable, 
\texttt{TAO\_DIR}\findex{TAO_DIR}, indicating the full path to 
the TAO home directory; this variable is used by the build
system when compiling TAO source code.  We use this variable in the
manual to refer to the location of files.

\section{Writing Application Codes with TAO}

Examples throughout the library demonstrate the software usage and
can serve as templates for developing custom applications.  We suggest
that new TAO users examine programs in
\begin{verbatim}
   ${TAO_DIR}/src/examples
\end{verbatim} % Needed to fool the xemacs coloring algorithm $
\noindent
Additional examples are available on our website and in
\begin{verbatim}
   ${TAO_DIR}/src/<unconstrained,bound,..>/examples/tutorials,
\end{verbatim} 
% $
\noindent
where \texttt{<component>}
denotes any of the TAO components, such as 
\texttt{bound} or \texttt{unconstrained}.
The HTML version of the manual pages located at
\begin{verbatim}
   ${TAO_DIR}/docs/manpages/index.html
\end{verbatim} % To fool the coloring algorithm $
\noindent
and
\begin{verbatim}
   http://www.mcs.anl.gov/tao/documentation/index.html
\end{verbatim}
\noindent
provides indices (organized by both routine names and concepts) to the
tutorial examples.

We suggest the following procedure for writing a new application
program using TAO:

\begin{enumerate}
\item Install TAO according to the instructions in
  \url{http://www.mcs.anl.gov/tao/documentation/installation.html}.
\item Copy the examples and makefile from the directory
  \url{${TAO\_DIR}/examples}, %$
  compile the examples, and run the programs. 
\item Select the example program matching the application most
  closely, and use it as a starting point for developing a customized
  code.
\end{enumerate}

\section{A Simple TAO Example}
\label{sec:simple}

To help the user start using TAO immediately, we introduce here a simple
uniprocessor example. Please read Section~\ref{chapter:tao_solver} for a 
more in-depth discussion on using the TAO solvers.
The code presented in Figure~\ref{fig:example1} minimizes the
extended Rosenbrock function $f: \Re^n \to \Re$ defined by
\[
 f(x) = 
 \sum_{i=0}^{m-1} \left( \alpha(x_{2i+1}-x_{2i}^2)^2 + (1-x_{2i})^2 \right),
\]
where $n = 2m$ is the number of variables.  Note that while we use the C 
language to introduce the TAO software, the package is fully usable from 
C++ and Fortran77/90.  Section~\ref{chapter:fortran} discusses additional 
issues concerning Fortran usage.

\afterpage{
\begin{figure}[H]
  {\footnotesize \verbatiminput{rosenbrock1.c}}
\caption{Example of Uniprocessor TAO Code\label{fig:example1}}
\end{figure}
}


The code in Figure~\ref{fig:example1} contains many of the components
needed to write most TAO programs and thus, is illustrative of the
features present in complex optimization problems.  Note that for
display purposes we have omitted some non-essential lines of code as well as the
(essential) code required for the routine \texttt{FormFunctionGradient},
which evaluates the function and gradient, and the code for
\texttt{FormHessian}, which evaluates the Hessian matrix for Rosenbrock's
function. The complete code is available in \url{$TAO\_DIR/src/unconstrained/examples/tutorials/rosenbrock1.c}. %$
The following sections annotates the lines of code in
Figure~\ref{fig:example1}.

\section{Include Files}

The include file for TAO should be used via the statement
\begin{verbatim}
   #include "tao.h"
\end{verbatim}
\noindent
The required lower level include files are automatically included
within this high-level file.

\section{TAO Initialization}
\label{sec:initialization}

All TAO programs contain a call to \findex{TaoInitialize()}
\begin{verbatim}
   ierr = TaoInitialize(int *argc,char ***argv,char *file_name, 
                        char *help_message);
\end{verbatim}
\noindent 
This command initializes TAO (and also MPI and PETSc if these have not
yet been initialized elsewhere).  The arguments \texttt{argc} and
\texttt{argv} are the command line arguments delivered in all C and
C++ programs. \sindex{command line arguments} The argument
\texttt{file\_name} optionally indicates an alternative name for an
options file, which by default is called \texttt{.petscrc} and resides
in the user's home directory.  See the PETSc users manual 
\cite{petsc-user-ref} for details
regarding runtime option specification.  The final argument,
\texttt{help\_message}, is an optional character string that will be
printed if the program is run with the \texttt{-help} option.

As illustrated by the \texttt{TaoInitialize()} statement above, TAO
routines return an integer indicating whether an error has occurred
during the call.  The error code is set to be nonzero if an error has
been detected; otherwise, it is zero.  For the C or C++ interface, the
error variable is the routine's return value, while for the Fortran
version, each TAO routine has as its final argument an integer error
variable.  Error tracebacks are discussed in
Section~\ref{sec:tao_programming}.

\section{TAO Finalization}

All TAO programs should call \texttt{TaoFinalize()}
\findex{TaoFinalize()} as their final (or nearly final) statement
\findex{TaoFinalize()}
\begin{verbatim}
   TaoFinalize();
\end{verbatim}
\noindent
This routine handles options to be called at the conclusion of the
program, and calls \texttt{PetscFinalize()} %\findex{PetscFinalize()}
if \texttt{TaoInitialize()} began PETSc. If PETSc was initiated
externally from TAO (by either the user or another software package),
the user is responsible for calling \texttt{PetscFinalize()}.

\section{TAO Solvers}

The primary commands for solving an unconstrained optimization problem
using TAO are shown in Figure \ref{fig:tao_commands}.
\findex{TaoCreate()} \findex{TaoSetObjectiveAndGradientRoutine()}
\findex{TaoSetRoutine()} \findex{TaoSolve()}
\findex{TaoDestroy()} \findex{TaoSetInitialVector()}

\begin{figure}[H]
\begin{verbatim}
   TaoCreate(MPI_Comm comm, TaoSolver *tao); 
   TaoSetType(TaoSolver tao, TaoSolverType type);
   TaoSetInitialVector(TaoSolver tao, Vec x);
   TaoSetObjectiveAndGradientRoutine(TaoSolver tao, 
        PetscErrorCode (*FormFGradient)(TaoSolver,Vec,PetscReal*,Vec,void*), 
        void *user);
   TaoSetHessianRoutine(TaoSolver tao, Mat H, Mat Hpre,
        PetscErrorCode (*FormHessian)(TaoSolver,Vec,Mat*,Mat*,MatStructure*,
        void*), void *user);
   TaoSolve(TaoSolver tao);
   TaoDestroy(TaoSolver tao);
\end{verbatim}
\caption{Commands for solving an unconstrained optimization problem
\label{fig:tao_commands}}
\end{figure}

\noindent
The user first creates the \texttt{TaoSolver} context. 
Call-back routines as well as vector (\texttt{Vec}) and matrix (\texttt{Mat}) 
data structures are then set.  These call-back routines will be use for 
evaluating the minimization function, gradient, and optionally the Hessian 
matrix.  The user then solves the minimization problem, and finally destroys
the \texttt{TaoSolver} context.  Details of these commands are presented in
Chapter~\ref{chapter:tao_solver}.

Note that the solver algorithm selected through the function 
\texttt{TaoSetType()} can be overridden
at runtime by using an options database.  Through this
database, the user not only can select a minimization method (e.g.,
limited-memory variable metric, conjugate gradient, Newton with line
search or trust region), but also can prescribe the convergence
tolerance, set various monitoring routines, set iterative methods
and preconditions for solving the linear systems, etc.  See 
Chapter~\ref{chapter:tao_solver} for more information on the 
solver methods available in TAO.

\section{Function Evaluations}

Users of TAO are required to provide routines that perform function
evaluations. Depending on the solver chosen, they may also have to
write routines that evaluate the gradient vector and Hessian matrix.

\section{Programming with PETSc}
\label{sec:tao_programming}
TAO relies heavily on PETSc not only for its vectors, matrices, and linear
solvers, but also for its programming utilities such as command line option 
handling, error handling, and compiling system.  We provide here a quick 
overview of some of these PETSc features.  Please reference the PETSc 
manual \cite{petsc-user-ref} for a more in-depth
discussion of PETSc.

\subsection*{Vectors}

In the example in Figure \ref{fig:example1}, the vector data structure
(\texttt{Vec}) is used to store the solution and gradient for the TAO
unconstrained minimization solvers.  A new parallel or sequential
vector \texttt{x} of global dimension \texttt{M} is created with the
command % \findex{VecCreate()} \sindex{vectors}
\begin{verbatim}
   info = VecCreate(MPI_Comm comm,int m,int M,Vec *x);
\end{verbatim}
\noindent
where \texttt{comm} denotes the MPI communicator. The type of storage
for the vector may be set with either calls to \texttt{VecSetType()}
or \texttt{VecSetFromOptions()}.  Additional vectors of the same type
can be formed with % \findex{VecSetType()} \findex{VecSetFromOptions} \findex{VecDuplicate()}
\begin{verbatim}
   info = VecDuplicate(Vec old,Vec *new);
\end{verbatim}
\noindent
The commands % \findex{VecSet()} \findex{VecSetValues()}
\begin{verbatim}
   info = VecSet(Vec X,PetscScalar value);
   info = VecSetValues(Vec x,int n,int *indices,
                       Scalar *values,INSERT_VALUES);
\end{verbatim}
\noindent
respectively set all the components of a vector to a particular scalar
value and assign a different value to each component.  More detailed
information about PETSc vectors, including their basic operations,
scattering/gathering, index sets, and distributed arrays, may be found
in the PETSc users manual \cite{petsc-user-ref}.

\subsection*{Matrices}

Usage of matrices and vectors is similar. \sindex{matrix} 
The user can create a new parallel or sequential matrix \texttt{H} with 
\texttt{M} global rows and \texttt{N} global columns, with the routines
%\findex{MatCreate()}
\begin{verbatim}
   ierr = MatCreate(MPI_Comm comm,Mat *H);
   ierr = MatSetSizes(H,PETSC_DECIDE,PETSC_DECIDE,M,N);
\end{verbatim}
\noindent
where the matrix format can be specified at runtime.  The user could
alternatively specify each processes' number of local rows and columns
using \texttt{m} and \texttt{n} instead of \texttt{PETSC\_DECIDE}.  
\texttt{H} can then be used to store
the Hessian matrix, as indicated by the call to
\texttt{TaoSetHessianMat()}.  Matrix entries can be set with the
command
\begin{verbatim}
   ierr = MatSetValues(Mat H,PetscInt m,PetscInt *im, PetscInt n,
                       PetscInt *in, PetscScalar *values,INSERT_VALUES);
\end{verbatim}
\noindent
After %\findex{MatSetValues()} 
all elements have been inserted into the
matrix, it must be processed with the pair of commands
%\findex{MatAssemblyBegin()} \findex{MatAssemblyEnd()}
\begin{verbatim}
   ierr = MatAssemblyBegin(Mat H,MAT_FINAL_ASSEMBLY);
   ierr = MatAssemblyEnd(Mat H,MAT_FINAL_ASSEMBLY);
\end{verbatim}
\noindent
The PETSc users manual \cite{petsc-user-ref} discusses
various matrix formats as
well as the details of some basic matrix manipulation routines.


\subsection*{The Options Database}
\label{sec:options}
A TAO application can access the command line options presented at
runtime through the PETSc options database. This database gives the application
author the ability to set and change application parameters without
the need to recompile the application. For example, 
an application may have a grid discretization parameter \texttt{nx}
which can be set with the command line option \texttt{-nx <integer>}.
The application can read this option with the following line of code:
\begin{verbatim}
   PetscOptionsGetInt(PETSC_NULL, "-nx", &nx, &flg);
\end{verbatim}
\noindent
If the command line option is present, the variable \texttt{nx} is set
accordingly; otherwise, \texttt{nx} remains unchanged. A complete
description of the options database may be found in the PETSc users
manual \cite{petsc-user-ref}.

\subsection*{Error Checking}

All TAO commands begin with the \texttt{Tao} prefix and return an
integer indicating whether an error has occurred during the call.  The
error code equals zero after the successful completion of the routine
and is set to a nonzero value if an error has been detected.  The
macro \texttt{CHKERRQ(ierr)} checks the value of \texttt{ierr} and calls an
error handler upon error detection.  \texttt{CHKERRQ()} should be used after
all subroutines to enable a complete error traceback.

In Figure \ref{fig:traceback} we indicate a traceback generated by
error detection within a sample program. The error occurred on line
2110 of the file \texttt{\$\{PETSC\_DIR\}/src/mat/inter\-face/mat\-rix.c} in the
routine \texttt{MatMult()} and was caused by failure to assemble the 
matrix in the Hessian evaluation routine.
The \texttt{MatMult()} routine was called from
the \texttt{TaoSolve\_NLS()} routine, which was in turn called on line 
154 of \texttt{TaoSolve()}, called from the \texttt{main()} routine 
in the program \texttt{rosenbrock1.c}.  The PETSc users
manual \cite{petsc-user-ref}provides further details
regarding error checking, including
information about error handling in Fortran.

\begin{figure}[htb]
{\footnotesize
\begin{verbatim}
> rosenbrock1 -tao_method tao_nls
[0]PETSC ERROR: --------------------- Error Message ------------------------------------
[0]PETSC ERROR: Object is in wrong state!
[0]PETSC ERROR: Not for unassembled matrix!
[0]PETSC ERROR: ------------------------------------------------------------------------
[0]PETSC ERROR: Petsc Development HG revision: b95ffff514b66a703d96e6ae8e78ea266ad2ca19
[0]PETSC ERROR: See docs/changes/index.html for recent updates.
[0]PETSC ERROR: See docs/faq.html for hints about trouble shooting.
[0]PETSC ERROR: See docs/index.html for manual pages.
[0]PETSC ERROR: ------------------------------------------------------------------------
[0]PETSC ERROR: Libraries linked from petsc-dev/arch-linux2-c-debug/lib
[0]PETSC ERROR: Configure run at Tue Jul 19 14:13:14 2011
[0]PETSC ERROR: Configure options --with-shared-libraries --with-dynamic-loading
[0]PETSC ERROR: ------------------------------------------------------------------------
[0]PETSC ERROR: MatMult() line 2110 in petsc-dev/src/mat/interface/matrix.c
[0]PETSC ERROR: TaoSolve_NLS() line 291 in src/unconstrained/impls/nls/nls.c
[0]PETSC ERROR: TaoSolve() line 154 in src/interface/taosolver.c
[0]PETSC ERROR: main() line 94 in src/unconstrained/examples/tutorials/rosenbrock1.c
application called MPI_Abort(MPI_COMM_WORLD, 73) - process 0
\end{verbatim}
}
\caption{Example of Error Traceback}
\label{fig:traceback}
\end{figure}

When running the debugging version of the TAO software (PETSc configured 
with the (default) \texttt{--with-debugging} option), checking is performed for 
memory corruption
(writing outside of array bounds, etc). The macros \texttt{CHKMEMQ} and
\texttt{CHKMEMA} can be called anywhere in the code, and when used together 
with the command line option \texttt{-malloc\_debug} check the current
status of the memory for corruption.  By putting several (or many) of
these macros into an application code, one can usually track
down the code segment where corruption has occurred.

\subsection*{Parallel Programming}

Since TAO uses the message-passing model for parallel programming and
employs MPI for all interprocessor communication, the user is free to
employ MPI routines as needed throughout an application code.
However, by default the user is shielded from many of the details of
message passing within TAO, since these are hidden within parallel
objects, such as vectors, matrices, and solvers.  In addition, TAO
users can interface to external tools, such as the generalized vector
scatters/gathers and distributed arrays within PETSc, to assist in the
management of parallel data.

%\sindex{collective operations} 
The user must specify a communicator
upon creation of any PETSc or TAO object (such as a vector, matrix, or 
solver)
to indicate the processors over which the object is to be distributed. 
For example, some commands for matrix, vector, and solver creation
are:
\begin{verbatim}
   ierr = MatCreate(MPI_Comm comm,Mat *H);
   ierr = VecCreate(MPI_Comm comm,Vec *x);
   ierr = TaoCreate(MPI_Comm comm,TaoSolver *tao); 
\end{verbatim}
\noindent
In most cases, the value for \texttt{comm} will be either 
\texttt{PETSC\_COMM\_SELF} for single-process objects or 
\texttt{PETSC\_COMM\_WORLD} for objects distributed over all processors.
The creation routines are collective over all processors in the
communicator; thus, all processors in the communicator {\em must} call
the creation routine.  In addition, if a sequence of collective
routines is being used, the routines {\em must} be called in the same
order on each processor.

\section{Compiling and Running TAO}
\label{sec:running}

Compilation of the TAO numerical libraries and TAO application codes
requires three environmental variables to be set. \texttt{PETSC\_ARCH} and \texttt{PETSC\_DIR} must be identical to the values used when compiling PETSc, \texttt{TAO\_DIR} must be set to top level of the TAO directory tree. These three
variables are discussed in greater detail in the TAO installation 
instructions (\url{http:\\www.mcs.anl.gov/tao/documentation/installation.html}).

TAO uses a portable makefile system provided by the
PETSc~\cite{petsc-web-page,petsc-user-ref} library, which is discussed
further in Section~\ref{sec:makefiles}.  The TAO library can be
compiled with the command
\begin{verbatim}
   make
\end{verbatim}
\noindent
from the \texttt{TAO\_DIR} directory.  

Running a TAO application on a single processor can be done in the
usual way by entering the name of the executable and any command line
options.  Running programs in parallel, however, requires use of the
MPI library.  All TAO programs use the MPI (Message Passing Interface)
standard for message-passing communication \cite{MPI-final}.  Thus, to
execute TAO programs, users must know the procedure for beginning MPI
jobs on their selected computer system(s).  For instance, when using
the MPICH implementation of MPI \cite{mpich-web-page} and many others,
the following command initiates a program that uses eight processors:
%\findex{mpiexec} \sindex{running TAO programs} 
\begin{verbatim}
  mpiexec -np 8 tao_program_name tao_options
\end{verbatim}



\subsection*{Makefiles}
\label{sec:makefiles}

To manage code portability across a wide variety of UNIX systems, TAO
uses a makefile system that is integrated with the PETSc makefile system.  This
section briefly discusses makefile usage from the perspective of
application programmers; see the ``makefiles'' chapter of the PETSc
users manual  \cite{petsc-user-ref} for additional
details.

In Figures \ref{fig:make3} we present a sample makefile.

\begin{figure}[tbh]
{\footnotesize
\begin{verbatim}   
       CFLAGS    = 
       FFLAGS    = 
       CPPFLAGS  =
       FPPFLAGS  =
       
       include ${TAO_DIR}/conf/tao_base
   
       minsurf1: minsurf1.o tao_chkopts
            -${CLINKER} -o minsurf1 minsurf1.o ${TAO_LIB} ${PETSC_LIB}
            ${RM} minsurf1.o
\end{verbatim} 
% $
\noindent
}
\caption{Sample TAO makefile for a C application}
\label{fig:make3}
\end{figure}

This small makefile is suitable for maintaining a  program that
uses the TAO library.  The most important line in this makefile is the
line starting with {\tt include}:
\findex{TAO_LIB}
\begin{verbatim}
   include ${TAO_DIR}/conf/tao_base
\end{verbatim}
\noindent % $
This line includes other makefiles that provide the needed definitions
and rules for the particular base software installations (specified by
{\tt TAO\_DIR} and {\tt PETSC\_DIR}) and architecture
(specified by {\tt PETSC\_ARCH}), which are typically set as
environmental variables prior to compiling TAO source or programs.
 
Some additional variables that can be used in the makefile are defined
as follows:
\begin{itemize}
\item \texttt{CFLAGS, FFLAGS} - user-specified additional options for the
  C/C++ compiler and Fortran compiler.
\item \texttt{CPPFLAGS, FPPFLAGS} - user-specified additional flags
        for the C/C++ preprocessor and Fortran preprocesor.
\item \texttt{CLINKER, FLINKER} - the C/C++ and Fortran linkers. 
\item \texttt{RM} - the remove command for deleting files.
\item \texttt{TAO\_LIB} - the TAO library flags
             \findex{TAO_LIB}
\item \texttt{PETSC\_LIB} - the PETSc library flags
\end{itemize}

\section{Directory Structure}

The home directory of TAO contains the following subdirectories:

\begin{itemize}
\item \texttt{docs} - All documentation for TAO. The files \texttt{tao\_manual.pdf}
                   and \texttt{manual/manual.html} contain the users manual in
                   PDF and HTML formats, respectively. Includes
                   the subdirectory
 \subitem - \texttt{manpages} (manual pages for individual TAO routines).
% \item \texttt{bin} - Utilities and short scripts for use with TAO, including
\item \texttt{conf} - Base TAO makefile directory.  
\item \texttt{include} - All include files for TAO that are visible to the user.
\item \texttt{examples} - Example problems and makefile.
% \item \texttt{include/finclude}    - TAO include files for Fortran programmers using 
%                                   the .F suffix (recommended).
% \item \texttt{include/pinclude}    - Private TAO include files that should {\em not} 
%                                  be used by application programmers.
\item \texttt{src} - The source code for all TAO components, which
                  currently includes
 \begin{itemize}
 \item \texttt{unconstrained} - unconstrained minimization,
 \item \texttt{bound} - bound-constrained minimization.
 \item \texttt{least\_squares} - nonlinear least squares,
 \item \texttt{complementarity} - mixed complementarity solvers
 \item \texttt{pde\_constrained} - pde-constrained solvers.
 \end{itemize}
\end{itemize}

\noindent
Each TAO source code component directory has the following subdirectories:
\begin{itemize}
\item  \texttt{examples} - Example programs for the component, including
  \begin{itemize}
  \item \texttt{tutorials} - Programs designed to teach users about TAO.  These
          codes can serve as templates for the design of custom
applications.
  \end{itemize}
\item  \texttt{interface} - The calling sequences for the abstract interface  
        to the component.
        Code here does not know about particular implementations.
\item  \texttt{impls} - Source code for one or more implementations.
\item  \texttt{utils} - Utility routines.  Source here may know about the 
          implementations, but ideally will not know about implementations
          for other components.
\end{itemize}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual_tex"
%%% End: 
